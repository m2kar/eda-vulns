[{"body":"Hi! Now I try to add types and operators in sim to get the lowered operators in moore, and then lower them to llvm dialect, so that the corresponding dynamic size container can be implemented in arcilator.\n\nFirst, add IntType and RefType in sim, as well as VariableOp, BlockAssignOp, Print, ReadOp, and ConcatOp operators.\nTaking Variable as an example, creating a stringtype VariableOp in Moore will create an int type through string_constant, and then perform conversionOp to convert the int type to Stringtype, and finally create VariableOp. In sim, if VariableOp can directly accept int type, the conversion time can be saved. Therefore, I think it is not necessary to add StringType separately, and only use Int Type and RefType to represent it.\n\nIn sim to llvm dialect, VariableOp will be converted into a series of Ops. First, llvm.alloca will be used to create an i128 memory, which will be divided into i32 size to record the string length, and i96 data to record the string content. Then, llvm.getelementptrOp and llvm.storeOp are used to store the contents in the corresponding locations. This memory will be dynamically doubled according to the length of the string.\n\nCan you give me some advise?","createdAt":"2025-03-20T02:36:53Z","labels":[],"number":8332,"state":"OPEN","title":"[MooreToCore] Support for StringType from moore to llvm dialect","url":"https://github.com/llvm/circt/issues/8332"},{"body":"Unsized array type in systemverilog like `OpenArrayType`, `QueueType` can't be lower to Arc Dialect, because Arc only has sized array type. \n\nCommon programming language like `Cpp` can directly call `mmap` provided by OS to get dynamic size array. I can't see this kind of ability in systemverilog.\n\nSo how to achieve that if we want to solve #8276? Can you give me some advice?","createdAt":"2025-03-04T15:38:48Z","labels":[],"number":8292,"state":"OPEN","title":"[MooreToCore] Support for Unsized Array Type","url":"https://github.com/llvm/circt/issues/8292"},{"body":"# Issue\n\n**Related**: https://github.com/llvm/circt/issues/6399\n\nIn `FIRRTLOps.cpp`, `FModuleLike` has two seemingly similiar operations called `getPorts()` and `getPort(size_t)`. `getPorts()` works reliably, but `getPort(size_t)` can crash `firtool` (and `circt-opt`) with an assertion failure when the port does not have a symbol.\n\n## Reproduction\n\nGiven following pass,\n\n```cpp\nnamespace {\nstruct GetPortExperimentPass\n    : public GetPortExperimentBase<GetPortExperimentPass> {\n  void runOnOperation() override {\n    CircuitOp circuit = getOperation();\n    OpBuilder classBuilder(circuit);\n    classBuilder.setInsertionPointToStart(circuit.getBodyBlock());\n\n    ClassOp generatedWithPort =\n        createSimpleClassWithPortSym(&circuit, classBuilder);\n    printOutClassOpPorts(generatedWithPort);\n\n    ClassOp generatedWithoutPort =\n        createSimpleClassWithoutPortSym(&circuit, classBuilder);\n    printOutClassOpPorts(generatedWithoutPort);\n  }\n\nprivate:\n  void printOutClassOpPorts(ClassOp &generated) {\n    LLVM_DEBUG(llvm::dbgs() << \"Found ports with getPorts() API: \\n\");\n    for (auto port : generated.getPorts())\n      LLVM_DEBUG(llvm::dbgs() << \"- \" << port.name << \"\\n\");\n\n    LLVM_DEBUG(llvm::dbgs() << \"Direct access with getPort(size_t): \\n\");\n    LLVM_DEBUG(llvm::dbgs() << \"- \" << generated.getPort(0).name << \"\\n\");\n    LLVM_DEBUG(llvm::dbgs() << \"- \" << generated.getPort(1).name << \"\\n\");\n  }\n\n  ClassOp createSimpleClassWithoutPortSym(CircuitOp *circuit,\n                                          OpBuilder builder) {\n    MLIRContext *context = circuit->getContext();\n\n    StringType portType = StringType::get(context);\n    PortInfo nameOut(StringAttr::get(context, \"name\"), portType,\n                     Direction::Out);\n    PortInfo nameIn(StringAttr::get(context, \"nameIn\"), portType,\n                    Direction::In);\n    const SmallVector<PortInfo, 2> instInfoPorts = {nameOut, nameIn};\n\n    ClassOp instInfoClass = builder.create<ClassOp>(\n        circuit->getLoc(), StringAttr::get(context, \"ClassWithoutPortSym\"),\n        instInfoPorts);\n\n    // PropAssign is deliberately omitted to minimize the reproduction code.\n    return instInfoClass;\n  }\n\n  ClassOp createSimpleClassWithPortSym(CircuitOp *circuit, OpBuilder builder) {\n    MLIRContext *context = circuit->getContext();\n\n    StringType portType = StringType::get(context);\n    StringAttr nameAttr = StringAttr::get(context, \"name\");\n    PortInfo nameOut(nameAttr, portType, Direction::Out, nameAttr);\n\n    StringAttr nameInAttr = StringAttr::get(context, \"nameIn\");\n    PortInfo nameIn(nameInAttr, portType, Direction::In, nameInAttr);\n    const SmallVector<PortInfo, 2> instInfoPorts = {nameOut, nameIn};\n\n    ClassOp instInfoClass = builder.create<ClassOp>(\n        circuit->getLoc(), StringAttr::get(context, \"ClassWithPortSym\"),\n        instInfoPorts);\n\n    // PropAssign is deliberately omitted to minimize the reproduction code.\n    return instInfoClass;\n  }\n};\n} // namespace\n```\n\nUsing this trivial input:\n\n```\nfirrtl.circuit \"BlankModule\" {\n    firrtl.module @BlankModule() {}\n}\n```\n\nThe generated IR is\n\n```\nmodule {\n  firrtl.circuit \"BlankModule\" {\n    firrtl.class @ClassWithPortSym(out %name: !firrtl.string sym @name, in %nameIn: !firrtl.string sym @nameIn) {\n    }\n    firrtl.class @ClassWithoutPortSym(out %name: !firrtl.string, in %nameIn: !firrtl.string) {\n    }\n    firrtl.module @BlankModule() {\n    }\n  }\n}\n```\n\n**Behavior**:\n- **Without debug option**: No crashes.\n- **With debug** (`--debug` or `--debug-only=<pass>`): accessing ports via `getPort(size_t)` on the symbol-less class causes an assertion failure.\n\n```\nFound ports with getPorts() API: \n- \"name\"\n- \"nameIn\"\nDirect access with getPort(size_t): \n- \"name\"\n- \"nameIn\"\nFound ports with getPorts() API: \n- \"name\"\n- \"nameIn\"\nDirect access with getPort(size_t): \n- circt-opt: /home/nergy-host/circt/llvm/mlir/lib/IR/Attributes.cpp:45: mlir::NamedAttribute::NamedAttribute(mlir::StringAttr, mlir::Attribute): Assertion `name && value && \"expected valid attribute name and value\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.      Program arguments: ./circt-opt --firrtl-port-experiment ./temp/blank.mlir --debug-only=get-port-experiment\n #0 0x00007339e58b281d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/nergy-host/circt/llvm/llvm/lib/Support/Unix/Signals.inc:723:11\n #1 0x00007339e58b2d0b PrintStackTraceSignalHandler(void*) /home/nergy-host/circt/llvm/llvm/lib/Support/Unix/Signals.inc:798:1\n #2 0x00007339e58b0d36 llvm::sys::RunSignalHandlers() /home/nergy-host/circt/llvm/llvm/lib/Support/Signals.cpp:105:5\n #3 0x00007339e58b3525 SignalHandler(int) /home/nergy-host/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\n #4 0x00007339e3c42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #5 0x00007339e3c969fc __pthread_kill_implementation ./nptl/./nptl/pthread_kill.c:44:76\n #6 0x00007339e3c969fc __pthread_kill_internal ./nptl/./nptl/pthread_kill.c:78:10\n #7 0x00007339e3c969fc pthread_kill ./nptl/./nptl/pthread_kill.c:89:10\n #8 0x00007339e3c42476 gsignal ./signal/../sysdeps/posix/raise.c:27:6\n #9 0x00007339e3c287f3 abort ./stdlib/./stdlib/abort.c:81:7\n#10 0x00007339e3c2871b _nl_load_domain ./intl/./intl/loadmsgcat.c:1177:9\n#11 0x00007339e3c39e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n#12 0x000062b0bb4b15d1 mlir::NamedAttribute::NamedAttribute(mlir::StringAttr, mlir::Attribute) /home/nergy-host/circt/llvm/mlir/lib/IR/Attributes.cpp:46:3\n```\n\nNote that `getPort(size_t)` works fine when `symName` was supplied, as shown on first case but crashes otherwise.\n\n## Analysis\n\n`getPorts()` constructs `firrtl::PortInfo` with `getPortSymbolAttr(i)` directly.\n```cpp\nstatic SmallVector<PortInfo> getPortImpl(FModuleLike module) {\n  SmallVector<PortInfo> results;\n  for (unsigned i = 0, e = module.getNumPorts(); i < e; ++i) {\n    results.push_back({module.getPortNameAttr(i), module.getPortType(i),\n                       module.getPortDirection(i), module.getPortSymbolAttr(i),\n                       module.getPortLocation(i),\n                       AnnotationSet::forPort(module, i)});\n  }\n  return results;\n}\n\nSmallVector<PortInfo> FModuleOp::getPorts() { return ::getPortImpl(*this); }\n\n// ...\n```\n\nwhile `getPort(size_t)` constructs `hw::PortInfo` with `NamedAttribute`. Whenever `getPortSymbolAttr(idx)` is null, this will trigger assertion.\n```cpp\nstatic hw::PortInfo getPortImpl(FModuleLike module, size_t idx) {\n  return {{module.getPortNameAttr(idx), module.getPortType(idx),\n           dirFtoH(module.getPortDirection(idx))},\n          idx,\n          DictionaryAttr::get(\n              module.getContext(),\n              ArrayRef<mlir::NamedAttribute>{NamedAttribute{\n                  StringAttr::get(module.getContext(),\n                                  hw::HWModuleLike::getPortSymbolAttrName()),\n                  module.getPortSymbolAttr(idx)}}),\n          module.getPortLocation(idx)};\n}\n\n::circt::hw::PortInfo FModuleOp::getPort(size_t idx) {\n  return ::getPortImpl(*this, idx);\n}\n\n// ...\n```\n\nThis code was originated from https://github.com/llvm/circt/commit/8722a98a7b0464d2c95498c6e4a68e7e98e0e70d and as of 12/02/25 the `main` branch remains unchanged. (https://github.com/llvm/circt/blame/main/lib/Dialect/FIRRTL/FIRRTLOps.cpp)\n\n# Reason this issue should be fixed\n\nEven though it's a small issue, it's easy to trip over for unexperienced developers.\n\n- One API silently assumes that a symbol must exist, without documenting that requirement.\n- As a result, this result can surprise newcomers.\n\n# Possible workarounds\n\n1. **Supply the optional `symName` or `hw::InnerSymAttr` when constructing `PortInfo`.**\n\n```cpp\n    StringType portType = StringType::get(context);\n    StringAttr nameAttr = StringAttr::get(context, \"name\");\n    PortInfo nameOut(nameAttr, portType, Direction::Out, nameAttr);\n```\n\n2.  **Use `getPorts()` and index access instead.** (This returns `firrtl::PortInfo`)\n\n```cpp\ngenerated.getPorts()[2]\n```","createdAt":"2025-12-02T03:07:09Z","labels":[],"number":9278,"state":"CLOSED","title":"[FIRRTL] Confusing API between `getPort(size_t)` and `getPorts`","url":"https://github.com/llvm/circt/issues/9278"},{"body":"It's time to create a string type in HW. Will be used for module parameterization and format strings to start.","createdAt":"2023-07-12T22:18:16Z","labels":[{"id":"MDU6TGFiZWwyMTUyNzU0NzU0","name":"HW","description":"Involving the `hw` dialect","color":"081f7a"}],"number":5576,"state":"CLOSED","title":"[HW] String type","url":"https://github.com/llvm/circt/issues/5576"}]
[{"body":"Making this issue for tracking as I gradually replace all the uses of to_builtin_bool with to_builtin_int (not totally trivial since we now have to explicitly cast to int type), as I'll split it across PRs to keep the diffs small and make sure I'm not missing anything\n\nPlaces to change:\n- [x] Assertion builtin handling\n- [ ] AssertionExpr.cpp convertToI1 function\n- [ ] Statements.cpp conditions\n- [ ] MooreToCore","createdAt":"2026-01-29T18:09:01Z","labels":[],"number":9542,"state":"OPEN","title":"[Moore] to_builtin_bool should be replaced with to_builtin_int","url":"https://github.com/llvm/circt/issues/9542"},{"body":"## Description\n\nCIRCT crashes with assertion `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"` when compiling SystemVerilog modules that use packed union types as module ports.\n\n**Likely cause**: MooreToCore conversion pass lacks a type conversion rule for packed union types (`UnionType`). When processing module ports, the type converter fails to convert `UnionType`, resulting in an invalid/null type that causes assertion failures in downstream port processing code (`getModulePortInfo` at line 259).\n\n> **Validation**: Test case accepted by: verilator, iverilog, slang\n> **IEEE 1800-2005**: Packed unions are valid (Section 7.3)\n\n## Steps to Reproduce\n\n1. Save following code as `bug.sv`\n2. Run: `circt-verilog --ir-hw bug.sv`\n\n## Test Case\n\n```systemverilog\ntypedef union packed {\n  logic [31:0] a;\n  logic [31:0] b;\n} my_union;\n\nmodule Sub(input my_union in_val, output my_union out_val);\n  assign out_val = in_val;\nendmodule\n\nmodule Top;\n  my_union data_in, data_out;\n  \n  Sub s(.in_val(data_in), .out_val(data_out));\nendmodule\n```\n\n## Error Output\n\n```\n #4 0x00007f8176f898ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007f8176f89b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007f8176f89530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n```\n\n<details>\n<summary>Full Stack Trace</summary>\n\n```\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.      Program arguments: /opt/firtool/bin/circt-verilog --ir-hw bug.sv\n #0 0x00007f8172d678a8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x2008a8)\n #1 0x00007f8172d652f5 llvm::sys::RunSignalHandlers() (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x1fe2f5)\n #2 0x00007f8172d68631 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x00007f8172875330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #4 0x00007f8176f898ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007f8176f89b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007f8176f89530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n #7 0x00007f817529b438 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2a438)\n #8 0x00007f81752658ed void llvm::function_ref<void ()>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_0>(long) PatternApplicator.cpp:0:0\n #9 0x00007f8175262774 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/opt/firtool-1.139.0/bin/../lib/libMLIRRewrite.so+0x7774)\n#10 0x00007f817529cc6f (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*) DialectConversion.cpp:0:0\n#11 0x00007f817529c470 mlir::OperationConverter::convert(mlir::Operation*, bool) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2b470)\n#12 0x00007f817529cdae mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2bdae)\n#13 0x00007f81752aa8e4 void llvm::function_ref<void ()>::callback_fn<applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode)::$_0>(long) DialectConversion.cpp:0:0\n#14 0x00007f81752a1f7d applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode) DialectConversion.cpp:0:0\n#15 0x00007f81752a20fe mlir::applyFullConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x310fe)\n#16 0x00007f8176f5b231 (anonymous namespace)::MooreToCorePass::runOnOperation() MooreToCore.cpp:0:0\n#17 0x00007f81750572a5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x172a5)\n#18 0x00007f817505a7a9 mlir::PassManager::run(mlir::Operation*) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x1a7a9)\n#19 0x0000563df3daf5d0 executeWithSources(mlir::MLIRContext*, llvm::SourceMgr&) circt-verilog.cpp:0:0\n#20 0x0000563df3daadd5 execute(mlir::MLIRContext*) circt-verilog.cpp:0:0\n#21 0x0000563df3daa4b8 main (/opt/firtool/bin/circt-verilog+0x84b8)\n#22 0x00007f817285a1ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#23 0x00007f817285a28b call_init ./csu/../csu/libc-start.c:128:20\n#24 0x00007f817285a28b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#25 0x0000563df3da9b05 _start (/opt/firtool/bin/circt-verilog+0x7b05)\n[1]    1143009 segmentation fault (core dumped)  /opt/firtool/bin/circt-verilog --ir-hw bug.sv\n\n```\n\n</details>\n\n## Root Cause Analysis\n\n- **Dialect**: Moore\n- **Failing Pass**: MooreToCore\n\n### Hypotheses\n\n1. **Missing UnionType type conversion rule** (confidence: high)\n   - Evidence: [\"Test case uses 'typedef union packed' as module port type\", 'Stack trace shows crash in getModulePortInfo during port processing at line 259', \"Assertion message indicates 'dyn_cast<InOutType>' failed on non-existent value\", 'No conversion rule for UnionType exists in populateTypeConversion function (lines 2268-2409)', 'Similar types like StructType have conversion rules, but UnionType does not', 'Both UnionType and StructType implement DestructurableTypeInterface, suggesting they should be handled similarly']\n   - Mechanism: The typeConverter fails to convert UnionType when processing module ports, resulting in an invalid type that causes assertion failures\n\n2. **Type converter returns invalid non-null type** (confidence: medium)\n   - Evidence: [\"Line 245-248 checks 'if (!portTy)' and emits error\", 'However, crash still occurs, suggesting either the check is not being reached or the type is non-null but invalid', 'The assertion occurs in a different code path that may not be covered by the initial null check']\n   - Mechanism: The typeConverter may return a non-null type with incorrect MLIR type ID or metadata\n\n## Environment\n\n- **CIRCT Version**: LLVM (http://llvm.org/):\n  LLVM version 22.0.0git\n  Optimized build.\nCIRCT firtool-1.139.0\nslang version 9.1.0+0\n\n---\n**Labels**: bug, Moore","createdAt":"2026-02-01T02:15:22Z","labels":[],"number":9570,"state":"OPEN","title":"[Moore] Assertion in MooreToCore when module uses packed union type as port","url":"https://github.com/llvm/circt/issues/9570"},{"body":"## Bug Description\n\n`circt-verilog` crashes with an assertion failure when processing a SystemVerilog module that has a `string` type output port. The crash occurs during the MooreToCore conversion pass when the `getModulePortInfo()` function fails to properly handle cases where type conversion returns an invalid/empty type, causing a `dyn_cast` assertion failure in `ModulePortInfo::sanitizeInOut()`.\n\nThis is a valid SystemVerilog construct per IEEE 1800-2017 Section 6.16 (String data type). Both **slang** and **verilator** accept the code without errors.\n\n## Steps to Reproduce\n\n1. Save the following test case as `bug.sv`\n2. Run: `circt-verilog --ir-hw bug.sv`\n\n## Test Case\n\n```systemverilog\nmodule test_module(output string a);\nendmodule\n```\n\n## Expected Behavior\n\nCIRCT should either:\n1. Support simulation constructs like string ports appropriately, OR\n2. Emit a proper diagnostic error message indicating that string ports are not supported for hardware synthesis\n\n## Actual Behavior\n\nThe tool crashes with an assertion failure:\n\n```\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: circt-verilog --ir-hw bug.sv\n #0 0x00007fe810a738a8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x2008a8)\n #1 0x00007fe810a712f5 llvm::sys::RunSignalHandlers() (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x1fe2f5)\n #2 0x00007fe810a74631 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x00007fe810581330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #4 0x00007fe814c958ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007fe814c95b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007fe814c95530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n #7 0x00007fe812fa7438 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2a438)\n #8 0x00007fe812f718ed void llvm::function_ref<void ()>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_0>(long) PatternApplicator.cpp:0:0\n #9 0x00007fe812f6e774 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/opt/firtool-1.139.0/bin/../lib/libMLIRRewrite.so+0x7774)\n#10 0x00007fe812fa8c6f (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*) DialectConversion.cpp:0:0\n#11 0x00007fe812fa8470 mlir::OperationConverter::convert(mlir::Operation*, bool) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2b470)\n#12 0x00007fe812fa8dae mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2bdae)\n#13 0x00007fe812fb68e4 void llvm::function_ref<void ()>::callback_fn<applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode)::$_0>(long) DialectConversion.cpp:0:0\n#14 0x00007fe812fadf7d applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode) DialectConversion.cpp:0:0\n#15 0x00007fe812fae0fe mlir::applyFullConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x310fe)\n#16 0x00007fe814c67231 (anonymous namespace)::MooreToCorePass::runOnOperation() MooreToCore.cpp:0:0\n#17 0x00007fe812d632a5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x172a5)\n#18 0x00007fe812d667a9 mlir::PassManager::run(mlir::Operation*) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x1a7a9)\n#19 0x0000561bab9605d0 executeWithSources(mlir::MLIRContext*, llvm::SourceMgr&) circt-verilog.cpp:0:0\n#20 0x0000561bab95bdd5 execute(mlir::MLIRContext*) circt-verilog.cpp:0:0\n#21 0x0000561bab95b4b8 main (/opt/firtool-1.139.0/bin/circt-verilog+0x84b8)\n#22 0x00007fe8105661ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#23 0x00007fe81056628b call_init ./csu/../csu/libc-start.c:128:20\n#24 0x00007fe81056628b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#25 0x0000561bab95ab05 _start (/opt/firtool-1.139.0/bin/circt-verilog+0x7b05)\n\n```\n\n## Root Cause Analysis\n\n### Crash Location\n- **File**: `lib/Conversion/MooreToCore/MooreToCore.cpp`\n- **Function**: `getModulePortInfo()` → calls `ModulePortInfo::sanitizeInOut()`\n- **Assertion**: `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"`\n\n### Analysis\n\nThe root cause is **missing validation of type conversion result** in `getModulePortInfo()`:\n\n```cpp\n// MooreToCore.cpp:233-259\nstatic hw::ModulePortInfo getModulePortInfo(const TypeConverter &typeConverter,\n                                            SVModuleOp op) {\n  // ...\n  for (auto port : moduleTy.getPorts()) {\n    Type portTy = typeConverter.convertType(port.type);  // <-- May return empty Type!\n    // ...\n    ports.push_back(hw::PortInfo({{port.name, portTy, port.dir}, ...}));  // <-- Stores empty Type\n  }\n  return hw::ModulePortInfo(ports);  // <-- Constructor calls sanitizeInOut()\n}\n```\n\nWhen `typeConverter.convertType()` fails for the `string` port type (returns empty `Type`), this invalid type is passed to `sanitizeInOut()` which calls `dyn_cast<hw::InOutType>(p.type)` on the empty type, triggering the assertion.\n\n### Suggested Fix\n\nAdd validation in `getModulePortInfo()` to check if `typeConverter.convertType()` returns a valid type:\n\n```cpp\nType portTy = typeConverter.convertType(port.type);\nif (!portTy) {\n  // Emit proper diagnostic error\n  return failure();\n}\n```\n\n## Environment\n\n- **CIRCT Version**: firtool-1.139.0 (LLVM 22.0.0git)\n- **OS**: Linux 5.15.0 (x86_64)\n\n## Cross-Tool Validation\n\n| Tool | Version | Status | Notes |\n|------|---------|--------|-------|\n| slang | 10.0.6+3d7e6cd2e | ✅ Pass | Build succeeded: 0 errors, 0 warnings |\n| verilator | 5.022 | ✅ Pass | No errors |\n| iverilog | - | ❌ Error | \"Port with type string is not supported\" (tool limitation, not syntax error) |\n\nThis confirms the test case is **syntactically valid** SystemVerilog per IEEE 1800-2017.\n","createdAt":"2026-02-01T03:00:12Z","labels":[],"number":9572,"state":"OPEN","title":"[Moore] Assertion failure when module has string type output port","url":"https://github.com/llvm/circt/issues/9572"},{"body":"Is there a strong reason to go from PowUOp to math.ipow as opposed to lowering to a sequence of multiplications?\n\nIs there any existing lowering from math.ipow to the core dialects? \n\nhttps://github.com/llvm/circt/blob/83effb21cd6b1cebc060b4f57180f16683309cd9/lib/Conversion/MooreToCore/MooreToCore.cpp#L1379-L1398","createdAt":"2025-09-16T14:19:34Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8973,"state":"OPEN","title":"[MooreToCore] Lowering to math.ipow?","url":"https://github.com/llvm/circt/issues/8973"},{"body":"It failed when trying to compile https://github.com/pulp-platform/ELAU/blob/b0d113aff6a2d800076f5ebb84f09fba93625bc7/src/SqrtArrUns.sv#L96-L105. \n```\nmoore.module @behavioural_SqrtArrUns(in %X : !moore.l8, out Q : !moore.l4, out R : !moore.l4) {\n  %0 = moore.constant 2 : l8\n  %1 = moore.conversion %X : !moore.l8 -> !moore.real\n  %2 = moore.builtin.sqrt %1 : real\n  %3 = moore.builtin.floor %2 : real\n  %4 = moore.conversion %3 : !moore.real -> !moore.l4\n  %5 = moore.zext %4 : l4 -> l8\n  %6 = moore.powu %5, %0 : l8\n  %7 = moore.sub %X, %6 : l8\n  %8 = moore.trunc %7 : l8 -> l4\n  moore.output %4, %8 : !moore.l4, !moore.l4\n}\n```\n\n```\n[circt-verilog] Running \"convert-moore-to-core\"\ncirct-verilog: /home/uenoku/dev/circt-synth/llvm/llvm/include/llvm/Support/Casting.h:650: decltype(auto) llvm::dyn_cast(const From &) [To = mlir::IntegerType, From = mlir::Type]: Assertion `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.      Program arguments: circt-verilog ../out/SqrtArrUns_behavioral.sv -o build/SqrtArrUns_behavioral/circt/SqrtArrUns_behavioral.mlir --mlir-timing -y ../out ../ext/ELAU/src/arith_utils.sv -mlir-print-ir-after-all -verbose-pass-executions\n #0 0x00005a3051df92b8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/uenoku/dev/circt-synth/llvm/llvm/lib/Support/Unix/Signals.inc:834:13\n #1 0x00005a3051df6e93 llvm::sys::RunSignalHandlers() /home/uenoku/dev/circt-synth/llvm/llvm/lib/Support/Signals.cpp:105:18\n #2 0x00005a3051dfa051 SignalHandler(int, siginfo_t*, void*) /home/uenoku/dev/circt-synth/llvm/llvm/lib/Support/Unix/Signals.inc:426:38\n #3 0x00007ecdbca42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #4 0x00007ecdbca969fc __pthread_kill_implementation ./nptl/./nptl/pthread_kill.c:44:76\n #5 0x00007ecdbca969fc __pthread_kill_internal ./nptl/./nptl/pthread_kill.c:78:10\n #6 0x00007ecdbca969fc pthread_kill ./nptl/./nptl/pthread_kill.c:89:10\n #7 0x00007ecdbca42476 gsignal ./signal/../sysdeps/posix/raise.c:27:6\n #8 0x00007ecdbca287f3 abort ./stdlib/./stdlib/abort.c:81:7\n #9 0x00007ecdbca2871b _nl_load_domain ./intl/./intl/loadmsgcat.c:1177:9\n#10 0x00007ecdbca39e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n#11 0x00005a3050b0d8c4 decltype(auto) llvm::dyn_cast<mlir::IntegerType, mlir::Type>(mlir::Type const&) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x1ad8c4)\n#12 0x00005a3050cb10c5 decltype(auto) llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Type, long>, mlir::Type>::castValue<mlir::IntegerType, mlir::Type const&>(mlir::Type const&) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x3510c5)\n#13 0x00005a3050c9d8da llvm::TypeSwitch<mlir::Type, long>& llvm::TypeSwitch<mlir::Type, long>::Case<mlir::IntegerType, circt::hw::getBitWidth(mlir::Type)::$_0>(circt::hw::getBitWidth(mlir::Type)::$_0&&) HWTypes.cpp:0:0\n#14 0x00005a3050c9d7e6 circt::hw::getBitWidth(mlir::Type) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x33d7e6)\n#15 0x00005a30510f9908 (anonymous namespace)::ConversionOpConversion::matchAndRewrite(circt::moore::ConversionOp, circt::moore::ConversionOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n#16 0x00005a30510fa631 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::ConversionOp>, circt::moore::ConversionOp>(mlir::OpConversionPattern<circt::moore::ConversionOp> const&, circt::moore::ConversionOp, circt::moore::ConversionOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange> >, mlir::ConversionPatternRewriter&) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x79a631)\n```","createdAt":"2025-09-06T09:21:38Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8930,"state":"OPEN","title":"[MooreToCore] Crash with sqrt/floor","url":"https://github.com/llvm/circt/issues/8930"},{"body":"I'm looking into the failing testcase for `real` constants [on sv-tests-results](https://chipsalliance.github.io/sv-tests-results/?v=circt_verilog+5.7.2+real-constants). Just want to put it up here to make sure no one else has already started working on it.","createdAt":"2025-02-23T19:01:31Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8269,"state":"OPEN","title":"[MooreToCore] Support `real` constants","url":"https://github.com/llvm/circt/issues/8269"},{"body":"Add a conversion for the `moore.net` op to MooreToConv: https://chipsalliance.github.io/sv-tests-results/?v=circt_verilog+12.4+if","createdAt":"2024-09-25T03:28:07Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIx","name":"good first issue","description":"Good for newcomers","color":"7057ff"},{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":7629,"state":"OPEN","title":"[MooreToCore] Support net op","url":"https://github.com/llvm/circt/issues/7629"},{"body":"Dear @maerhart @fabianschuiki ,\r\n When lowering `SV` to `Hw` Dialect, there is a stack dump. \r\nDriver: circt-verilog %s\r\n```\r\nmodule top();\r\n  typedef struct {\r\n    int a;\r\n    int b;\r\n  } ms_t;\r\n\r\n  ms_t ms;\r\n\r\n  initial begin\r\n    ms = '{ 0, 1};\r\n\r\n    ms = '{ default:1, int:1};\r\n\r\n    ms = '{ int:0, int:1};\r\n  end\r\n\r\nendmodule\r\n```\r\nIt can be converted to `moore` Dialect like this\r\nDriver:  circt-verilog --ir-moore %s\r\n```\r\nmodule {\r\n  moore.module @top() {\r\n    %0 = moore.constant 1 : i32\r\n    %1 = moore.constant 0 : i32\r\n    %ms = moore.variable : <ustruct<{a: i32, b: i32}>>\r\n    moore.procedure initial {\r\n      %2 = moore.struct_create %1, %0 : !moore.i32, !moore.i32 -> ustruct<{a: i32, b: i32}>\r\n      moore.blocking_assign %ms, %2 : ustruct<{a: i32, b: i32}>\r\n      %3 = moore.struct_create %0, %0 : !moore.i32, !moore.i32 -> ustruct<{a: i32, b: i32}>\r\n      moore.blocking_assign %ms, %3 : ustruct<{a: i32, b: i32}>\r\n      moore.blocking_assign %ms, %3 : ustruct<{a: i32, b: i32}>\r\n      moore.return\r\n    }\r\n    moore.output\r\n  }\r\n}\r\n```\r\nBut it got stack dump when casting `hw::InOutType`. Maybe `structType` should be converted somehow.\r\nThis is part of error codes.\r\n```\r\n#19 0x00005f9660f42af4 (anonymous namespace)::OperationLegalizer::legalizeWithPattern(mlir::Operation*, mlir::ConversionPatternRewriter&) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:1958:21\r\n#20 0x00005f9660f3b100 (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:1850:17\r\n#21 0x00005f9660f3aa73 mlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:2384:26\r\n#22 0x00005f9660f3b41f mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:2436:16\r\n#23 0x00005f9660f3fdfc mlir::applyFullConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:3447:22\r\n#24 0x00005f9660f3fe9d mlir::applyFullConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:3453:10\r\n#25 0x00005f965faed60d (anonymous namespace)::MooreToCorePass::runOnOperation() /home/pluto/Documents/circt/circt/lib/Conversion/MooreToCore/MooreToCore.cpp:1398:14\r\n```","createdAt":"2024-08-20T01:51:29Z","labels":[],"number":7535,"state":"OPEN","title":"[MooreToCore] VariableOp lowered failed","url":"https://github.com/llvm/circt/issues/7535"},{"body":"Currently, CIRCT's MooreToCore pass converts unpacked arrays to packed arrays (hw::ArrayType),\nlosing the unpacked semantics.\n\nWhen we've attempted to preserve unpacked arrays by emitting hw::UnpackedArrayType,\nMLIR raises \"failed to legalize operation\" errors.\n\n## Minimal Reproduction\n\nWhen running `circt-opt` on the following input,\n\n```systemverilog\nmodule a (\n  input logic b[3:0]\n);\nendmodule\n```\n\nwe get the following result:\n\n```mlir\nmodule {\n  hw.module @a(in %b : !hw.array<4xi1>) {\n    hw.output\n  }\n}\n```\n\nas you can clearly see, the `uarray` is converted to a `array`.\n","createdAt":"2025-02-26T14:37:40Z","labels":[],"number":8276,"state":"OPEN","title":"[MooreToCore] Support for UnpackedArrayType emission","url":"https://github.com/llvm/circt/issues/8276"},{"body":"@jiahanxie353 has added the Math dialect to circt-opt in #8475. This is a great precedent to start using that dialect in the MooreToCore conversion. For example, the `moore.pow` operation could be lowered to `math.ipowi` and `math.powf` depending on its type.","createdAt":"2025-05-12T16:08:01Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIx","name":"good first issue","description":"Good for newcomers","color":"7057ff"},{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8476,"state":"OPEN","title":"[MooreToCore] Lower exponentiation to `math.ipowi`","url":"https://github.com/llvm/circt/issues/8476"},{"body":"Unsized array type in systemverilog like `OpenArrayType`, `QueueType` can't be lower to Arc Dialect, because Arc only has sized array type. \n\nCommon programming language like `Cpp` can directly call `mmap` provided by OS to get dynamic size array. I can't see this kind of ability in systemverilog.\n\nSo how to achieve that if we want to solve #8276? Can you give me some advice?","createdAt":"2025-03-04T15:38:48Z","labels":[],"number":8292,"state":"OPEN","title":"[MooreToCore] Support for Unsized Array Type","url":"https://github.com/llvm/circt/issues/8292"},{"body":"Please check this PR(https://github.com/llvm/circt/pull/8210/files) to view the details.\n\nOr for example:\n```\nmoore.module @crash(in %in0: !moore.i32, in %in1: !moore.i32) {\n  %var = moore.variable : <!moore.i32>\n  moore.procedure always_comb {\n    %0 = moore.pows %in0, %in1 : !moore.i32\n    moore.blocking_assign %var, %0 : !moore.i32\n    moore.return\n  }\n}\n```\n\n`%var` will be regarded as one member of the implicit sensitivity list. But this act is illegal❌.","createdAt":"2025-02-08T13:58:49Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8211,"state":"OPEN","title":"[MooreToCore]Unexpected observed values in llhd.wait.","url":"https://github.com/llvm/circt/issues/8211"},{"body":"The following crashes due to an unattached region when calling `getValuesToObserve`.\n\n```mlir\nmoore.module @crash(in %in0: !moore.i32, in %in1: !moore.i32) {\n  %var = moore.variable : <!moore.i32>\n  moore.procedure always_comb {\n    %0 = moore.pows %in0, %in1 : !moore.i32\n    moore.blocking_assign %var, %0 : !moore.i32\n    moore.return\n  }\n}\n```","createdAt":"2025-02-03T10:27:41Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8176,"state":"OPEN","title":"[MooreToCore] Crash when getting values to observe","url":"https://github.com/llvm/circt/issues/8176"},{"body":"In Verilog it's legal to access arrays/bitvectors out-of-bounds which will yield X or 0. Thus a lowBit attribute not within the range is allowed by `moore.extract`. This is currently lowered 1-1 to `comb.extract` which does verify that the lowBit attribute is within range. Therefore, MooreToCore needs to check if the attribute is out of bounds and lower it to a constant in that case.","createdAt":"2025-01-31T13:37:09Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8163,"state":"OPEN","title":"[MooreToCore] Out-of-bounds moore.extract lowered incorrectly","url":"https://github.com/llvm/circt/issues/8163"},{"body":"Hi! Now I try to add types and operators in sim to get the lowered operators in moore, and then lower them to llvm dialect, so that the corresponding dynamic size container can be implemented in arcilator.\n\nFirst, add IntType and RefType in sim, as well as VariableOp, BlockAssignOp, Print, ReadOp, and ConcatOp operators.\nTaking Variable as an example, creating a stringtype VariableOp in Moore will create an int type through string_constant, and then perform conversionOp to convert the int type to Stringtype, and finally create VariableOp. In sim, if VariableOp can directly accept int type, the conversion time can be saved. Therefore, I think it is not necessary to add StringType separately, and only use Int Type and RefType to represent it.\n\nIn sim to llvm dialect, VariableOp will be converted into a series of Ops. First, llvm.alloca will be used to create an i128 memory, which will be divided into i32 size to record the string length, and i96 data to record the string content. Then, llvm.getelementptrOp and llvm.storeOp are used to store the contents in the corresponding locations. This memory will be dynamically doubled according to the length of the string.\n\nCan you give me some advise?","createdAt":"2025-03-20T02:36:53Z","labels":[],"number":8332,"state":"OPEN","title":"[MooreToCore] Support for StringType from moore to llvm dialect","url":"https://github.com/llvm/circt/issues/8332"},{"body":"If I understand IEEE 1800-2017 §7.4.6 Indexing and slicing of arrays right, an unpacked array slice should be 0/X in its entirety even if only a part of the slice is OOB. Currently, only the OOB part is 0/X because they are lowered just like packed arrays.","createdAt":"2025-02-10T13:02:44Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8215,"state":"OPEN","title":"[MooreToCore] OOB array slices of unpacked arrays lowered like packed arrays","url":"https://github.com/llvm/circt/issues/8215"},{"body":"I want to support this [sv-tests-results/string_concat_op](https://chipsalliance.github.io/sv-tests-results/?v=circt_verilog+11.4.12.2+string_concat_op) feature, but not sure how to fix it properly.\n\n``` sv\nmodule top();\n\nstring str;\n\ninitial begin\n    str = \"Hello\";\nend\n\nendmodule\n```\n\n`circt-verilog`  has the following complaints when compiling the string.sv file:\n```s.sv:3:8: error: failed to legalize operation 'moore.variable'\nstring str;\n       ^\ns.sv:3:8: note: see current operation: %0 = \"moore.variable\"() <{name = \"str\"}> : () -> !moore.ref<string>\n```\n\nThis error is due to MooreToCore's lack of string-type conversion. It only has `StringConstantOpConv` and `Format*OpConversion`; none of these conversions can handle the `string` type.\n","createdAt":"2025-02-28T08:51:12Z","labels":[],"number":8283,"state":"OPEN","title":"[ImportVerilog] Cannot compile forward decleared string type","url":"https://github.com/llvm/circt/issues/8283"},{"body":"Given this module:\n\n```mlir\nmodule {\n  moore.module @test(out x : !moore.l4) {\n    %arr = moore.variable : <array<2 x array<3 x l4>>>\n    %0 = moore.read %arr : <array<2 x array<3 x l4>>>\n    %1 = moore.extract %0 from 1 : array<2 x array<3 x l4>> -> array<3 x l4>\n    %2 = moore.extract %1 from 2 : array<3 x l4> -> l4\n    moore.output %2 : !moore.l4\n  }\n}\n```\n\nHere is the result of running `MooreToCore`:\n\n```mlir\nmodule {\n  hw.module @test(out x : i4) {\n    %c0_i24 = hw.constant 0 : i24\n    %0 = hw.bitcast %c0_i24 : (i24) -> !hw.array<2xarray<3xi4>>\n    %arr = llhd.sig %0 : !hw.array<2xarray<3xi4>>\n    %1 = llhd.prb %arr : !hw.inout<array<2xarray<3xi4>>>\n    %true = hw.constant true\n    %2 = hw.array_slice %1[%true] : (!hw.array<2xarray<3xi4>>) -> !hw.array<3xi4>\n    %c-2_i2 = hw.constant -2 : i2\n    %3 = hw.array_get %2[%c-2_i2] : !hw.array<3xi4>, i2\n    hw.output %3 : i4\n  }\n}\n```\n\nIt can be seen that `%1 = moore.extract ...` was translated to `%2 = hw.array_slice ...`: `moore.extract`'s result type is an array, so it was mistaken for a slicing operation.\n\nThe resulting module is malformed and fails validation after canonicalization (due to `hw.output`'s argument not matching the output port's type).","createdAt":"2024-11-28T19:09:10Z","labels":[],"number":7918,"state":"OPEN","title":"[MooreToCore] `moore.extract` is converted to `hw.array_slice` when array's element type is also array","url":"https://github.com/llvm/circt/issues/7918"},{"body":"Hello, I'm having an issue when trying to import Verilog generated with Yosys. It leads into a combinatorial cycle that isn't present in the Verilog program.\nHere is a simple example of problematic Verilog:\n```sv\nmodule outline_control_3(output [1:0] result, input arg0);\n  assign result[1] = arg0;\n  assign result[0] = result[1];\nendmodule\n```\nWhen I import the Verilog into Moore with `./circt-translate --import-verilog test.sv` it generates the following program:\n```mlir\nmodule {\n  moore.module @outline_control_3(out result : !moore.l2, in %arg0 : !moore.l1) {\n    %result = moore.net wire : <l2>\n    %arg0_0 = moore.net name \"arg0\" wire : <l1>\n    %0 = moore.extract_ref %result from 1 : <l2> -> <l1>\n    %1 = moore.read %arg0_0 : <l1>\n    moore.assign %0, %1 : l1\n    %2 = moore.extract_ref %result from 0 : <l2> -> <l1>\n    %3 = moore.read %result : <l2>\n    %4 = moore.extract %3 from 1 : l2 -> l1\n    moore.assign %2, %4 : l1\n    %5 = moore.read %result : <l2>\n    moore.assign %arg0_0, %arg0 : l1\n    moore.output %5 : !moore.l2\n  }\n}\n```\nBut then, when I lower it into the comb/HW dialects with `./circt-translate --import-verilog test.sv | ./circt-opt --moore-lower-concatref --canonicalize --cse --convert-moore-to-core --llhd-sig2reg --canonicalize --cse`. It generates the following program:\n```mlir\nmodule {\n  hw.module @outline_control_3(out result : i2, in %arg0 : i1) {\n    %false = hw.constant false\n    %0 = comb.concat %false, %3 : i1, i1\n    %1 = comb.concat %arg0, %false : i1, i1\n    %2 = comb.or %1, %0 : i2\n    %3 = comb.extract %2 from 1 : (i2) -> i1\n    hw.output %2 : i2\n  }\n}\n```\nMy problem here is that `%3` depends on `%2`, which in turn depends on `%0`, which also depends on `%3`. As the hw.module contains a `graph` region, it doesn't seem to be an invalid MLIR program. But is it the expected behavior? There is a combinatorial cycle that wasn't present in the imported Verilog.","createdAt":"2025-10-06T12:22:11Z","labels":[{"id":"LA_kwDODpuCgs8AAAABp1j0gg","name":"ImportVerilog","description":"","color":"e99695"}],"number":9057,"state":"CLOSED","title":"[MooreToCore] Unexpected topological cycle after importing generated verilog","url":"https://github.com/llvm/circt/issues/9057"},{"body":"Lowering the following with `circt-verilog`\n```sv\nmodule combo (  input   a, b, c, d, e,  output  reg z);\n\n        always @ (*) begin\n                z = ((a & b) | (c ^ d) & ~e);\n        end\n\nendmodule\n```\nresults in this MLIR:\n```mlir\n  hw.module @combo(in %a : i1, in %b : i1, in %c : i1, in %d : i1, in %e : i1, out z : i1) {\n    %0 = llhd.constant_time <0ns, 0d, 1e>\n    %true = hw.constant true\n    %false = hw.constant false\n    %a_0 = llhd.sig name \"a\" %false : i1\n    %1 = llhd.prb %a_0 : !hw.inout<i1>\n    %b_1 = llhd.sig name \"b\" %false : i1\n    %2 = llhd.prb %b_1 : !hw.inout<i1>\n    %c_2 = llhd.sig name \"c\" %false : i1\n    %3 = llhd.prb %c_2 : !hw.inout<i1>\n    %d_3 = llhd.sig name \"d\" %false : i1\n    %4 = llhd.prb %d_3 : !hw.inout<i1>\n    %e_4 = llhd.sig name \"e\" %false : i1\n    %5 = llhd.prb %e_4 : !hw.inout<i1>\n    %z = llhd.sig %false : i1\n    llhd.process {\n      cf.br ^bb1\n    ^bb1:  // 3 preds: ^bb0, ^bb2, ^bb3\n      %7 = llhd.prb %a_0 : !hw.inout<i1>\n      %8 = llhd.prb %b_1 : !hw.inout<i1>\n      %9 = llhd.prb %c_2 : !hw.inout<i1>\n      %10 = llhd.prb %d_3 : !hw.inout<i1>\n      %11 = llhd.prb %e_4 : !hw.inout<i1>\n      llhd.wait (%1, %2, %3, %4, %5 : i1, i1, i1, i1, i1), ^bb2\n    ^bb2:  // pred: ^bb1\n      %12 = llhd.prb %a_0 : !hw.inout<i1>\n      %13 = comb.icmp bin ne %7, %12 : i1\n      %14 = llhd.prb %b_1 : !hw.inout<i1>\n      %15 = comb.icmp bin ne %8, %14 : i1\n      %16 = llhd.prb %c_2 : !hw.inout<i1>\n      %17 = comb.icmp bin ne %9, %16 : i1\n      %18 = llhd.prb %d_3 : !hw.inout<i1>\n      %19 = comb.icmp bin ne %10, %18 : i1\n      %20 = llhd.prb %e_4 : !hw.inout<i1>\n      %21 = comb.icmp bin ne %11, %20 : i1\n      %22 = comb.or bin %13, %15, %17, %19, %21 : i1\n      cf.cond_br %22, ^bb3, ^bb1\n    ^bb3:  // pred: ^bb2\n      %23 = llhd.prb %a_0 : !hw.inout<i1>\n      %24 = llhd.prb %b_1 : !hw.inout<i1>\n      %25 = comb.and %23, %24 : i1\n      %26 = llhd.prb %c_2 : !hw.inout<i1>\n      %27 = llhd.prb %d_3 : !hw.inout<i1>\n      %28 = comb.xor %26, %27 : i1\n      %29 = llhd.prb %e_4 : !hw.inout<i1>\n      %30 = comb.xor %29, %true : i1\n      %31 = comb.and %28, %30 : i1\n      %32 = comb.or %25, %31 : i1\n      llhd.drv %z, %32 after %0 : !hw.inout<i1>\n      cf.br ^bb1\n    }\n    llhd.drv %a_0, %a after %0 : !hw.inout<i1>\n    llhd.drv %b_1, %b after %0 : !hw.inout<i1>\n    llhd.drv %c_2, %c after %0 : !hw.inout<i1>\n    llhd.drv %d_3, %d after %0 : !hw.inout<i1>\n    llhd.drv %e_4, %e after %0 : !hw.inout<i1>\n    %6 = llhd.prb %z : !hw.inout<i1>\n    hw.output %6 : i1\n  }\n```\n\n`%22` will always evaluate to `true` because the wait operation will only branch if one of its sensitivity values changes. We should add a folder/canonicalizer that performs this simplification.\n\nThe code responsible for generating this pattern is in MooreToCore in the WaitEventOp lowering pattern.","createdAt":"2024-12-22T12:56:02Z","labels":[{"id":"MDU6TGFiZWwyMTY1NDc5NTk1","name":"LLHD","description":"","color":"e07b00"}],"number":8013,"state":"OPEN","title":"[LLHD] Canonicalizer for processes produced by always @(*)","url":"https://github.com/llvm/circt/issues/8013"}]
[{"body":"## Bug Description\n\n`circt-verilog` crashes with an assertion failure when processing a SystemVerilog module that has a `string` type output port. The crash occurs during the MooreToCore conversion pass when the `getModulePortInfo()` function fails to properly handle cases where type conversion returns an invalid/empty type, causing a `dyn_cast` assertion failure in `ModulePortInfo::sanitizeInOut()`.\n\nThis is a valid SystemVerilog construct per IEEE 1800-2017 Section 6.16 (String data type). Both **slang** and **verilator** accept the code without errors.\n\n## Steps to Reproduce\n\n1. Save the following test case as `bug.sv`\n2. Run: `circt-verilog --ir-hw bug.sv`\n\n## Test Case\n\n```systemverilog\nmodule test_module(output string a);\nendmodule\n```\n\n## Expected Behavior\n\nCIRCT should either:\n1. Support simulation constructs like string ports appropriately, OR\n2. Emit a proper diagnostic error message indicating that string ports are not supported for hardware synthesis\n\n## Actual Behavior\n\nThe tool crashes with an assertion failure:\n\n```\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: circt-verilog --ir-hw bug.sv\n #0 0x00007fe810a738a8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x2008a8)\n #1 0x00007fe810a712f5 llvm::sys::RunSignalHandlers() (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x1fe2f5)\n #2 0x00007fe810a74631 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x00007fe810581330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #4 0x00007fe814c958ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007fe814c95b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007fe814c95530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n #7 0x00007fe812fa7438 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2a438)\n #8 0x00007fe812f718ed void llvm::function_ref<void ()>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_0>(long) PatternApplicator.cpp:0:0\n #9 0x00007fe812f6e774 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/opt/firtool-1.139.0/bin/../lib/libMLIRRewrite.so+0x7774)\n#10 0x00007fe812fa8c6f (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*) DialectConversion.cpp:0:0\n#11 0x00007fe812fa8470 mlir::OperationConverter::convert(mlir::Operation*, bool) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2b470)\n#12 0x00007fe812fa8dae mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2bdae)\n#13 0x00007fe812fb68e4 void llvm::function_ref<void ()>::callback_fn<applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode)::$_0>(long) DialectConversion.cpp:0:0\n#14 0x00007fe812fadf7d applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode) DialectConversion.cpp:0:0\n#15 0x00007fe812fae0fe mlir::applyFullConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x310fe)\n#16 0x00007fe814c67231 (anonymous namespace)::MooreToCorePass::runOnOperation() MooreToCore.cpp:0:0\n#17 0x00007fe812d632a5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x172a5)\n#18 0x00007fe812d667a9 mlir::PassManager::run(mlir::Operation*) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x1a7a9)\n#19 0x0000561bab9605d0 executeWithSources(mlir::MLIRContext*, llvm::SourceMgr&) circt-verilog.cpp:0:0\n#20 0x0000561bab95bdd5 execute(mlir::MLIRContext*) circt-verilog.cpp:0:0\n#21 0x0000561bab95b4b8 main (/opt/firtool-1.139.0/bin/circt-verilog+0x84b8)\n#22 0x00007fe8105661ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#23 0x00007fe81056628b call_init ./csu/../csu/libc-start.c:128:20\n#24 0x00007fe81056628b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#25 0x0000561bab95ab05 _start (/opt/firtool-1.139.0/bin/circt-verilog+0x7b05)\n\n```\n\n## Root Cause Analysis\n\n### Crash Location\n- **File**: `lib/Conversion/MooreToCore/MooreToCore.cpp`\n- **Function**: `getModulePortInfo()` → calls `ModulePortInfo::sanitizeInOut()`\n- **Assertion**: `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"`\n\n### Analysis\n\nThe root cause is **missing validation of type conversion result** in `getModulePortInfo()`:\n\n```cpp\n// MooreToCore.cpp:233-259\nstatic hw::ModulePortInfo getModulePortInfo(const TypeConverter &typeConverter,\n                                            SVModuleOp op) {\n  // ...\n  for (auto port : moduleTy.getPorts()) {\n    Type portTy = typeConverter.convertType(port.type);  // <-- May return empty Type!\n    // ...\n    ports.push_back(hw::PortInfo({{port.name, portTy, port.dir}, ...}));  // <-- Stores empty Type\n  }\n  return hw::ModulePortInfo(ports);  // <-- Constructor calls sanitizeInOut()\n}\n```\n\nWhen `typeConverter.convertType()` fails for the `string` port type (returns empty `Type`), this invalid type is passed to `sanitizeInOut()` which calls `dyn_cast<hw::InOutType>(p.type)` on the empty type, triggering the assertion.\n\n### Suggested Fix\n\nAdd validation in `getModulePortInfo()` to check if `typeConverter.convertType()` returns a valid type:\n\n```cpp\nType portTy = typeConverter.convertType(port.type);\nif (!portTy) {\n  // Emit proper diagnostic error\n  return failure();\n}\n```\n\n## Environment\n\n- **CIRCT Version**: firtool-1.139.0 (LLVM 22.0.0git)\n- **OS**: Linux 5.15.0 (x86_64)\n\n## Cross-Tool Validation\n\n| Tool | Version | Status | Notes |\n|------|---------|--------|-------|\n| slang | 10.0.6+3d7e6cd2e | ✅ Pass | Build succeeded: 0 errors, 0 warnings |\n| verilator | 5.022 | ✅ Pass | No errors |\n| iverilog | - | ❌ Error | \"Port with type string is not supported\" (tool limitation, not syntax error) |\n\nThis confirms the test case is **syntactically valid** SystemVerilog per IEEE 1800-2017.\n","createdAt":"2026-02-01T03:00:12Z","labels":[],"number":9572,"state":"OPEN","title":"[Moore] Assertion failure when module has string type output port","url":"https://github.com/llvm/circt/issues/9572"}]
[{"body":"## Bug Description\n\n`circt-verilog` crashes with an assertion failure when processing a SystemVerilog module that has a `string` type output port. The crash occurs during the MooreToCore conversion pass when the `getModulePortInfo()` function fails to properly handle cases where type conversion returns an invalid/empty type, causing a `dyn_cast` assertion failure in `ModulePortInfo::sanitizeInOut()`.\n\nThis is a valid SystemVerilog construct per IEEE 1800-2017 Section 6.16 (String data type). Both **slang** and **verilator** accept the code without errors.\n\n## Steps to Reproduce\n\n1. Save the following test case as `bug.sv`\n2. Run: `circt-verilog --ir-hw bug.sv`\n\n## Test Case\n\n```systemverilog\nmodule test_module(output string a);\nendmodule\n```\n\n## Expected Behavior\n\nCIRCT should either:\n1. Support simulation constructs like string ports appropriately, OR\n2. Emit a proper diagnostic error message indicating that string ports are not supported for hardware synthesis\n\n## Actual Behavior\n\nThe tool crashes with an assertion failure:\n\n```\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: circt-verilog --ir-hw bug.sv\n #0 0x00007fe810a738a8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x2008a8)\n #1 0x00007fe810a712f5 llvm::sys::RunSignalHandlers() (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x1fe2f5)\n #2 0x00007fe810a74631 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x00007fe810581330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #4 0x00007fe814c958ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007fe814c95b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007fe814c95530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n #7 0x00007fe812fa7438 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2a438)\n #8 0x00007fe812f718ed void llvm::function_ref<void ()>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_0>(long) PatternApplicator.cpp:0:0\n #9 0x00007fe812f6e774 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/opt/firtool-1.139.0/bin/../lib/libMLIRRewrite.so+0x7774)\n#10 0x00007fe812fa8c6f (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*) DialectConversion.cpp:0:0\n#11 0x00007fe812fa8470 mlir::OperationConverter::convert(mlir::Operation*, bool) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2b470)\n#12 0x00007fe812fa8dae mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2bdae)\n#13 0x00007fe812fb68e4 void llvm::function_ref<void ()>::callback_fn<applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode)::$_0>(long) DialectConversion.cpp:0:0\n#14 0x00007fe812fadf7d applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode) DialectConversion.cpp:0:0\n#15 0x00007fe812fae0fe mlir::applyFullConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x310fe)\n#16 0x00007fe814c67231 (anonymous namespace)::MooreToCorePass::runOnOperation() MooreToCore.cpp:0:0\n#17 0x00007fe812d632a5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x172a5)\n#18 0x00007fe812d667a9 mlir::PassManager::run(mlir::Operation*) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x1a7a9)\n#19 0x0000561bab9605d0 executeWithSources(mlir::MLIRContext*, llvm::SourceMgr&) circt-verilog.cpp:0:0\n#20 0x0000561bab95bdd5 execute(mlir::MLIRContext*) circt-verilog.cpp:0:0\n#21 0x0000561bab95b4b8 main (/opt/firtool-1.139.0/bin/circt-verilog+0x84b8)\n#22 0x00007fe8105661ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#23 0x00007fe81056628b call_init ./csu/../csu/libc-start.c:128:20\n#24 0x00007fe81056628b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#25 0x0000561bab95ab05 _start (/opt/firtool-1.139.0/bin/circt-verilog+0x7b05)\n\n```\n\n## Root Cause Analysis\n\n### Crash Location\n- **File**: `lib/Conversion/MooreToCore/MooreToCore.cpp`\n- **Function**: `getModulePortInfo()` → calls `ModulePortInfo::sanitizeInOut()`\n- **Assertion**: `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"`\n\n### Analysis\n\nThe root cause is **missing validation of type conversion result** in `getModulePortInfo()`:\n\n```cpp\n// MooreToCore.cpp:233-259\nstatic hw::ModulePortInfo getModulePortInfo(const TypeConverter &typeConverter,\n                                            SVModuleOp op) {\n  // ...\n  for (auto port : moduleTy.getPorts()) {\n    Type portTy = typeConverter.convertType(port.type);  // <-- May return empty Type!\n    // ...\n    ports.push_back(hw::PortInfo({{port.name, portTy, port.dir}, ...}));  // <-- Stores empty Type\n  }\n  return hw::ModulePortInfo(ports);  // <-- Constructor calls sanitizeInOut()\n}\n```\n\nWhen `typeConverter.convertType()` fails for the `string` port type (returns empty `Type`), this invalid type is passed to `sanitizeInOut()` which calls `dyn_cast<hw::InOutType>(p.type)` on the empty type, triggering the assertion.\n\n### Suggested Fix\n\nAdd validation in `getModulePortInfo()` to check if `typeConverter.convertType()` returns a valid type:\n\n```cpp\nType portTy = typeConverter.convertType(port.type);\nif (!portTy) {\n  // Emit proper diagnostic error\n  return failure();\n}\n```\n\n## Environment\n\n- **CIRCT Version**: firtool-1.139.0 (LLVM 22.0.0git)\n- **OS**: Linux 5.15.0 (x86_64)\n\n## Cross-Tool Validation\n\n| Tool | Version | Status | Notes |\n|------|---------|--------|-------|\n| slang | 10.0.6+3d7e6cd2e | ✅ Pass | Build succeeded: 0 errors, 0 warnings |\n| verilator | 5.022 | ✅ Pass | No errors |\n| iverilog | - | ❌ Error | \"Port with type string is not supported\" (tool limitation, not syntax error) |\n\nThis confirms the test case is **syntactically valid** SystemVerilog per IEEE 1800-2017.\n","createdAt":"2026-02-01T03:00:12Z","labels":[],"number":9572,"state":"OPEN","title":"[Moore] Assertion failure when module has string type output port","url":"https://github.com/llvm/circt/issues/9572"},{"body":"## Description\n\nCIRCT crashes with assertion `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"` when compiling SystemVerilog modules that use packed union types as module ports.\n\n**Likely cause**: MooreToCore conversion pass lacks a type conversion rule for packed union types (`UnionType`). When processing module ports, the type converter fails to convert `UnionType`, resulting in an invalid/null type that causes assertion failures in downstream port processing code (`getModulePortInfo` at line 259).\n\n> **Validation**: Test case accepted by: verilator, iverilog, slang\n> **IEEE 1800-2005**: Packed unions are valid (Section 7.3)\n\n## Steps to Reproduce\n\n1. Save following code as `bug.sv`\n2. Run: `circt-verilog --ir-hw bug.sv`\n\n## Test Case\n\n```systemverilog\ntypedef union packed {\n  logic [31:0] a;\n  logic [31:0] b;\n} my_union;\n\nmodule Sub(input my_union in_val, output my_union out_val);\n  assign out_val = in_val;\nendmodule\n\nmodule Top;\n  my_union data_in, data_out;\n  \n  Sub s(.in_val(data_in), .out_val(data_out));\nendmodule\n```\n\n## Error Output\n\n```\n #4 0x00007f8176f898ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007f8176f89b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007f8176f89530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n```\n\n<details>\n<summary>Full Stack Trace</summary>\n\n```\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.      Program arguments: /opt/firtool/bin/circt-verilog --ir-hw bug.sv\n #0 0x00007f8172d678a8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x2008a8)\n #1 0x00007f8172d652f5 llvm::sys::RunSignalHandlers() (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x1fe2f5)\n #2 0x00007f8172d68631 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x00007f8172875330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #4 0x00007f8176f898ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007f8176f89b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007f8176f89530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n #7 0x00007f817529b438 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2a438)\n #8 0x00007f81752658ed void llvm::function_ref<void ()>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_0>(long) PatternApplicator.cpp:0:0\n #9 0x00007f8175262774 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/opt/firtool-1.139.0/bin/../lib/libMLIRRewrite.so+0x7774)\n#10 0x00007f817529cc6f (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*) DialectConversion.cpp:0:0\n#11 0x00007f817529c470 mlir::OperationConverter::convert(mlir::Operation*, bool) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2b470)\n#12 0x00007f817529cdae mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2bdae)\n#13 0x00007f81752aa8e4 void llvm::function_ref<void ()>::callback_fn<applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode)::$_0>(long) DialectConversion.cpp:0:0\n#14 0x00007f81752a1f7d applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode) DialectConversion.cpp:0:0\n#15 0x00007f81752a20fe mlir::applyFullConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x310fe)\n#16 0x00007f8176f5b231 (anonymous namespace)::MooreToCorePass::runOnOperation() MooreToCore.cpp:0:0\n#17 0x00007f81750572a5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x172a5)\n#18 0x00007f817505a7a9 mlir::PassManager::run(mlir::Operation*) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x1a7a9)\n#19 0x0000563df3daf5d0 executeWithSources(mlir::MLIRContext*, llvm::SourceMgr&) circt-verilog.cpp:0:0\n#20 0x0000563df3daadd5 execute(mlir::MLIRContext*) circt-verilog.cpp:0:0\n#21 0x0000563df3daa4b8 main (/opt/firtool/bin/circt-verilog+0x84b8)\n#22 0x00007f817285a1ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#23 0x00007f817285a28b call_init ./csu/../csu/libc-start.c:128:20\n#24 0x00007f817285a28b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#25 0x0000563df3da9b05 _start (/opt/firtool/bin/circt-verilog+0x7b05)\n[1]    1143009 segmentation fault (core dumped)  /opt/firtool/bin/circt-verilog --ir-hw bug.sv\n\n```\n\n</details>\n\n## Root Cause Analysis\n\n- **Dialect**: Moore\n- **Failing Pass**: MooreToCore\n\n### Hypotheses\n\n1. **Missing UnionType type conversion rule** (confidence: high)\n   - Evidence: [\"Test case uses 'typedef union packed' as module port type\", 'Stack trace shows crash in getModulePortInfo during port processing at line 259', \"Assertion message indicates 'dyn_cast<InOutType>' failed on non-existent value\", 'No conversion rule for UnionType exists in populateTypeConversion function (lines 2268-2409)', 'Similar types like StructType have conversion rules, but UnionType does not', 'Both UnionType and StructType implement DestructurableTypeInterface, suggesting they should be handled similarly']\n   - Mechanism: The typeConverter fails to convert UnionType when processing module ports, resulting in an invalid type that causes assertion failures\n\n2. **Type converter returns invalid non-null type** (confidence: medium)\n   - Evidence: [\"Line 245-248 checks 'if (!portTy)' and emits error\", 'However, crash still occurs, suggesting either the check is not being reached or the type is non-null but invalid', 'The assertion occurs in a different code path that may not be covered by the initial null check']\n   - Mechanism: The typeConverter may return a non-null type with incorrect MLIR type ID or metadata\n\n## Environment\n\n- **CIRCT Version**: LLVM (http://llvm.org/):\n  LLVM version 22.0.0git\n  Optimized build.\nCIRCT firtool-1.139.0\nslang version 9.1.0+0\n\n---\n**Labels**: bug, Moore","createdAt":"2026-02-01T02:15:22Z","labels":[],"number":9570,"state":"OPEN","title":"[Moore] Assertion in MooreToCore when module uses packed union type as port","url":"https://github.com/llvm/circt/issues/9570"},{"body":"**Test commit**\n[417a5112947d9889cad54cb5b2110b37978b86b8](https://github.com/llvm/circt/commit/417a5112947d9889cad54cb5b2110b37978b86b8)\n\n**Description**\nThe pass leaks memory when it fails to legalize nested operations (like `sv.reg`): it allocates `systemc.module` and `systemc.ctor` operations but fails to deallocate them when the conversion is aborted due to incorrect/illegal IR.\n\n**Steps to reproduce**\n- Minimal MLIR program (test.mlir)\n```\n\"builtin.module\"() ({\n  \"hw.module\"() <{module_type = !hw.modty<>, parameters = [], sym_name = \"Bar\"}> ({\n    %0 = \"hw.constant\"() <{value = false}> : () -> i1\n    %1 = \"sv.reg\"(%0) <{name = \"reg\"}> : (i1) -> !hw.inout<i1>\n    \"hw.output\"() : () -> ()\n  }) : () -> ()\n}) : () -> ()\n```\n\n**Command**\n```\ncirct-opt --convert-hw-to-systemc test.mlir\n```\n\n**Output**\n```\ntest.mlir:4:10: error: failed to legalize operation 'sv.reg'\n    %1 = \"sv.reg\"(%0) <{name = \"reg\"}> : (i1) -> !hw.inout<i1>\n         ^\ntest.mlir:4:10: note: see current operation: %2 = \"sv.reg\"(%1) <{name = \"reg\"}> : (i1) -> !hw.inout<i1>\n\n=================================================================\n==108527==ERROR: LeakSanitizer: detected memory leaks\n\nIndirect leak of 88 byte(s) in 1 object(s) allocated from:\n    #0 0x55b3b1245c5e in malloc (/workdir/builds/circt/bin/circt-opt+0x6f95c5e) (BuildId: d0273fc7523026d0)\n    #1 0x55b3b72f252a in mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) /workdir/sources/circt/llvm/mlir/lib/IR/Operation.cpp:114:46\n\nIndirect leak of 72 byte(s) in 1 object(s) allocated from:\n    #0 0x55b3b1280aad in operator new(unsigned long) (/workdir/builds/circt/bin/circt-opt+0x6fd0aad) (BuildId: d0273fc7523026d0)\n    #1 0x55b3b62d9d73 in circt::systemc::CtorOp::build(mlir::OpBuilder&, mlir::OperationState&) /workdir/builds/circt/include/circt/Dialect/SystemC/SystemC.cpp.inc:1849:25\n    #2 0x55b3b629c0c8 in circt::systemc::CtorOp::create(mlir::OpBuilder&, mlir::Location) /workdir/builds/circt/include/circt/Dialect/SystemC/SystemC.cpp.inc:1855:3\n    #3 0x55b3b629be5c in circt::systemc::SCModuleOp::getOrCreateCtor() /workdir/sources/circt/lib/Dialect/SystemC/SystemCOps.cpp:336:10\n    #4 0x55b3b69e3243 in (anonymous namespace)::ConvertHWModule::matchAndRewrite(circt::hw::HWModuleOp, circt::hw::HWModuleOpAdaptor, mlir::ConversionPatternRewriter&) const /workdir/sources/circt/lib/Conversion/HWToSystemC/HWToSystemC.cpp:86:18\n    #5 0x55b3b69d6038 in llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::hw::HWModuleOp>, circt::hw::HWModuleOp>(mlir::OpConversionPattern<circt::hw::HWModuleOp> const&, circt::hw::HWModuleOp, circt::hw::HWModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange> >, mlir::ConversionPatternRewriter&) /workdir/sources/circt/llvm/mlir/include/mlir/Transforms/DialectConversion.h:1069:15\n    #6 0x55b3b69d5b4f in mlir::OpConversionPattern<circt::hw::HWModuleOp>::matchAndRewrite(circt::hw::HWModuleOp, circt::hw::HWModuleOpGenericAdaptor<llvm::ArrayRef<mlir::ValueRange> >, mlir::ConversionPatternRewriter&) const /workdir/sources/circt/llvm/mlir/include/mlir/Transforms/DialectConversion.h:727:12\n    #7 0x55b3b69d43bf in mlir::OpConversionPattern<circt::hw::HWModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const /workdir/sources/circt/llvm/mlir/include/mlir/Transforms/DialectConversion.h:713:12\n    #8 0x55b3b7e3c195 in mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const /workdir/sources/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:2434:10\n\nIndirect leak of 72 byte(s) in 1 object(s) allocated from:\n    #0 0x55b3b1280aad in operator new(unsigned long) (/workdir/builds/circt/bin/circt-opt+0x6fd0aad) (BuildId: d0273fc7523026d0)\n    #1 0x55b3b6296442 in circt::systemc::SCModuleOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::StringAttr, mlir::ArrayAttr, llvm::ArrayRef<mlir::Type>, llvm::ArrayRef<mlir::NamedAttribute>) /workdir/sources/circt/lib/Dialect/SystemC/SystemCOps.cpp:249:21\n    #2 0x55b3b629706a in circt::systemc::SCModuleOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::StringAttr, llvm::ArrayRef<circt::hw::PortInfo>, llvm::ArrayRef<mlir::NamedAttribute>) /workdir/sources/circt/lib/Dialect/SystemC/SystemCOps.cpp:266:3\n    #3 0x55b3b6331669 in circt::systemc::SCModuleOp::create(mlir::OpBuilder&, mlir::Location, mlir::StringAttr, llvm::ArrayRef<circt::hw::PortInfo>, llvm::ArrayRef<mlir::NamedAttribute>) /workdir/builds/circt/include/circt/Dialect/SystemC/SystemC.cpp.inc:5747:3\n    #4 0x55b3b69e2e3b in (anonymous namespace)::ConvertHWModule::matchAndRewrite(circt::hw::HWModuleOp, circt::hw::HWModuleOpAdaptor, mlir::ConversionPatternRewriter&) const /workdir/sources/circt/lib/Conversion/HWToSystemC/HWToSystemC.cpp:61:21\n    #5 0x55b3b69d6038 in llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::hw::HWModuleOp>, circt::hw::HWModuleOp>(mlir::OpConversionPattern<circt::hw::HWModuleOp> const&, circt::hw::HWModuleOp, circt::hw::HWModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange> >, mlir::ConversionPatternRewriter&) /workdir/sources/circt/llvm/mlir/include/mlir/Transforms/DialectConversion.h:1069:15\n    #6 0x55b3b69d5b4f in mlir::OpConversionPattern<circt::hw::HWModuleOp>::matchAndRewrite(circt::hw::HWModuleOp, circt::hw::HWModuleOpGenericAdaptor<llvm::ArrayRef<mlir::ValueRange> >, mlir::ConversionPatternRewriter&) const /workdir/sources/circt/llvm/mlir/include/mlir/Transforms/DialectConversion.h:727:12\n    #7 0x55b3b69d43bf in mlir::OpConversionPattern<circt::hw::HWModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const /workdir/sources/circt/llvm/mlir/include/mlir/Transforms/DialectConversion.h:713:12\n    #8 0x55b3b7e3c195 in mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const /workdir/sources/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:2434:10\n\nSUMMARY: AddressSanitizer: 232 byte(s) leaked in 3 allocation(s).\n```\n","createdAt":"2025-12-19T15:26:23Z","labels":[],"number":9376,"state":"OPEN","title":"Memory leak in HW to SystemC conversion","url":"https://github.com/llvm/circt/issues/9376"},{"body":"Hi all, \n\nwhen building with the latest [slang](https://github.com/MikePopoloski/slang) master branch, there seems to be an issue with tests on `basic.sv`.\n\nSpecifically, I'm getting the following unexpected output\n```\n$ circt-translate --import-verilog test/Conversion/ImportVerilog/basic.sv | FileCheck test/Conversion/ImportVerilog/basic.sv\n\n../test/Conversion/ImportVerilog/basic.sv:1740:12: error: CHECK: expected string not found in input\n // CHECK: [[V0:%.+]] = moore.extract_ref %z3 from 2\n           ^\n<stdin>:1431:36: note: scanning from here\n %11 = moore.extract_ref %z3 from 1 : <l3> -> <l1>\n                                   ^\n<stdin>:1435:2: note: possible intended match here\n %15 = moore.extract_ref %w3 from 0 : <l2> -> <l1>\n ^\n\nInput file: <stdin>\nCheck file: ../test/Conversion/ImportVerilog/basic.sv\n\n-dump-input=help explains the following input dump.\n\nInput was:\n<<<<<<\n              .\n              .\n              .\n           1426:  %z3 = moore.net wire : <l3> \n           1427:  %w3 = moore.net wire : <l2> \n           1428:  %8 = moore.read %x3 : <l1> \n           1429:  %9 = moore.read %y3 : <l1> \n           1430:  %10 = moore.extract_ref %z3 from 0 : <l3> -> <l1> \n           1431:  %11 = moore.extract_ref %z3 from 1 : <l3> -> <l1> \ncheck:1740'0                                        X~~~~~~~~~~~~~~~ error: no match found\n           1432:  %12 = moore.read %z3 : <l3> \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1433:  %13 = moore.constant 2 : i32 \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1434:  %14 = moore.dyn_extract %12 from %13 : l3, i32 -> l1 \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1435:  %15 = moore.extract_ref %w3 from 0 : <l2> -> <l1> \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ncheck:1740'1      ?                                                  possible intended match\n           1436:  %16 = moore.read %w3 : <l2> \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1437:  %17 = moore.constant 1 : i32 \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1438:  %18 = moore.dyn_extract %16 from %17 : l2, i32 -> l1 \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1439:  %p3.v1, %p3.c1 = moore.instance \"p3\" @MultiPorts(a0: %8: !moore.l1, a1: %9: !moore.l1, v0: %14: !moore.l1, v2: %10: !moore.ref<l1>, c0: %18: !moore.l1) -> (v1: !moore.l1, c1: !moore.l1) \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1440:  moore.assign %11, %p3.v1 : l1 \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n              .\n              .\n              .\n>>>>>>\n\n```\n\nIt looks like `moore.extract_ref %z3 from 2` is missing but therefore we have this:\n```\n%12 = moore.read %z3 : <l3>\n%13 = moore.constant 2 : i32\n%14 = moore.dyn_extract %12 from %13 : l3, i32 -> l1 \n```\n\nDo you have any advice on how to proceed with this?\n\nThanks!","createdAt":"2026-01-22T00:06:42Z","labels":[],"number":9489,"state":"OPEN","title":"[slang] Testing error when switching to slang master branch","url":"https://github.com/llvm/circt/issues/9489"},{"body":"Getting a `error: 'func.call' op operand type mismatch: expected operand type '!moore.union<..., A, ...>', but provided 'A'`.","createdAt":"2025-05-08T20:55:11Z","labels":[],"number":8471,"state":"OPEN","title":"[ImportVerilog] Union type in call","url":"https://github.com/llvm/circt/issues/8471"},{"body":"The following fails verification after `circt-opt -lower-firrtl-to-hw`:\r\n\r\n``` mlir\r\nfirrtl.circuit \"Foo\" {\r\n  firrtl.module private @Foo() {\r\n    %a = firrtl.wire : !firrtl.clock\r\n    %b = firrtl.invalidvalue : !firrtl.clock\r\n    firrtl.strictconnect %a, %b : !firrtl.clock\r\n  }\r\n}\r\n```\r\n\r\nThis fails with:\r\n\r\n```\r\nTitan.mlir:4:10: error: 'hw.bitcast' op result #0 must be Type wherein the bitwidth in hardware is known, but got '!seq.clock'\r\n    %b = firrtl.invalidvalue : !firrtl.clock\r\n         ^\r\nTitan.mlir:4:10: note: see current operation: %2 = \"hw.bitcast\"(%0) : (i1) -> !seq.clock\r\n```\r\n\r\nThe illegal MLIR being produced is:\r\n\r\n``` mlir\r\n\"builtin.module\"() ({\r\n  \"hw.module\"() ({\r\n    %0 = \"hw.constant\"() {value = false} : () -> i1\r\n    %1 = \"hw.wire\"(%2) {name = \"a\"} : (!seq.clock) -> !seq.clock\r\n    %2 = \"hw.bitcast\"(%0) : (i1) -> !seq.clock\r\n    \"hw.output\"() : () -> ()\r\n  }) {comment = \"\", module_type = !hw.modty<>, parameters = [], per_port_attrs = [], result_locs = [], sym_name = \"Foo\", sym_visibility = \"private\"} : () -> ()\r\n}) : () -> ()\r\n```","createdAt":"2024-02-24T01:25:25Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIx","name":"good first issue","description":"Good for newcomers","color":"7057ff"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"},{"id":"MDU6TGFiZWwyMTUyNzU0NzU0","name":"HW","description":"Involving the `hw` dialect","color":"081f7a"}],"number":6740,"state":"OPEN","title":"[FIRRTLToHW] Conversion failure of invalidated wire of clock type","url":"https://github.com/llvm/circt/issues/6740"},{"body":"I want to support this [sv-tests-results/string_concat_op](https://chipsalliance.github.io/sv-tests-results/?v=circt_verilog+11.4.12.2+string_concat_op) feature, but not sure how to fix it properly.\n\n``` sv\nmodule top();\n\nstring str;\n\ninitial begin\n    str = \"Hello\";\nend\n\nendmodule\n```\n\n`circt-verilog`  has the following complaints when compiling the string.sv file:\n```s.sv:3:8: error: failed to legalize operation 'moore.variable'\nstring str;\n       ^\ns.sv:3:8: note: see current operation: %0 = \"moore.variable\"() <{name = \"str\"}> : () -> !moore.ref<string>\n```\n\nThis error is due to MooreToCore's lack of string-type conversion. It only has `StringConstantOpConv` and `Format*OpConversion`; none of these conversions can handle the `string` type.\n","createdAt":"2025-02-28T08:51:12Z","labels":[],"number":8283,"state":"OPEN","title":"[ImportVerilog] Cannot compile forward decleared string type","url":"https://github.com/llvm/circt/issues/8283"},{"body":"It failed when trying to compile https://github.com/pulp-platform/ELAU/blob/b0d113aff6a2d800076f5ebb84f09fba93625bc7/src/SqrtArrUns.sv#L96-L105. \n```\nmoore.module @behavioural_SqrtArrUns(in %X : !moore.l8, out Q : !moore.l4, out R : !moore.l4) {\n  %0 = moore.constant 2 : l8\n  %1 = moore.conversion %X : !moore.l8 -> !moore.real\n  %2 = moore.builtin.sqrt %1 : real\n  %3 = moore.builtin.floor %2 : real\n  %4 = moore.conversion %3 : !moore.real -> !moore.l4\n  %5 = moore.zext %4 : l4 -> l8\n  %6 = moore.powu %5, %0 : l8\n  %7 = moore.sub %X, %6 : l8\n  %8 = moore.trunc %7 : l8 -> l4\n  moore.output %4, %8 : !moore.l4, !moore.l4\n}\n```\n\n```\n[circt-verilog] Running \"convert-moore-to-core\"\ncirct-verilog: /home/uenoku/dev/circt-synth/llvm/llvm/include/llvm/Support/Casting.h:650: decltype(auto) llvm::dyn_cast(const From &) [To = mlir::IntegerType, From = mlir::Type]: Assertion `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.      Program arguments: circt-verilog ../out/SqrtArrUns_behavioral.sv -o build/SqrtArrUns_behavioral/circt/SqrtArrUns_behavioral.mlir --mlir-timing -y ../out ../ext/ELAU/src/arith_utils.sv -mlir-print-ir-after-all -verbose-pass-executions\n #0 0x00005a3051df92b8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/uenoku/dev/circt-synth/llvm/llvm/lib/Support/Unix/Signals.inc:834:13\n #1 0x00005a3051df6e93 llvm::sys::RunSignalHandlers() /home/uenoku/dev/circt-synth/llvm/llvm/lib/Support/Signals.cpp:105:18\n #2 0x00005a3051dfa051 SignalHandler(int, siginfo_t*, void*) /home/uenoku/dev/circt-synth/llvm/llvm/lib/Support/Unix/Signals.inc:426:38\n #3 0x00007ecdbca42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #4 0x00007ecdbca969fc __pthread_kill_implementation ./nptl/./nptl/pthread_kill.c:44:76\n #5 0x00007ecdbca969fc __pthread_kill_internal ./nptl/./nptl/pthread_kill.c:78:10\n #6 0x00007ecdbca969fc pthread_kill ./nptl/./nptl/pthread_kill.c:89:10\n #7 0x00007ecdbca42476 gsignal ./signal/../sysdeps/posix/raise.c:27:6\n #8 0x00007ecdbca287f3 abort ./stdlib/./stdlib/abort.c:81:7\n #9 0x00007ecdbca2871b _nl_load_domain ./intl/./intl/loadmsgcat.c:1177:9\n#10 0x00007ecdbca39e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n#11 0x00005a3050b0d8c4 decltype(auto) llvm::dyn_cast<mlir::IntegerType, mlir::Type>(mlir::Type const&) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x1ad8c4)\n#12 0x00005a3050cb10c5 decltype(auto) llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Type, long>, mlir::Type>::castValue<mlir::IntegerType, mlir::Type const&>(mlir::Type const&) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x3510c5)\n#13 0x00005a3050c9d8da llvm::TypeSwitch<mlir::Type, long>& llvm::TypeSwitch<mlir::Type, long>::Case<mlir::IntegerType, circt::hw::getBitWidth(mlir::Type)::$_0>(circt::hw::getBitWidth(mlir::Type)::$_0&&) HWTypes.cpp:0:0\n#14 0x00005a3050c9d7e6 circt::hw::getBitWidth(mlir::Type) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x33d7e6)\n#15 0x00005a30510f9908 (anonymous namespace)::ConversionOpConversion::matchAndRewrite(circt::moore::ConversionOp, circt::moore::ConversionOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n#16 0x00005a30510fa631 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::ConversionOp>, circt::moore::ConversionOp>(mlir::OpConversionPattern<circt::moore::ConversionOp> const&, circt::moore::ConversionOp, circt::moore::ConversionOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange> >, mlir::ConversionPatternRewriter&) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x79a631)\n```","createdAt":"2025-09-06T09:21:38Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8930,"state":"OPEN","title":"[MooreToCore] Crash with sqrt/floor","url":"https://github.com/llvm/circt/issues/8930"},{"body":"fstring type would never be on port from the current fir parser but it crashes at LowerToHW:\n\n```mlir\nfirrtl.circuit \"Printf\"{\n  // CHECK-LABEL: module Printf\n  firrtl.module @Printf(in %clock: !firrtl.fstring) attributes {convention = #firrtl<convention scalarized>} {\n  }\n}\n```\n\n```\n$  firtool bar.mlir\n\nfirtool: /scratch/hidetou/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:2562: llvm::LogicalResult (anonymous namespace)::FIRRTLLowering::setLowering(mlir::Value, mlir::Value): Assertion `(!result || !type_isa<FIRRTLType>(result.getType())) && \"Lowering didn't turn a FIRRTL value into a non-FIRRTL value\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.      Program arguments: ./build/bin/firtool bar.mlir\n #0 0x00000000007ceb97 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:804:13\n #1 0x00000000007ccad0 llvm::sys::RunSignalHandlers() /scratch/hidetou/circt/llvm/llvm/lib/Support/Signals.cpp:106:18\n #2 0x00000000007cf4aa SignalHandler(int, siginfo_t*, void*) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3\n #3 0x00007f083c2b1cf0 __restore_rt (/lib64/libpthread.so.0+0x12cf0)\n #4 0x00007f083b36aacf raise (/lib64/libc.so.6+0x4eacf)\n #5 0x00007f083b33dea5 abort (/lib64/libc.so.6+0x21ea5)\n #6 0x00007f083b33dd79 _nl_load_domain.cold.0 (/lib64/libc.so.6+0x21d79)\n #7 0x00007f083b363426 (/lib64/libc.so.6+0x47426)\n #8 0x0000000000d2176a decltype(auto) llvm::dyn_cast<circt::firrtl::LHSType, mlir::Type>(mlir::Type const&) /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/Casting.h:650:3\n #9 0x0000000000d2176a decltype(auto) llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Type, circt::firrtl::FIRRTLBaseType>, mlir::Type>::castValue<circt::firrtl::LHSType, mlir::Type const&>(mlir::Type const&) /scratch/hidetou/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:67:12\n#10 0x0000000000d2176a llvm::TypeSwitch<mlir::Type, circt::firrtl::FIRRTLBaseType>& llvm::TypeSwitch<mlir::Type, circt::firrtl::FIRRTLBaseType>::Case<circt::firrtl::LHSType, circt::firrtl::getBaseType(mlir::Type)::'lambda0'(auto)>(circt::firrtl::getBaseType(mlir::Type)::'lambda0'(auto)&&) /scratch/hidetou/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:101:26\n#11 0x0000000000d2176a circt::firrtl::getBaseType(mlir::Type) /scratch/hidetou/circt/include/circt/Dialect/FIRRTL/FIRRTLUtils.h:225:8\n#12 0x0000000000d2176a (anonymous namespace)::FIRRTLLowering::setLowering(mlir::Value, mlir::Value) /scratch/hidetou/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:2565:21\n#13 0x0000000000d1ee1f llvm::LogicalResult::failed() const /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:43:43\n#14 0x0000000000d1ee1f llvm::failed(llvm::LogicalResult) /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:71:58\n#15 0x0000000000d1ee1f (anonymous namespace)::FIRRTLLowering::run() /scratch/hidetou/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1985:9\n#16 0x0000000000d1ee1f (anonymous namespace)::FIRRTLModuleLowering::lowerModuleOperations(circt::hw::HWModuleOp, (anonymous namespace)::CircuitLoweringState&) /scratch/hidetou/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1977:48\n#17 0x0000000000d152a8 llvm::LogicalResult::failed() const /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:43:43\n#18 0x0000000000d152a8 llvm::failed(llvm::LogicalResult) /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:71:58\n#19 0x0000000000d152a8 llvm::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_10>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_10&&) /scratch/hidetou/circt/llvm/llvm/../mlir/include/mlir/IR/Threading.h:46:11\n#20 0x0000000000d152a8 llvm::LogicalResult mlir::failableParallelForEach<llvm::iota_range<unsigned long>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_10>(mlir::MLIRContext*, llvm::iota_range<unsigned long>&&, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_10&&) /scratch/hidetou/circt/llvm/llvm/../mlir/include/mlir/IR/Threading.h:92:10\n#21 0x0000000000d152a8 llvm::LogicalResult mlir::failableParallelForEachN<(anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_10>(mlir::MLIRContext*, unsigned long, unsigned long, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_10&&) /scratch/hidetou/circt/llvm/llvm/../mlir/include/mlir/IR/Threading.h:107:10\n#22 0x0000000000d152a8 (anonymous namespace)::FIRRTLModuleLowering::runOnOperation() /scratch/hidetou/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:753:17\n#23 0x000000000148cff9 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_7::operator()() const /scratch/hidetou/circt/llvm/mlir/lib/Pass/Pass.cpp:0:17\n#24 0x000000000148cff9 void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_7>(long) /scratch/hidetou/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:46:12\n#25 0x000000000148cff9 llvm::function_ref<void ()>::operator()() const /scratch/hidetou/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:69:12\n#26 0x000000000148cff9 void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(llvm::function_ref<void ()>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) /scratch/hidetou/circt/llvm/mlir/include/mlir/IR/MLIRContext.h:288:7\n#27 0x000000000148cff9 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /scratch/hidetou/circt/llvm/mlir/lib/Pass/Pass.cpp:520:21\n#28 0x000000000148fdbf llvm::LogicalResult::failed() const /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:43:43\n#29 0x000000000148fdbf llvm::failed(llvm::LogicalResult) /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:71:58\n#30 0x000000000148fdbf mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /scratch/hidetou/circt/llvm/mlir/lib/Pass/Pass.cpp:592:9\n#31 0x000000000148fdbf mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /scratch/hidetou/circt/llvm/mlir/lib/Pass/Pass.cpp:905:10\n#32 0x000000000148fdbf mlir::PassManager::run(mlir::Operation*) /scratch/hidetou/circt/llvm/mlir/lib/Pass/Pass.cpp:885:60\n#33 0x0000000000758686 llvm::LogicalResult::failed() const /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:43:43\n#34 0x0000000000758686 llvm::failed(llvm::LogicalResult) /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:71:58\n#35 0x0000000000758686 processBuffer(mlir::MLIRContext&, circt::firtool::FirtoolOptions&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /scratch/hidetou/circt/tools/firtool/firtool.cpp:561:7\n#36 0x00000000007572fb processInputSplit(mlir::MLIRContext&, circt::firtool::FirtoolOptions&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /scratch/hidetou/circt/tools/firtool/firtool.cpp:619:12\n#37 0x0000000000752e60 processInput(mlir::MLIRContext&, circt::firtool::FirtoolOptions&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /scratch/hidetou/circt/tools/firtool/firtool.cpp:635:12\n#38 0x0000000000752e60 executeFirtool(mlir::MLIRContext&, circt::firtool::FirtoolOptions&) /scratch/hidetou/circt/tools/firtool/firtool.cpp:727:14\n#39 0x0000000000751288 llvm::LogicalResult::failed() const /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:43:43\n#40 0x0000000000751288 llvm::failed(llvm::LogicalResult) /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:71:58\n#41 0x0000000000751288 main /scratch/hidetou/circt/tools/firtool/firtool.cpp:822:8\n#42 0x00007f083b356d85 __libc_start_main (/lib64/libc.so.6+0x3ad85)\n#43 0x000000000075030e _start (./build/bin/firtool+0x75030e)\nAborted\n```\n\nIdeally IR verifier should catch this ","createdAt":"2025-04-02T11:46:38Z","labels":[],"number":8382,"state":"OPEN","title":"[FIRRTL] Crash with fstring type on port","url":"https://github.com/llvm/circt/issues/8382"},{"body":"@jiahanxie353 has added the Math dialect to circt-opt in #8475. This is a great precedent to start using that dialect in the MooreToCore conversion. For example, the `moore.pow` operation could be lowered to `math.ipowi` and `math.powf` depending on its type.","createdAt":"2025-05-12T16:08:01Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIx","name":"good first issue","description":"Good for newcomers","color":"7057ff"},{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8476,"state":"OPEN","title":"[MooreToCore] Lower exponentiation to `math.ipowi`","url":"https://github.com/llvm/circt/issues/8476"},{"body":"With https://github.com/llvm/circt/pull/3452, rudimentary enum support is now available in CIRCT. However, this commit leaves encoding of the enum up to a lowering pass (which currently, in #3478, will leave this up to the synthesis tool).\r\n\r\nSome things to consider in this domain:\r\n\r\n### Base types\r\nSpecifying a base type for an enum should restrict the encoding space and be reflected in the emitted SV and by default, an enum should be emitted as an unsigned integer:\r\ne.g.:\r\n```mlir\r\nhw.typedecl @myEnum : !hw.enum[i5]<A, B, C>\r\nhw.typedecl @myEnum2 : !hw.enum<D, E, F>\r\n```\r\nemits as\r\n```sv\r\ntypedef enum bit [4:0] {A, B, C} myEnum_t;\r\ntypedef enum unsigned integer {D, E, F} myEnum2_t;\r\n```\r\n\r\n###  Encoding values: \r\nAllow specifying user-defined encodings for enum fields in either binary or decimal.\r\n```mlir\r\nhw.typedecl @myEnum : !hw.enum[i3]<A : 1, B : b10, C>\r\n```\r\nemits as\r\n```sv\r\ntypedef enum bit [2:0] {A = 3'b001, B = 3'b010, C} myEnum_t;\r\n```\r\n\r\nIn case an explicit base type has been defined, we should check whether the requested encoding fits within the specified bitvector.\r\n\r\n**Q:** how do we handle invalid/partial encodings?\r\n```mlir\r\nhw.typedecl @myEnum : !hw.enum[i2]<A : 3, B, C>\r\n```\r\nDepending on how downstream lowering and tooling interprets the above, it may (incrementally assigned: `B==4, C==5`) or may not (assigned to available encodings `B==0, C==1`) be illegal. My hunch is that codifying something here can lead into a rabithole that may not be relevant for anyones immediate use-case. My suggestion would be to only verify that requested encoding values fit within the base type, and then let downstream tooling decide whether or not something is an invalid enum.\r\n\r\n### Bitvector casting\r\nInteger casting allows interpreting enums as bitvectors and vice versa:\r\n\r\n```mlir\r\n%0 = hw.constant 3 : i3 // A, B \r\n%1 = hw.enum_cast %0 : i3 to !hw.enum[i3]<A = 0b1, B = 0b10, C>\r\n%2 = hw.enum_cast %1 : !hw.enum[i3]<A, B, C> to i5\r\n```\r\n\r\n**Q**: Should we only allow bitcasting on enums with explicit base types? Or should enums by default be considered as having a `i32` base type unless explicitly specified?\r\n\r\n### FSM encoding\r\nCurrently, FSM conversion is the only user of the `hw` enum type. In this conversion , we also have explicit awareness of where our state register is, and how we might want the synthesis tool to infer our state machine. FSM encoding attributes are generally supported across different tools ([vivado](https://docs.xilinx.com/r/en-US/ug901-vivado-synthesis/FSM_ENCODING), [quartus](https://www.intel.com/content/www/us/en/programmable/quartushelp/17.0/hdl/vlog/vlog_file_dir_syn_encoding.htm)) and it would be due diligence to consider whether such FSM encoding attributes are an inherent part of an enum type or if it is specific to the site which uses the enum type.\r\n\r\nIf part of the enum type, there could be 'smarts' which determine that some using ops (like `sv.reg`) needs to be emitted with an fsm encoding attribute:\r\n```mlir\r\nhw.typedecl @myEnum : !hw.enum['onehot']<A, B, C>\r\n%state_reg = sv.reg : !hw.enum<A, B, C>\r\n// emits as\r\ntypedef enum {A, B, C} myEnum_t;\r\n(* fsm_encoding = \"one_hot\" *) myEnum_t state_reg ;\r\n```\r\n\r\nIf not, the attribute could be attached directly to the using op, possibly as an attribute of the `fsm` dialect;\r\n```mlir\r\nhw.typedecl @myEnum : !hw.enum<A, B, C>\r\n%state_reg = sv.reg : !hw.enum<A, B, C> attributes {fsm.encoding = 'onehot'}\r\n```\r\nWhich is lowered to an appropriate SV attribute based on the target tooling:\r\n```mlir\r\nhw.typedecl @myEnum : !hw.enum<A, B, C>\r\n// circt-opt --lower-fsm-encodings=\"target=quartus\"\r\n%state_reg = sv.reg svattrs [#sv.attribute<\"syn_encoding\" = \"one-hot\">] : !hw.enum<A, B, C>\r\n\r\n// circt-opt --lower-fsm-encodings=\"target=vivado\"\r\n%state_reg = sv.reg svattrs [#sv.attribute<\"fsm_encoding\" = \"one_hot\">] : !hw.enum<A, B, C>\r\n```\r\n","createdAt":"2022-07-06T09:23:36Z","labels":[{"id":"MDU6TGFiZWwyMTUyNzU0NzU0","name":"HW","description":"Involving the `hw` dialect","color":"081f7a"},{"id":"LA_kwDODpuCgs710LVx","name":"FSM","description":"the FSM dialect","color":"E9BD94"}],"number":3480,"state":"OPEN","title":"[HW] Encoding enum types and values","url":"https://github.com/llvm/circt/issues/3480"},{"body":"I have a Docker-based repro: https://github.com/llvm/circt/blob/crashes-1804/utils/run-docker-1804.sh. Just run `./utils/run-docker-1804.sh`. This is running the LLVM build in the release config w/ asserts enabled and CIRCT in debug. I've attached a log of the crashes: [test_fails.log](https://github.com/llvm/circt/files/6495753/test_fails.log).\r\n\r\n\r\n```\r\nFailed Tests (210):\r\n  CIRCT :: CAPI/ir.c\r\n  CIRCT :: Conversion/FIRRTLToHW/errors.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-errors.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-module.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/zero-width.mlir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/connect.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_inouts.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_ins.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_none.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_outs.fir\r\n  CIRCT :: Conversion/HWToLLHD/errors.mlir\r\n  CIRCT :: Conversion/HWToLLHD/structure.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/simple_addi.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_branch.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_buffer.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_cmerge.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_conditional_branch.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_constant.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_fork.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_join.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_lazy_fork.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_load.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_memory.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_merge.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_mux.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_sink.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_store.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_arithmetic.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_bitwise.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_entity.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_extract.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_insert.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_memory.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_process_persistence.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_signals.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_simple.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_value_creation.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_wait.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/Affine/errors.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-for.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-load-store.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test1.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test10.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test11.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test12.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test13.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test14.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test15.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test16.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test17.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test18.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test19.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test2.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test20.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test21.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test22.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test23.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test24.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test25.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test26.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test27.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test28.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test29.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test3.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test30.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test31.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test32.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test33.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test34.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test35.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test4.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test5.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test6.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test7.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test8.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test9.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test_canonicalize.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer_errors.mlir\r\n  CIRCT :: Conversion/StandardToStaticLogic/test_pipeline.mlir\r\n  CIRCT :: Dialect/ESI/connectivity.mlir\r\n  CIRCT :: Dialect/ESI/errors.mlir\r\n  CIRCT :: Dialect/ESI/lowering.mlir\r\n  CIRCT :: Dialect/ESI/modwrap.mlir\r\n  CIRCT :: Dialect/ESI/wrapif-lowering.mlir\r\n  CIRCT :: Dialect/FIRRTL/annotations.fir\r\n  CIRCT :: Dialect/FIRRTL/blackbox-memory.mlir\r\n  CIRCT :: Dialect/FIRRTL/canonicalization.mlir\r\n  CIRCT :: Dialect/FIRRTL/check-widths-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/connect-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/connect.mlir\r\n  CIRCT :: Dialect/FIRRTL/const-prop-single-module.mlir\r\n  CIRCT :: Dialect/FIRRTL/cse.mlir\r\n  CIRCT :: Dialect/FIRRTL/errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/expand-whens-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/expand-whens.mlir\r\n  CIRCT :: Dialect/FIRRTL/imconstprop.mlir\r\n  CIRCT :: Dialect/FIRRTL/infer-widths-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/infer-widths.mlir\r\n  CIRCT :: Dialect/FIRRTL/inliner.mlir\r\n  CIRCT :: Dialect/FIRRTL/lower-types-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/lower-types.mlir\r\n  CIRCT :: Dialect/FIRRTL/parse-basic.fir\r\n  CIRCT :: Dialect/FIRRTL/parse-errors.fir\r\n  CIRCT :: Dialect/FIRRTL/parse-locations.fir\r\n  CIRCT :: Dialect/FIRRTL/test.mlir\r\n  CIRCT :: Dialect/HW/basic.mlir\r\n  CIRCT :: Dialect/HW/bitwise.mlir\r\n  CIRCT :: Dialect/HW/canonicalization.mlir\r\n  CIRCT :: Dialect/HW/errors.mlir\r\n  CIRCT :: Dialect/HW/greybox.mlir\r\n  CIRCT :: Dialect/HW/modules.mlir\r\n  CIRCT :: Dialect/HW/svEmitErrors.mlir\r\n  CIRCT :: Dialect/HW/typedecls.mlir\r\n  CIRCT :: Dialect/HW/types.mlir\r\n  CIRCT :: Dialect/Handshake/errors.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/arithmetic.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/bitwise.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/constant.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/extract.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/memory.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/probeCSE.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/signalOps.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_arithmetic.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_bitwise.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_entity.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_relations.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_sig.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_sig_errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/arithmetic.mlir\r\n  CIRCT :: Dialect/LLHD/IR/array.mlir\r\n  CIRCT :: Dialect/LLHD/IR/bitwise.mlir\r\n  CIRCT :: Dialect/LLHD/IR/connect-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/connect.mlir\r\n  CIRCT :: Dialect/LLHD/IR/const.mlir\r\n  CIRCT :: Dialect/LLHD/IR/entity.mlir\r\n  CIRCT :: Dialect/LLHD/IR/extract-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/extract.mlir\r\n  CIRCT :: Dialect/LLHD/IR/insert-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/insert.mlir\r\n  CIRCT :: Dialect/LLHD/IR/inst-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/inst.mlir\r\n  CIRCT :: Dialect/LLHD/IR/memory.mlir\r\n  CIRCT :: Dialect/LLHD/IR/proc.mlir\r\n  CIRCT :: Dialect/LLHD/IR/reg.mlir\r\n  CIRCT :: Dialect/LLHD/IR/signal-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/signal.mlir\r\n  CIRCT :: Dialect/LLHD/IR/time.mlir\r\n  CIRCT :: Dialect/LLHD/IR/tuple.mlir\r\n  CIRCT :: Dialect/LLHD/IR/wait.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_arbitrary_signal_size.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_array_boundary_check.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_bit_precision_drives.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_formats.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_process.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_reg.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_shifts.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_simple.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_wait.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/earlyCodeMotion.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/memoryToBlockArgument.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/processLowering.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/processLoweringErrors.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/totalFunctionInlining.mlir\r\n  CIRCT :: Dialect/MSFT/location.mlir\r\n  CIRCT :: Dialect/MSFT/opt-errors.mlir\r\n  CIRCT :: Dialect/MSFT/translate-errors.mlir\r\n  CIRCT :: Dialect/SV/basic.mlir\r\n  CIRCT :: Dialect/SV/canonicalization.mlir\r\n  CIRCT :: Dialect/SV/errors.mlir\r\n  CIRCT :: Dialect/SV/hw-cleanup.mlir\r\n  CIRCT :: Dialect/SV/hw-generator-callout.mlir\r\n  CIRCT :: Dialect/SV/hw-legalize-names-errors.mlir\r\n  CIRCT :: Dialect/SV/hw-legalize-names.mlir\r\n  CIRCT :: Dialect/SV/hw-memsim.mlir\r\n  CIRCT :: Dialect/SV/interfaces.mlir\r\n  CIRCT :: Dialect/SV/prettify-verilog.mlir\r\n  CIRCT :: Dialect/Seq/basic.mlir\r\n  CIRCT :: ExportVerilog/hw-dialect.mlir\r\n  CIRCT :: ExportVerilog/hw-typedecls.mlir\r\n  CIRCT :: ExportVerilog/line-length.mlir\r\n  CIRCT :: ExportVerilog/load-dialect.mlir\r\n  CIRCT :: ExportVerilog/sv-alwaysff.mlir\r\n  CIRCT :: ExportVerilog/sv-dialect.mlir\r\n  CIRCT :: ExportVerilog/sv-interfaces.mlir\r\n  CIRCT :: ExportVerilog/verilog-basic.mlir\r\n  CIRCT :: ExportVerilog/verilog-errors.mlir\r\n  CIRCT :: circt-opt/trivial.mlir\r\n  CIRCT :: circt-translate/parse_int64.fir\r\n  CIRCT :: firtool/firtool.fir\r\n  CIRCT :: firtool/firtool.mlir\r\n  CIRCT :: firtool/optimizations.fir\r\n  CIRCT :: firtool/phase-ordering.fir\r\n  CIRCT :: firtool/split-verilog.mlir\r\n  CIRCT :: firtool/style.fir\r\n  CIRCT :: handshake-runner/call_bb.mlir\r\n  CIRCT :: handshake-runner/cdiv-old-std.mlir\r\n  CIRCT :: handshake-runner/cdiv-std.mlir\r\n  CIRCT :: handshake-runner/complex_bb.mlir\r\n  CIRCT :: handshake-runner/floydwarshall-std.mlir\r\n  CIRCT :: handshake-runner/histogram-std.mlir\r\n  CIRCT :: handshake-runner/loadstore.mlir\r\n  CIRCT :: handshake-runner/loop-check-1-std.mlir\r\n  CIRCT :: handshake-runner/loop-check-2-std.mlir\r\n  CIRCT :: handshake-runner/matmul-check-std.mlir\r\n  CIRCT :: handshake-runner/matmul-std.mlir\r\n  CIRCT :: handshake-runner/memory_simple_2_std.mlir\r\n  CIRCT :: handshake-runner/memory_simple_std.mlir\r\n  CIRCT :: handshake-runner/simple_loop.mlir\r\n\r\n\r\nTesting Time: 1.34s\r\n  Unsupported:   4\r\n  Passed     :   6\r\n  Failed     : 210\r\n```","createdAt":"2021-05-17T17:43:44Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"}],"number":1065,"state":"OPEN","title":"[CI] Most tests fail on Ubuntu 18.04","url":"https://github.com/llvm/circt/issues/1065"},{"body":"```bash\r\n$ circt-opt test/Conversion/ExportVerilog/hw-dialect.mlir --test-apply-lowering-options='options=emittedLineLength=100,emitBindComments' -export-verilog -verify-diagnostics -o a.mlir\r\n$ circt-opt a.mlir\r\na.mlir:788:56: error: expected non-function type\r\n    %1 = sv.wire {hw.verilogName = \"_GEN\"} : !hw.inout<union<c: i1>>\r\n```","createdAt":"2024-07-23T04:52:15Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwyMTUyNzU0NzU0","name":"HW","description":"Involving the `hw` dialect","color":"081f7a"}],"number":7378,"state":"OPEN","title":"[HW] Roundtrip test fail for !hw.union ","url":"https://github.com/llvm/circt/issues/7378"},{"body":"Hello, I am attempting to export a Verilog file to smtlib and am receiving errors or an empty file. Could someone clarify how complete the functionality is or what the pipeline formats are for conversion?\n\n\nP.S. I am also trying to figure out how to get the verif dialect, since I am unable to do so.","createdAt":"2025-10-24T23:12:40Z","labels":[],"number":9138,"state":"OPEN","title":"export to smtlib","url":"https://github.com/llvm/circt/issues/9138"},{"body":"Dear @maerhart @fabianschuiki ,\r\n When lowering `SV` to `Hw` Dialect, there is a stack dump. \r\nDriver: circt-verilog %s\r\n```\r\nmodule top();\r\n  typedef struct {\r\n    int a;\r\n    int b;\r\n  } ms_t;\r\n\r\n  ms_t ms;\r\n\r\n  initial begin\r\n    ms = '{ 0, 1};\r\n\r\n    ms = '{ default:1, int:1};\r\n\r\n    ms = '{ int:0, int:1};\r\n  end\r\n\r\nendmodule\r\n```\r\nIt can be converted to `moore` Dialect like this\r\nDriver:  circt-verilog --ir-moore %s\r\n```\r\nmodule {\r\n  moore.module @top() {\r\n    %0 = moore.constant 1 : i32\r\n    %1 = moore.constant 0 : i32\r\n    %ms = moore.variable : <ustruct<{a: i32, b: i32}>>\r\n    moore.procedure initial {\r\n      %2 = moore.struct_create %1, %0 : !moore.i32, !moore.i32 -> ustruct<{a: i32, b: i32}>\r\n      moore.blocking_assign %ms, %2 : ustruct<{a: i32, b: i32}>\r\n      %3 = moore.struct_create %0, %0 : !moore.i32, !moore.i32 -> ustruct<{a: i32, b: i32}>\r\n      moore.blocking_assign %ms, %3 : ustruct<{a: i32, b: i32}>\r\n      moore.blocking_assign %ms, %3 : ustruct<{a: i32, b: i32}>\r\n      moore.return\r\n    }\r\n    moore.output\r\n  }\r\n}\r\n```\r\nBut it got stack dump when casting `hw::InOutType`. Maybe `structType` should be converted somehow.\r\nThis is part of error codes.\r\n```\r\n#19 0x00005f9660f42af4 (anonymous namespace)::OperationLegalizer::legalizeWithPattern(mlir::Operation*, mlir::ConversionPatternRewriter&) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:1958:21\r\n#20 0x00005f9660f3b100 (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:1850:17\r\n#21 0x00005f9660f3aa73 mlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:2384:26\r\n#22 0x00005f9660f3b41f mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:2436:16\r\n#23 0x00005f9660f3fdfc mlir::applyFullConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:3447:22\r\n#24 0x00005f9660f3fe9d mlir::applyFullConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:3453:10\r\n#25 0x00005f965faed60d (anonymous namespace)::MooreToCorePass::runOnOperation() /home/pluto/Documents/circt/circt/lib/Conversion/MooreToCore/MooreToCore.cpp:1398:14\r\n```","createdAt":"2024-08-20T01:51:29Z","labels":[],"number":7535,"state":"OPEN","title":"[MooreToCore] VariableOp lowered failed","url":"https://github.com/llvm/circt/issues/7535"},{"body":"I'm looking into the failing testcase for `real` constants [on sv-tests-results](https://chipsalliance.github.io/sv-tests-results/?v=circt_verilog+5.7.2+real-constants). Just want to put it up here to make sure no one else has already started working on it.","createdAt":"2025-02-23T19:01:31Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8269,"state":"OPEN","title":"[MooreToCore] Support `real` constants","url":"https://github.com/llvm/circt/issues/8269"},{"body":"Currently, CIRCT's MooreToCore pass converts unpacked arrays to packed arrays (hw::ArrayType),\nlosing the unpacked semantics.\n\nWhen we've attempted to preserve unpacked arrays by emitting hw::UnpackedArrayType,\nMLIR raises \"failed to legalize operation\" errors.\n\n## Minimal Reproduction\n\nWhen running `circt-opt` on the following input,\n\n```systemverilog\nmodule a (\n  input logic b[3:0]\n);\nendmodule\n```\n\nwe get the following result:\n\n```mlir\nmodule {\n  hw.module @a(in %b : !hw.array<4xi1>) {\n    hw.output\n  }\n}\n```\n\nas you can clearly see, the `uarray` is converted to a `array`.\n","createdAt":"2025-02-26T14:37:40Z","labels":[],"number":8276,"state":"OPEN","title":"[MooreToCore] Support for UnpackedArrayType emission","url":"https://github.com/llvm/circt/issues/8276"},{"body":"```mlir\r\nhw.module @TopXMRAsserts(%I: !hw.inout<i1>) -> () {}\r\nhw.module @Top() -> () {\r\n    %I = sv.wire : !hw.inout<i1>\r\n    hw.instance \"TopXMRAsserts_inst0\" sym @Top.TopXMRAsserts_inst0 @TopXMRAsserts(I: %I: !hw.inout<i1>) -> () {doNotPrint = 1}\r\n}\r\nsv.bind #hw.innerNameRef<@Top::@Top.TopXMRAsserts_inst0>\r\n```\r\n`circt-opt -export-verilog`:\r\n```\r\ncirct-opt: /home/uenoku/dev/circt/llvm/llvm/../mlir/include/mlir/IR/StorageUniquerSupport.h:153: static ConcreteT mlir::detail::StorageUserBase<circt::hw::InOutType, mlir::Type, circt::hw::detail::InOutTypeStorage, mlir::detail::TypeUniquer>::get(mlir::MLIRContext *, Args...) [ConcreteT = circt::hw::InOutType, BaseT = mlir::Type, StorageT = circt::hw::detail::InOutTypeStorage, UniquerT = mlir::detail::TypeUniquer, Traits = <>, Args = <mlir::Type>]: Assertion `succeeded(ConcreteT::verify(getDefaultDiagnosticEmitFn(ctx), args...))' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\n #0 0x000055ccf68fee23 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/uenoku/dev/circt/llvm/llvm/lib/Support/Unix/Signals.inc:569:13\r\n #1 0x000055ccf68fd0e0 llvm::sys::RunSignalHandlers() /home/uenoku/dev/circt/llvm/llvm/lib/Support/Signals.cpp:104:18\r\n #2 0x000055ccf68ff47a SignalHandler(int) /home/uenoku/dev/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #3 0x00007f04f0242520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #4 0x00007f04f0296a7c __pthread_kill_implementation ./nptl/pthread_kill.c:44:76\r\n #5 0x00007f04f0296a7c __pthread_kill_internal ./nptl/pthread_kill.c:78:10\r\n #6 0x00007f04f0296a7c pthread_kill ./nptl/pthread_kill.c:89:10\r\n #7 0x00007f04f0242476 gsignal ./signal/../sysdeps/posix/raise.c:27:6\r\n #8 0x00007f04f02287f3 abort ./stdlib/abort.c:81:7\r\n #9 0x00007f04f022871b _nl_load_domain ./intl/loadmsgcat.c:1177:9\r\n#10 0x00007f04f0239e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n#11 0x000055ccf6eb5897 (./bin/circt-opt+0xb1b897)\r\n#12 0x000055ccf6fd56e8 circt::sv::WireOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Type, mlir::StringAttr, mlir::StringAttr) /home/uenoku/dev/circt/lib/Dialect/SV/SVOps.cpp:1296:21\r\n#13 0x000055ccf6ffd651 circt::sv::WireOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Type, llvm::StringRef) /home/uenoku/dev/circt/build/tools/circt/include/circt/Dialect/SV/SV.cpp.inc:15061:7\r\n#14 0x000055ccf6a68d51 circt::sv::WireOp mlir::OpBuilder::create<circt::sv::WireOp, mlir::Type, llvm::SmallString<32u>&>(mlir::Location, mlir::Type&&, llvm::SmallString<32u>&) /home/uenoku/dev/circt/llvm/llvm/../mlir/include/mlir/IR/Builders.h:460:16\r\n#15 0x000055ccf6a658ac spillWiresForInstanceInputs(circt::hw::InstanceOp) /home/uenoku/dev/circt/lib/Conversion/ExportVerilog/PrepareForEmission.cpp:103:28\r\n#16 0x000055ccf6a658ac legalizeHWModule(mlir::Block&, circt::LoweringOptions const&) /home/uenoku/dev/circt/lib/Conversion/ExportVerilog/PrepareForEmission.cpp:735:9\r\n```\r\n","createdAt":"2022-09-30T15:30:25Z","labels":[],"number":4036,"state":"OPEN","title":"[PrepareForEmission] Crash when inout operations are passed to instance ports","url":"https://github.com/llvm/circt/issues/4036"},{"body":"Hi! Now I try to add types and operators in sim to get the lowered operators in moore, and then lower them to llvm dialect, so that the corresponding dynamic size container can be implemented in arcilator.\n\nFirst, add IntType and RefType in sim, as well as VariableOp, BlockAssignOp, Print, ReadOp, and ConcatOp operators.\nTaking Variable as an example, creating a stringtype VariableOp in Moore will create an int type through string_constant, and then perform conversionOp to convert the int type to Stringtype, and finally create VariableOp. In sim, if VariableOp can directly accept int type, the conversion time can be saved. Therefore, I think it is not necessary to add StringType separately, and only use Int Type and RefType to represent it.\n\nIn sim to llvm dialect, VariableOp will be converted into a series of Ops. First, llvm.alloca will be used to create an i128 memory, which will be divided into i32 size to record the string length, and i96 data to record the string content. Then, llvm.getelementptrOp and llvm.storeOp are used to store the contents in the corresponding locations. This memory will be dynamically doubled according to the length of the string.\n\nCan you give me some advise?","createdAt":"2025-03-20T02:36:53Z","labels":[],"number":8332,"state":"OPEN","title":"[MooreToCore] Support for StringType from moore to llvm dialect","url":"https://github.com/llvm/circt/issues/8332"},{"body":"While the RTL dialect has no notion of signs, this is not the only source of IntegerTypes for the SV dialect. If a dialect wants to print signed or unsigned integers (e.g. `wire signed [7:0] signed8BitInt`), there is currently no way to do that. I think it's fair to emit the SystemVerilog keywords `signed` and `unsigned` in module ports and wire/reg declarations for IntegerTypes which are not signless.","createdAt":"2021-01-17T02:53:26Z","labels":[],"number":469,"state":"OPEN","title":"[ExportVerilog] Should emit unsigned/signed for IntegerTypes which are not signless","url":"https://github.com/llvm/circt/issues/469"}]
[{"body":"## Bug Description\n\n`circt-verilog` crashes with an assertion failure when processing a SystemVerilog module that has a `string` type output port. The crash occurs during the MooreToCore conversion pass when the `getModulePortInfo()` function fails to properly handle cases where type conversion returns an invalid/empty type, causing a `dyn_cast` assertion failure in `ModulePortInfo::sanitizeInOut()`.\n\nThis is a valid SystemVerilog construct per IEEE 1800-2017 Section 6.16 (String data type). Both **slang** and **verilator** accept the code without errors.\n\n## Steps to Reproduce\n\n1. Save the following test case as `bug.sv`\n2. Run: `circt-verilog --ir-hw bug.sv`\n\n## Test Case\n\n```systemverilog\nmodule test_module(output string a);\nendmodule\n```\n\n## Expected Behavior\n\nCIRCT should either:\n1. Support simulation constructs like string ports appropriately, OR\n2. Emit a proper diagnostic error message indicating that string ports are not supported for hardware synthesis\n\n## Actual Behavior\n\nThe tool crashes with an assertion failure:\n\n```\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: circt-verilog --ir-hw bug.sv\n #0 0x00007fe810a738a8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x2008a8)\n #1 0x00007fe810a712f5 llvm::sys::RunSignalHandlers() (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x1fe2f5)\n #2 0x00007fe810a74631 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x00007fe810581330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #4 0x00007fe814c958ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007fe814c95b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007fe814c95530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n #7 0x00007fe812fa7438 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2a438)\n #8 0x00007fe812f718ed void llvm::function_ref<void ()>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_0>(long) PatternApplicator.cpp:0:0\n #9 0x00007fe812f6e774 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/opt/firtool-1.139.0/bin/../lib/libMLIRRewrite.so+0x7774)\n#10 0x00007fe812fa8c6f (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*) DialectConversion.cpp:0:0\n#11 0x00007fe812fa8470 mlir::OperationConverter::convert(mlir::Operation*, bool) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2b470)\n#12 0x00007fe812fa8dae mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2bdae)\n#13 0x00007fe812fb68e4 void llvm::function_ref<void ()>::callback_fn<applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode)::$_0>(long) DialectConversion.cpp:0:0\n#14 0x00007fe812fadf7d applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode) DialectConversion.cpp:0:0\n#15 0x00007fe812fae0fe mlir::applyFullConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x310fe)\n#16 0x00007fe814c67231 (anonymous namespace)::MooreToCorePass::runOnOperation() MooreToCore.cpp:0:0\n#17 0x00007fe812d632a5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x172a5)\n#18 0x00007fe812d667a9 mlir::PassManager::run(mlir::Operation*) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x1a7a9)\n#19 0x0000561bab9605d0 executeWithSources(mlir::MLIRContext*, llvm::SourceMgr&) circt-verilog.cpp:0:0\n#20 0x0000561bab95bdd5 execute(mlir::MLIRContext*) circt-verilog.cpp:0:0\n#21 0x0000561bab95b4b8 main (/opt/firtool-1.139.0/bin/circt-verilog+0x84b8)\n#22 0x00007fe8105661ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#23 0x00007fe81056628b call_init ./csu/../csu/libc-start.c:128:20\n#24 0x00007fe81056628b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#25 0x0000561bab95ab05 _start (/opt/firtool-1.139.0/bin/circt-verilog+0x7b05)\n\n```\n\n## Root Cause Analysis\n\n### Crash Location\n- **File**: `lib/Conversion/MooreToCore/MooreToCore.cpp`\n- **Function**: `getModulePortInfo()` → calls `ModulePortInfo::sanitizeInOut()`\n- **Assertion**: `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"`\n\n### Analysis\n\nThe root cause is **missing validation of type conversion result** in `getModulePortInfo()`:\n\n```cpp\n// MooreToCore.cpp:233-259\nstatic hw::ModulePortInfo getModulePortInfo(const TypeConverter &typeConverter,\n                                            SVModuleOp op) {\n  // ...\n  for (auto port : moduleTy.getPorts()) {\n    Type portTy = typeConverter.convertType(port.type);  // <-- May return empty Type!\n    // ...\n    ports.push_back(hw::PortInfo({{port.name, portTy, port.dir}, ...}));  // <-- Stores empty Type\n  }\n  return hw::ModulePortInfo(ports);  // <-- Constructor calls sanitizeInOut()\n}\n```\n\nWhen `typeConverter.convertType()` fails for the `string` port type (returns empty `Type`), this invalid type is passed to `sanitizeInOut()` which calls `dyn_cast<hw::InOutType>(p.type)` on the empty type, triggering the assertion.\n\n### Suggested Fix\n\nAdd validation in `getModulePortInfo()` to check if `typeConverter.convertType()` returns a valid type:\n\n```cpp\nType portTy = typeConverter.convertType(port.type);\nif (!portTy) {\n  // Emit proper diagnostic error\n  return failure();\n}\n```\n\n## Environment\n\n- **CIRCT Version**: firtool-1.139.0 (LLVM 22.0.0git)\n- **OS**: Linux 5.15.0 (x86_64)\n\n## Cross-Tool Validation\n\n| Tool | Version | Status | Notes |\n|------|---------|--------|-------|\n| slang | 10.0.6+3d7e6cd2e | ✅ Pass | Build succeeded: 0 errors, 0 warnings |\n| verilator | 5.022 | ✅ Pass | No errors |\n| iverilog | - | ❌ Error | \"Port with type string is not supported\" (tool limitation, not syntax error) |\n\nThis confirms the test case is **syntactically valid** SystemVerilog per IEEE 1800-2017.\n","createdAt":"2026-02-01T03:00:12Z","labels":[],"number":9572,"state":"OPEN","title":"[Moore] Assertion failure when module has string type output port","url":"https://github.com/llvm/circt/issues/9572"},{"body":"Consider this input FIRRTL:\n```\nFIRRTL version 6.0.0\ncircuit Foo :\n  public module Foo :\n    skip\n  simulation GrayCodeExhaustive of GrayCodeExhaustive_1 :\n  module GrayCodeExhaustive_1 :\n    input clock : Clock\n    input init : UInt<1>\n    output done : UInt<1>\n    output success : UInt<1>\n\n    connect done, UInt<1>(0h1)\n    connect success, UInt<1>(0h1)\n```\nWhen run through `firtool`, this produces the following error:\n```\nerror: 'firrtl.simulation' op target @GrayCodeExhaustive_1 must have at least 4 ports, got 0 instead\n  simulation GrayCodeExhaustive of GrayCodeExhaustive_1 :\n             ^\nnote: target defined here\n  module GrayCodeExhaustive_1 :\n  ^\n```\nI think this is a bug in dead code / dead port elimination: if a module is targeted by a `firrtl.simulation` or a `firrtl.formal` declaration, we cannot change its port list, because those declarations rely on the module having specific ports.","createdAt":"2026-01-20T22:11:40Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":9482,"state":"OPEN","title":"[FIRRTL] Module ports get removed even when module is targeted by firrtl.simulation/firrtl.formal","url":"https://github.com/llvm/circt/issues/9482"},{"body":"## Description\n\nCIRCT crashes with assertion `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"` when compiling SystemVerilog modules that use packed union types as module ports.\n\n**Likely cause**: MooreToCore conversion pass lacks a type conversion rule for packed union types (`UnionType`). When processing module ports, the type converter fails to convert `UnionType`, resulting in an invalid/null type that causes assertion failures in downstream port processing code (`getModulePortInfo` at line 259).\n\n> **Validation**: Test case accepted by: verilator, iverilog, slang\n> **IEEE 1800-2005**: Packed unions are valid (Section 7.3)\n\n## Steps to Reproduce\n\n1. Save following code as `bug.sv`\n2. Run: `circt-verilog --ir-hw bug.sv`\n\n## Test Case\n\n```systemverilog\ntypedef union packed {\n  logic [31:0] a;\n  logic [31:0] b;\n} my_union;\n\nmodule Sub(input my_union in_val, output my_union out_val);\n  assign out_val = in_val;\nendmodule\n\nmodule Top;\n  my_union data_in, data_out;\n  \n  Sub s(.in_val(data_in), .out_val(data_out));\nendmodule\n```\n\n## Error Output\n\n```\n #4 0x00007f8176f898ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007f8176f89b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007f8176f89530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n```\n\n<details>\n<summary>Full Stack Trace</summary>\n\n```\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.      Program arguments: /opt/firtool/bin/circt-verilog --ir-hw bug.sv\n #0 0x00007f8172d678a8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x2008a8)\n #1 0x00007f8172d652f5 llvm::sys::RunSignalHandlers() (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x1fe2f5)\n #2 0x00007f8172d68631 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x00007f8172875330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #4 0x00007f8176f898ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007f8176f89b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007f8176f89530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n #7 0x00007f817529b438 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2a438)\n #8 0x00007f81752658ed void llvm::function_ref<void ()>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_0>(long) PatternApplicator.cpp:0:0\n #9 0x00007f8175262774 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/opt/firtool-1.139.0/bin/../lib/libMLIRRewrite.so+0x7774)\n#10 0x00007f817529cc6f (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*) DialectConversion.cpp:0:0\n#11 0x00007f817529c470 mlir::OperationConverter::convert(mlir::Operation*, bool) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2b470)\n#12 0x00007f817529cdae mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2bdae)\n#13 0x00007f81752aa8e4 void llvm::function_ref<void ()>::callback_fn<applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode)::$_0>(long) DialectConversion.cpp:0:0\n#14 0x00007f81752a1f7d applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode) DialectConversion.cpp:0:0\n#15 0x00007f81752a20fe mlir::applyFullConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x310fe)\n#16 0x00007f8176f5b231 (anonymous namespace)::MooreToCorePass::runOnOperation() MooreToCore.cpp:0:0\n#17 0x00007f81750572a5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x172a5)\n#18 0x00007f817505a7a9 mlir::PassManager::run(mlir::Operation*) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x1a7a9)\n#19 0x0000563df3daf5d0 executeWithSources(mlir::MLIRContext*, llvm::SourceMgr&) circt-verilog.cpp:0:0\n#20 0x0000563df3daadd5 execute(mlir::MLIRContext*) circt-verilog.cpp:0:0\n#21 0x0000563df3daa4b8 main (/opt/firtool/bin/circt-verilog+0x84b8)\n#22 0x00007f817285a1ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#23 0x00007f817285a28b call_init ./csu/../csu/libc-start.c:128:20\n#24 0x00007f817285a28b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#25 0x0000563df3da9b05 _start (/opt/firtool/bin/circt-verilog+0x7b05)\n[1]    1143009 segmentation fault (core dumped)  /opt/firtool/bin/circt-verilog --ir-hw bug.sv\n\n```\n\n</details>\n\n## Root Cause Analysis\n\n- **Dialect**: Moore\n- **Failing Pass**: MooreToCore\n\n### Hypotheses\n\n1. **Missing UnionType type conversion rule** (confidence: high)\n   - Evidence: [\"Test case uses 'typedef union packed' as module port type\", 'Stack trace shows crash in getModulePortInfo during port processing at line 259', \"Assertion message indicates 'dyn_cast<InOutType>' failed on non-existent value\", 'No conversion rule for UnionType exists in populateTypeConversion function (lines 2268-2409)', 'Similar types like StructType have conversion rules, but UnionType does not', 'Both UnionType and StructType implement DestructurableTypeInterface, suggesting they should be handled similarly']\n   - Mechanism: The typeConverter fails to convert UnionType when processing module ports, resulting in an invalid type that causes assertion failures\n\n2. **Type converter returns invalid non-null type** (confidence: medium)\n   - Evidence: [\"Line 245-248 checks 'if (!portTy)' and emits error\", 'However, crash still occurs, suggesting either the check is not being reached or the type is non-null but invalid', 'The assertion occurs in a different code path that may not be covered by the initial null check']\n   - Mechanism: The typeConverter may return a non-null type with incorrect MLIR type ID or metadata\n\n## Environment\n\n- **CIRCT Version**: LLVM (http://llvm.org/):\n  LLVM version 22.0.0git\n  Optimized build.\nCIRCT firtool-1.139.0\nslang version 9.1.0+0\n\n---\n**Labels**: bug, Moore","createdAt":"2026-02-01T02:15:22Z","labels":[],"number":9570,"state":"OPEN","title":"[Moore] Assertion in MooreToCore when module uses packed union type as port","url":"https://github.com/llvm/circt/issues/9570"},{"body":"Consider the following example, directly adapted from an existing `lower-domains.mlir` test:\n\n``` mlir\n firrtl.circuit \"Foo\" {\n  firrtl.domain @ClockDomain\n  firrtl.module private @ZeroWidthPort(\n    in %A: !firrtl.domain of @ClockDomain,\n    in %a: !firrtl.uint<0> domains [%A]\n  ) {\n  }\n  firrtl.module @Foo() {}\n}\n```\n\nCurrently, this will lower the `ZeroWidthPort` module to the following. This keeps the domain information, but it is intentionally empty because `LowerToHW` will strip zero-width ports.\n\n``` mlir\nfirrtl.module private @ZeroWidthPort(\n  in %A: !firrtl.class<@ClockDomain()>, \n  out %A_out: !firrtl.class<@ClockDomain_out(\n    in domainInfo_in: !firrtl.class<@ClockDomain()>, \n    out domainInfo_out: !firrtl.class<@ClockDomain()>, \n    in associations_in: !firrtl.list<path>, \n    out associations_out: !firrtl.list<path>\n  )>, \n  in %a: !firrtl.uint<0>\n) {\n      %A_object = firrtl.object @ClockDomain_out(in domainInfo_in: !firrtl.class<@ClockDomain()>, out domainInfo_out: !firrtl.class<@ClockDomain()>, in associations_in: !firrtl.list<path>, out associations_out: !firrtl.list<path>)\n      %0 = firrtl.object.subfield %A_object[domainInfo_in] : !firrtl.class<@ClockDomain_out(in domainInfo_in: !firrtl.class<@ClockDomain()>, out domainInfo_out: !firrtl.class<@ClockDomain()>, in associations_in: !firrtl.list<path>, out associations_out: !firrtl.list<path>)>\n      firrtl.propassign %0, %A : !firrtl.class<@ClockDomain()>\n      %1 = firrtl.object.subfield %A_object[associations_in] : !firrtl.class<@ClockDomain_out(in domainInfo_in: !firrtl.class<@ClockDomain()>, out domainInfo_out: !firrtl.class<@ClockDomain()>, in associations_in: !firrtl.list<path>, out associations_out: !firrtl.list<path>)>\n      %2 = firrtl.list.create  : !firrtl.list<path>\n      firrtl.propassign %1, %2 : !firrtl.list<path>\n      firrtl.propassign %A_out, %A_object : !firrtl.class<@ClockDomain_out(in domainInfo_in: !firrtl.class<@ClockDomain()>, out domainInfo_out: !firrtl.class<@ClockDomain()>, in associations_in: !firrtl.list<path>, out associations_out: !firrtl.list<path>)>\n    }\n```\n\nI've observed a handful of situations where there are private modules with lots of this going on, e.g., O(10) unused, inferred domains show up because there are lots of zero-width ports.\n\nIt would be better if truly unused domains could be stripped when they have no association information. This may motivate breaking the zero-width removal part of `LowerToHW` out to a pass that runs earlier in the FIRRTL to HW conversion pipeline.","createdAt":"2026-01-26T16:07:52Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIw","name":"enhancement","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":9516,"state":"OPEN","title":"[FIRRTL] Elide domains of zero-width ports in LowerDomains","url":"https://github.com/llvm/circt/issues/9516"},{"body":"**Test commit**\n[417a5112947d9889cad54cb5b2110b37978b86b8](https://github.com/llvm/circt/commit/417a5112947d9889cad54cb5b2110b37978b86b8)\n\n**Description**\nThe IR printer fails an assertion when an `hw.module.extern` has a `port_locs` attribute with a different number of elements than the actual ports defined in the module type.\n\n**Steps to reproduce**\n- Minimal MLIR program (test.mlir)\n```\n#loc = loc(\"test.mlir\":1:1)\n\"builtin.module\"() ({\n  \"hw.module.extern\"() <{\n    module_type = !hw.modty<>,\n    parameters = [],\n    port_locs = [#loc],\n    sym_name = \"ListModule\"\n  }> ({}) : () -> ()\n}) : () -> ()\n```\n\n**Command**\n```\ncirct-opt test.mlir\n```\n\n**Output**\n```\ncirct-opt: /workdir/sources/circt/lib/Dialect/HW/HWOps.cpp:1214: SmallVector<mlir::Location> getAllPortLocs(ModTy) [ModTy = circt::hw::HWModuleExternOp]: Assertion `!locs->size() || locs->size() == module.getNumPorts()' failed.\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.      Program arguments: /workdir/builds/circt/bin/circt-opt test.mlir\n #0 0x000056338509e94b backtrace (/workdir/builds/circt/bin/circt-opt+0x6f4e94b)\n #1 0x000056338522e747 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /workdir/sources/circt/llvm/llvm/lib/Support/Unix/Signals.inc:834:13\n #2 0x000056338522c373 llvm::sys::RunSignalHandlers() /workdir/sources/circt/llvm/llvm/lib/Support/Signals.cpp:105:18\n #3 0x000056338522f4b5 SignalHandler(int, siginfo_t*, void*) /workdir/sources/circt/llvm/llvm/lib/Support/Unix/Signals.inc:426:38\n #4 0x00007f22dadc9520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #5 0x00007f22dae1d9fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\n #6 0x00007f22dadc9476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\n #7 0x00007f22dadaf7f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\n #8 0x00007f22dadaf71b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\n #9 0x00007f22dadc0e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n#10 0x0000563387c24a0e mlir::Location::Location(mlir::LocationAttr) /workdir/sources/circt/llvm/mlir/include/mlir/IR/Location.h:79:5\n#11 0x0000563387c24a0e llvm::SmallVector<mlir::Location, 6u> getAllPortLocs<circt::hw::HWModuleExternOp>(circt::hw::HWModuleExternOp) /workdir/sources/circt/lib/Dialect/HW/HWOps.cpp:1218:32\n#12 0x0000563387c24a0e circt::hw::HWModuleExternOp::getAllPortLocs() /workdir/sources/circt/lib/Dialect/HW/HWOps.cpp:1246:10\n#13 0x0000563387b82885 circt::hw::detail::HWModuleLikeInterfaceTraits::Model<circt::hw::HWModuleExternOp>::getAllPortLocs(circt::hw::detail::HWModuleLikeInterfaceTraits::Concept const*, mlir::Operation*) /workdir/builds/circt/include/circt/Dialect/HW/HWOpInterfaces.h.inc:2530:3\n#14 0x0000563387bf89a4 circt::hw::HWModuleLike::getAllPortLocs() /workdir/builds/circt/include/circt/Dialect/HW/HWOpInterfaces.cpp.inc:285:7\n#15 0x0000563387e0ef84 llvm::ArrayRef<mlir::Location>::ArrayRef<llvm::SmallVector<mlir::Location, 6u>, void>(llvm::SmallVector<mlir::Location, 6u> const&) /workdir/sources/circt/llvm/llvm/include/llvm/ADT/ArrayRef.h:95:44\n#16 0x0000563387e0ef84 circt::hw::module_like_impl::printModuleSignatureNew(mlir::OpAsmPrinter&, circt::hw::HWModuleLike) /workdir/sources/circt/lib/Dialect/HW/ModuleImplementation.cpp:398:7\n#17 0x0000563387c1c583 void printModuleOp<circt::hw::HWModuleExternOp>(mlir::OpAsmPrinter&, circt::hw::HWModuleExternOp) /workdir/sources/circt/lib/Dialect/HW/HWOps.cpp:1051:3\n#18 0x0000563387c1c583 circt::hw::HWModuleExternOp::print(mlir::OpAsmPrinter&) /workdir/sources/circt/lib/Dialect/HW/HWOps.cpp:1071:49\n#19 0x0000563387b8636b mlir::Op<circt::hw::HWModuleExternOp, mlir::OpTrait::OneRegion, mlir::OpTrait::ZeroResults, mlir::OpTrait::ZeroSuccessors, mlir::OpTrait::ZeroOperands, mlir::OpTrait::HasParent<mlir::ModuleOp>::Impl, mlir::OpTrait::OpInvariants, mlir::BytecodeOpInterface::Trait, circt::hw::PortList::Trait, mlir::SymbolOpInterface::Trait, circt::igraph::ModuleOpInterface::Trait, circt::hw::HWModuleLike::Trait, circt::hw::HWMutableModuleLike::Trait, mlir::OpTrait::InnerSymbolTable, mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn()::'lambda'(mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef)::operator()(mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef) const /workdir/sources/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1966:9\n#20 0x0000563387b7e55d mlir::RegisteredOperationName::Model<circt::hw::HWModuleExternOp>::printAssembly(mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef) /workdir/sources/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:552:7\n#21 0x000056338b0c5a7d llvm::ilist_detail::node_base_prevnext<llvm::ilist_node_base<true, void>, true>::getNext() const /workdir/sources/circt/llvm/llvm/include/llvm/ADT/ilist_node_base.h:42:38\n#22 0x000056338b0c5a7d llvm::ilist_node_impl<llvm::ilist_detail::node_options<mlir::Operation, true, false, void, false, void> >::getNext() /workdir/sources/circt/llvm/llvm/include/llvm/ADT/ilist_node.h:108:59\n#23 0x000056338b0c5a7d llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void, false, void>, false, false>::operator++() /workdir/sources/circt/llvm/llvm/include/llvm/ADT/ilist_iterator.h:187:57\n#24 0x000056338b0c5a7d (anonymous namespace)::DummyAliasOperationPrinter::print(mlir::Block*, bool, bool) /workdir/sources/circt/llvm/mlir/lib/IR/AsmPrinter.cpp:765:24\n#25 0x000056338b0c3554 llvm::ilist_detail::node_base_prevnext<llvm::ilist_node_base<true, void>, true>::getNext() const /workdir/sources/circt/llvm/llvm/include/llvm/ADT/ilist_node_base.h:42:38\n#26 0x000056338b0c3554 llvm::ilist_node_impl<llvm::ilist_detail::node_options<mlir::Block, true, false, void, false, void> >::getNext() /workdir/sources/circt/llvm/llvm/include/llvm/ADT/ilist_node.h:108:59\n#27 0x000056338b0c3554 llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Block, true, false, void, false, void>, false, false>::operator++() /workdir/sources/circt/llvm/llvm/include/llvm/ADT/ilist_iterator.h:187:57\n#28 0x000056338b0c3554 llvm::simple_ilist<mlir::Block>::begin() /workdir/sources/circt/llvm/llvm/include/llvm/ADT/simple_ilist.h:118:29\n#29 0x000056338b0c3554 mlir::Region::begin() /workdir/sources/circt/llvm/mlir/include/mlir/IR/Region.h:55:36\n#30 0x000056338b0c3554 decltype(fp.begin()) std::begin<mlir::Region>(mlir::Region&) /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/range_access.h:52:21\n#31 0x000056338b0c3554 decltype(begin(std::forward<mlir::Region&>(fp))) llvm::adl_detail::begin_impl<mlir::Region&>(mlir::Region&) /workdir/sources/circt/llvm/llvm/include/llvm/ADT/ADL.h:29:10\n#32 0x000056338b0c3554 decltype(adl_detail::begin_impl(std::forward<mlir::Region&>(fp))) llvm::adl_begin<mlir::Region&>(mlir::Region&) /workdir/sources/circt/llvm/llvm/include/llvm/ADT/ADL.h:80:10\n#33 0x000056338b0c3554 auto llvm::drop_begin<mlir::Region&>(mlir::Region&, unsigned long) /workdir/sources/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:317:31\n#34 0x000056338b0c3554 (anonymous namespace)::DummyAliasOperationPrinter::printRegion(mlir::Region&, bool, bool, bool) /workdir/sources/circt/llvm/mlir/lib/IR/AsmPrinter.cpp:782:21\n#35 0x000056338b1167bc llvm::SmallVectorTemplateCommon<llvm::StringRef, void>::isSmall() const /workdir/sources/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:145:39\n#36 0x000056338b1167bc llvm::SmallVectorImpl<llvm::StringRef>::~SmallVectorImpl() /workdir/sources/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:604:16\n#37 0x000056338b1167bc llvm::SmallVector<llvm::StringRef, 2u>::~SmallVector() /workdir/sources/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:1210:3\n#38 0x000056338b1167bc mlir::ModuleOp::print(mlir::OpAsmPrinter&) /workdir/builds/llvm_for_circt/tools/mlir/include/mlir/IR/BuiltinOps.cpp.inc:325:1\n#39 0x000056338b119756 void llvm::detail::UniqueFunctionBase<void, mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef>::CallImpl<mlir::Op<mlir::ModuleOp, mlir::OpTrait::OneRegion, mlir::OpTrait::ZeroResults, mlir::OpTrait::ZeroSuccessors, mlir::OpTrait::ZeroOperands, mlir::OpTrait::NoRegionArguments, mlir::OpTrait::NoTerminator, mlir::OpTrait::SingleBlock, mlir::OpTrait::OpInvariants, mlir::BytecodeOpInterface::Trait, mlir::OpTrait::AffineScope, mlir::OpTrait::IsIsolatedFromAbove, mlir::OpTrait::SymbolTable, mlir::SymbolOpInterface::Trait, mlir::OpAsmOpInterface::Trait, mlir::RegionKindInterface::Trait, mlir::OpTrait::HasOnlyGraphRegion>::getPrintAssemblyFn()::'lambda'(mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef) const>(void*, mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef) /workdir/sources/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:213:3\n#40 0x000056338b117de5 llvm::detail::PunnedPointer<llvm::PointerUnion<llvm::detail::UniqueFunctionBase<void, mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef>::TrivialCallback*, llvm::detail::UniqueFunctionBase<void, mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef>::NonTrivialCallbacks*> >::asInt() const /workdir/sources/circt/llvm/llvm/include/llvm/ADT/PointerIntPair.h:41:5\n#41 0x000056338b117de5 llvm::detail::PunnedPointer<llvm::PointerUnion<llvm::detail::UniqueFunctionBase<void, mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef>::TrivialCallback*, llvm::detail::UniqueFunctionBase<void, mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef>::NonTrivialCallbacks*> >::operator long() const /workdir/sources/circt/llvm/llvm/include/llvm/ADT/PointerIntPair.h:45:48\n#42 0x000056338b117de5 llvm::PointerIntPair<llvm::PointerUnion<llvm::detail::UniqueFunctionBase<void, mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef>::TrivialCallback*, llvm::detail::UniqueFunctionBase<void, mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef>::NonTrivialCallbacks*>, 1u, bool, llvm::PointerLikeTypeTraits<llvm::PointerUnion<llvm::detail::UniqueFunctionBase<void, mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef>::TrivialCallback*, llvm::detail::UniqueFunctionBase<void, mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef>::NonTrivialCallbacks*> >, llvm::PointerIntPairInfo<llvm::PointerUnion<llvm::detail::UniqueFunctionBase<void, mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef>::TrivialCallback*, llvm::detail::UniqueFunctionBase<void, mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef>::NonTrivialCallbacks*>, 1u, llvm::PointerLikeTypeTraits<llvm::PointerUnion<llvm::detail::UniqueFunctionBase<void, mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef>::TrivialCallback*, llvm::detail::UniqueFunctionBase<void, mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef>::NonTrivialCallbacks*> > > >::getPointer() const /workdir/sources/circt/llvm/llvm/include/llvm/ADT/PointerIntPair.h:94:58\n#43 0x000056338b117de5 llvm::detail::UniqueFunctionBase<void, mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef>::~UniqueFunctionBase() /workdir/sources/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:274:32\n#44 0x000056338b117de5 mlir::RegisteredOperationName::Model<mlir::ModuleOp>::printAssembly(mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef) /workdir/sources/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:552:7\n#45 0x000056338b0bc58e mlir::OperationName::printAssembly(mlir::Operation*, mlir::OpAsmPrinter&, llvm::StringRef) const /workdir/sources/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:0:23\n#46 0x000056338b0bc58e (anonymous namespace)::DummyAliasOperationPrinter::printCustomOrGenericOp(mlir::Operation*) /workdir/sources/circt/llvm/mlir/lib/IR/AsmPrinter.cpp:710:21\n#47 0x000056338b0bc58e (anonymous namespace)::AliasInitializer::initialize(mlir::Operation*, mlir::OpPrintingFlags const&, llvm::MapVector<void const*, (anonymous namespace)::SymbolAlias, llvm::DenseMap<void const*, unsigned int, llvm::DenseMapInfo<void const*, void>, llvm::detail::DenseMapPair<void const*, unsigned int> >, llvm::SmallVector<std::pair<void const*, (anonymous namespace)::SymbolAlias>, 0u> >&) /workdir/sources/circt/llvm/mlir/lib/IR/AsmPrinter.cpp:1146:16\n#48 0x000056338b0bc58e (anonymous namespace)::AliasState::initialize(mlir::Operation*, mlir::OpPrintingFlags const&, mlir::DialectInterfaceCollection<mlir::OpAsmDialectInterface>&) /workdir/sources/circt/llvm/mlir/lib/IR/AsmPrinter.cpp:1293:15\n#49 0x000056338b0bc58e mlir::detail::AsmStateImpl::initializeAliases(mlir::Operation*) /workdir/sources/circt/llvm/mlir/lib/IR/AsmPrinter.cpp:1956:16\n#50 0x000056338b0bb332 mlir::Operation::print(llvm::raw_ostream&, mlir::AsmState&) /workdir/sources/circt/llvm/mlir/lib/IR/AsmPrinter.cpp:0:21\n#51 0x000056338b67e88b llvm::raw_ostream::operator<<(char) /workdir/sources/circt/llvm/llvm/include/llvm/Support/raw_ostream.h:205:9\n#52 0x000056338b67e88b performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) /workdir/sources/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:618:41\n#53 0x000056338b67d4ae processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::MemoryBufferRef, mlir::MlirOptMainConfig const&, mlir::DialectRegistry&, mlir::SourceMgrDiagnosticVerifierHandler*, llvm::ThreadPoolInterface*) /workdir/sources/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:673:12\n#54 0x000056338b67d4ae mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_3::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::MemoryBufferRef, llvm::raw_ostream&) const /workdir/sources/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:771:12\n#55 0x000056338b67d4ae llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::MemoryBufferRef const&, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_3>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::MemoryBufferRef const&, llvm::raw_ostream&) /workdir/sources/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:46:12\n#56 0x000056338b6a677b llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::MemoryBufferRef const&, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::MemoryBufferRef const&, llvm::raw_ostream&) const /workdir/sources/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:69:12\n#57 0x000056338b6a677b mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::MemoryBufferRef const&, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) /workdir/sources/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:30:12\n#58 0x000056338b674d52 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) /workdir/sources/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:776:26\n#59 0x000056338b675089 mlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) /workdir/sources/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:822:14\n#60 0x000056338b6752cd mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) /workdir/sources/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:838:10\n#61 0x00005633851245f3 llvm::failed(llvm::LogicalResult) /workdir/sources/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:71:42\n#62 0x00005633851245f3 main /workdir/sources/circt/tools/circt-opt/circt-opt.cpp:86:10\n#63 0x00007f22dadb0d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\n#64 0x00007f22dadb0e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\n#65 0x0000563385062e15 _start (/workdir/builds/circt/bin/circt-opt+0x6f12e15)\nAborted (core dumped)\n```\n","createdAt":"2025-12-19T14:37:27Z","labels":[],"number":9368,"state":"OPEN","title":"Assertion failure when printing external modules with mismatched port locations","url":"https://github.com/llvm/circt/issues/9368"},{"body":"Consider the following:\n\n``` mlir\nfirrtl.circuit \"Foo\" {\n  firrtl.module private @Bar(\n    out %ref: !firrtl.probe<clock>\n  ) {\n  }\n  firrtl.module @Foo() {\n    %Bar_ref = firrtl.instance Bar @Bar(\n      out ref: !firrtl.probe<clock>\n    )\n  }\n}\n```\n\nThis will crash if run with:\n\n``` console\n# circt-reduce -skip-initial -test='exit 0' firrtl-remove-unused-ports.1.mlir -include firrtl-remove-unused-ports -o /dev/null\nReading input\nTesting input with `exit 0`\nInitial module has size 221\nTrying reduction `firrtl-remove-unused-ports`\nAssertion failed: (isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"), function cast, file Casting.h, line 560.\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: circt-reduce -skip-initial \"-test=exit 0\" firrtl-remove-unused-ports.1.mlir -include firrtl-remove-unused-ports -o /dev/null\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\n0  circt-reduce             0x0000000102367c34 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 56\n1  circt-reduce             0x0000000102365b1c llvm::sys::RunSignalHandlers() + 172\n2  circt-reduce             0x00000001023686dc SignalHandler(int, __siginfo*, void*) + 300\n3  libsystem_platform.dylib 0x000000018fd516a4 _sigtramp + 56\n4  libsystem_pthread.dylib  0x000000018fd17848 pthread_kill + 296\n5  libsystem_c.dylib        0x000000018fc209e4 abort + 124\n6  libsystem_c.dylib        0x000000018fc1fc18 err + 0\n7  circt-reduce             0x00000001034bbc2c llvm::StdThreadPool::wait() (.cold.1) + 0\n8  circt-reduce             0x000000010269e0d8 circt::firrtl::patterns::AddOfPad::~AddOfPad() + 0\n9  circt-reduce             0x000000010282e020 (anonymous namespace)::RemoveUnusedPortsPass::runOnOperation() + 3056\n10 circt-reduce             0x0000000103475108 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 1340\n11 circt-reduce             0x0000000103475a04 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 620\n12 circt-reduce             0x0000000103477b68 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) + 5408\n13 circt-reduce             0x00000001034754f0 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 2340\n14 circt-reduce             0x0000000103475a04 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 620\n15 circt-reduce             0x000000010347b3ec mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) + 464\n16 circt-reduce             0x000000010347abf0 mlir::PassManager::run(mlir::Operation*) + 5292\n17 circt-reduce             0x00000001022f30dc execute(mlir::MLIRContext&) + 3988\n18 circt-reduce             0x00000001022f1ebc main + 300\n19 dyld                     0x000000018f976b98 start + 6076\nzsh: abort      circt-reduce -skip-initial -test='exit 0' firrtl-remove-unused-ports.1.mlir \n```","createdAt":"2026-01-31T16:49:07Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"},{"id":"LA_kwDODpuCgs8AAAABAHHhZQ","name":"Reducer","description":"Related to `circt-reduce`","color":"C5DEF5"}],"number":9564,"state":"OPEN","title":"[FIRRTL][circt-reduce] firrtl-remove-unused-ports can't handle probes","url":"https://github.com/llvm/circt/issues/9564"},{"body":"Consider the following circuit:\n\n``` firrtl\nFIRRTL version 6.0.0\ncircuit Foo: %[[\n  {\n    \"class\": \"circt.FullResetAnnotation\",\n    \"target\": \"~|Foo>reset\",\n    \"resetType\": \"async\"\n  }\n]]\n\n  module Baz:\n    inst bar of Bar\n\n  module Bar:\n\n  public module Foo:\n    input reset: AsyncReset\n\n    inst bar of Bar\n```\n\nWhen compiled with `firtool Foo.fir -mlir-print-ir-after-failure`, this will error out because this creates a port on `Bar`, but doesn't update all instances of `Bar`. See commentary later as I think there are actual problems with `FullResetAnnotation` here:\n\n```\ncirct/async-reset-full-multi-top.fir:11:5: error: 'firrtl.instance' op has a wrong number of results; expected 1 but got 0\n    inst bar of Bar\n    ^\ncirct/async-reset-full-multi-top.fir:11:5: note: see current operation: \"firrtl.instance\"() <{annotations = [], domainInfo = [], layers = [], moduleName = @Bar, name = \"bar\", nameKind = #firrtl<name_kind droppable_name>, portAnnotations = [], portDirections = array<i1>, portNames = []}> : () -> ()\ncirct/async-reset-full-multi-top.fir:13:3: note: original module declared here\n  module Bar:\n  ^\n```\n\nMLIR dump:\n\n``` mlir\n\"firrtl.circuit\"() <{annotations = [], name = \"Foo\"}> ({\n  \"firrtl.module\"() <{\n    annotations = [],\n    convention = #firrtl<convention internal>,\n    domainInfo = [],\n    layers = [],\n    portAnnotations = [],\n    portDirections = array<i1>,\n    portLocations = [],\n    portNames = [],\n    portSymbols = [],\n    portTypes = [],\n    sym_name = \"Baz\"\n  }> ({\n    \"firrtl.instance\"() <{\n      annotations = [],\n      domainInfo = [],\n      layers = [],\n      moduleName = @Bar,\n      name = \"bar\",\n      nameKind = #firrtl<name_kind droppable_name>,\n      portAnnotations = [],\n      portDirections = array<i1>,\n      portNames = []\n    }> : () -> ()\n  }) {sym_visibility = \"private\"} : () -> ()\n  \"firrtl.module\"() <{\n    annotations = [{class = \"circt.FullResetAnnotation\"}],\n    convention = #firrtl<convention internal>,\n    domainInfo = [],\n    layers = [],\n    portAnnotations = [],\n    portDirections = array<i1: false>,\n    portLocations = [loc(\"circt/async-reset-full-multi-top.fir\":16:11)],\n    portNames = [\"reset\"],\n    portSymbols = [],\n    portTypes = [!firrtl.asyncreset],\n    sym_name = \"Bar\"\n  }> ({\n  ^bb0(%arg1: !firrtl.asyncreset):\n  }) {sym_visibility = \"private\"} : () -> ()\n  \"firrtl.module\"() <{\n    annotations = [{class = \"circt.FullResetAnnotation\"}],\n    convention = #firrtl<convention scalarized>,\n    domainInfo = [[]],\n    layers = [],\n    portAnnotations = [[{class = \"circt.FullResetAnnotation\",\n    resetType = \"async\"}]],\n    portDirections = array<i1: false>,\n    portLocations = [loc(\"circt/async-reset-full-multi-top.fir\":16:11)],\n    portNames = [\"reset\"],\n    portSymbols = [],\n    portTypes = [!firrtl.asyncreset],\n    sym_name = \"Foo\"\n  }> ({\n  ^bb0(%arg0: !firrtl.asyncreset):\n    %0 = \"firrtl.instance\"() <{\n      annotations = [],\n      domainInfo = [[]],\n      layers = [],\n      moduleName = @Bar,\n      name = \"bar\",\n      nameKind = #firrtl<name_kind droppable_name>,\n      portAnnotations = [[]],\n      portDirections = array<i1: false>,\n      portNames = [\"reset\"]\n    }> : () -> !firrtl.asyncreset\n    \"firrtl.matchingconnect\"(%0, %arg0) : (!firrtl.asyncreset, !firrtl.asyncreset) -> ()\n  }) : () -> ()\n}) : () -> ()\n```\n\nThe fundamental problem is that `FullResetAnnotation` is a \"point-to-point\" connection request. It's saying \"Hook up this port to all the registers that don't have a reset under me.\" This has to create ports to do this. However, it assumes that this port can be connected to all of these registers. In the multi-top case, e.g., above where `Bar` is instantiated under `Foo` and `Bar`, it is completely ambiguous as to what should happen here. Specifically, it's unclear how the added port should be driven from an instantiation site that isn't reachable by the requested port.\n\nPragmatically, there are a couple of things that can help here, but don't address the fundamental problem:\n\n1. Modify the `InferResets` pass to not create ports for modules which don't _need_ the port. I.e., for modules which have no reset-less registers underneath them (in their body or in any body of a module they instantiate).\n2. The `InferResets` pass shouldn't create invalid IR. This needs to update instances to add the port, even if it doesn't know what to do with it, other than leaving it unconnected. The phase ordering of `InferResets` before `ExpandWhens` will catch this. (Relying on the phase ordering is dangerous, though...)\n3. The other instantiations can create the port on all instances and then tie it to zero. I don't exactly like this, but it's about the only sane thing to do here. A register with a reset tied to zero is the same as a register without a reset in simulation (and we already do this optimization when we see it).\n\nNote: the same problem does exist when there is a register. I.e., the problem here can't just be ignored with a solution to (1):\n\n``` firrtl\nFIRRTL version 6.0.0\ncircuit Foo: %[[\n  {\n    \"class\": \"circt.FullResetAnnotation\",\n    \"target\": \"~|Foo>reset\",\n    \"resetType\": \"async\"\n  }\n]]\n\n  module Baz:\n    input clock: Clock\n\n    inst bar of Bar\n    connect bar.clock, clock\n\n  module Bar:\n    input clock: Clock\n\n    reg r: UInt<1>, clock\n\n  public module Foo:\n    input clock: Clock\n    input reset: AsyncReset\n\n    inst bar of Bar\n    connect bar.clock, clock\n```","createdAt":"2025-12-30T18:54:03Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":9396,"state":"OPEN","title":"[FIRRTL] FullResetAnnotation breaks multi-top","url":"https://github.com/llvm/circt/issues/9396"},{"body":"Consider the following domain inference problem:\n\n``` firrtl\nFIRRTL version 6.0.0\n\ncircuit Foo:\n\n  domain ClockDomain:\n\n  module Bar:\n    output a: UInt<1>\n\n    wire b : UInt<1>\n    connect a, b\n\n  module Baz:\n    input a: UInt<1>\n\n  public module Foo:\n\n    inst bar of Bar\n    inst baz of Baz\n\n    connect baz.a, bar.a\n```\n\nWith the current domain inference pass in https://github.com/llvm/circt/pull/9106, this presently fails with the following error:\n\n```\nFoo.fir:18:5: error: unable to infer value for undriven domain port \"ClockDomain\"\n    inst bar of Bar\n    ^\nFoo.fir:18:5: note: associated with hardware port \"a\"\n```\n","createdAt":"2025-11-26T04:23:34Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":9268,"state":"OPEN","title":"[FIRRTL] Domain Inference U-turn Issue","url":"https://github.com/llvm/circt/issues/9268"},{"body":"A long time ago, HW module op would store its inputs and outputs using a function type.  This lacked the ability to intermix input and output ports the way verilog allows, and so we overhauled the system.  We added a `ModuleType` which holds an array of all ports, storing the name, type, and direction of each.  It seems that different parts of our code have not been updated properly with the new system.\r\n\r\n---\r\nIn the HWModuleOpInterface, the `setInputNames` makes an assumption that the port names of inputs are stored before all outputs.  When you update the input port names, it will replace replace all the existing input port names, but then effectively partially sort by port direction before commiting the names.\r\n\r\nhttps://github.com/llvm/circt/blob/a3e993cb387a08e686b0df1d7f5b599bca0b3751/include/circt/Dialect/HW/HWOpInterfaces.td#L135-L140\r\n\r\nThis issue can be found in `setInputNames`, `setOutputNames`, `setAllInputAttrs`, `setAllOutputAttrs`, `setInputLocs`, `setOutputLocs`.\r\n\r\n---\r\n\r\n`modifyModuleArgs` is used to insert and delete ports from modules.  Due to historical reasons, it treats input and output ports differently.  I believe that this function will successfully modify the input and output ports as requested, but then follow up by sorting them by direction.  I don't think this is on purpose, and would argue it would make sense to retain the original port order. I.e. the input and output indices should be changed in to a global port index.  An ever better API here would be to change this function so that it used a single list of port modifications for both inputs and outputs.\r\n\r\nhttps://github.com/llvm/circt/blob/a3e993cb387a08e686b0df1d7f5b599bca0b3751/lib/Dialect/HW/HWOps.cpp#L582\r\n\r\n---\r\nHWInstanceOp `getPortIdForInputId` and `getPortIdForOutputId` are wrong, and ~should just forward the question to the ModuleType~ the InstanceOp does not have enough information to properly implement these methods as is.\r\n\r\nhttps://github.com/llvm/circt/blob/a3e993cb387a08e686b0df1d7f5b599bca0b3751/include/circt/Dialect/HW/HWStructure.td#L458-L462\r\n\r\n\r\nhttps://github.com/llvm/circt/blob/a3e993cb387a08e686b0df1d7f5b599bca0b3751/lib/Dialect/HW/HWTypes.cpp#L825\r\n\r\n---\r\nThis is not a bug, but this code could be faster.  Using `getPortIdForInputId` and `getPortIdForOutputId` involves a serial walk through all ports.  It would be faster to just walk all ports, filtering out the unneeded directions. Same issue in `getInputLocs`, `getInputLocsAttr`, `getOutputLocs`, `getOutputLocsAttr`.\r\n\r\nhttps://github.com/llvm/circt/blob/a3e993cb387a08e686b0df1d7f5b599bca0b3751/include/circt/Dialect/HW/HWOpInterfaces.td#L178-L200\r\n\r\n---\r\n\r\nAudit the use of `HWMutableModuleLike`.  Is it still needed, and can the functionality be collapsed in to the regular `HWModuleLike`?\r\n\r\n`appendOutputs` should probably be implemented the way other methods are in this file, i.e. by lightly wrapping `modifyPorts`.  It does not look like its implemented properly for all module types as is: \r\n```\r\nvoid HWModuleExternOp::appendOutputs(\r\n    ArrayRef<std::pair<StringAttr, Value>> outputs) {}\r\n\r\nvoid HWModuleGeneratedOp::appendOutputs(\r\n    ArrayRef<std::pair<StringAttr, Value>> outputs) {}\r\n```","createdAt":"2024-02-15T17:47:21Z","labels":[{"id":"MDU6TGFiZWwyMTUyNzU0NzU0","name":"HW","description":"Involving the `hw` dialect","color":"081f7a"}],"number":6706,"state":"OPEN","title":"[HW] Module port accessors and modifiers bugs","url":"https://github.com/llvm/circt/issues/6706"},{"body":"```firrtl\r\nFIRRTL version 4.0.0\r\ncircuit Foo: %[[\r\n  {\"class\":\"sifive.enterprise.firrtl.FullAsyncResetAnnotation\", \"target\":\"~Foo|Foo>r\"}\r\n]]\r\n  public module Foo:\r\n    input c : Clock\r\n    input i : UInt<8>\r\n    input r : AsyncReset\r\n    output o : UInt<8>\r\n\r\n    inst bar of Bar\r\n    connect bar.c, c\r\n    connect bar.i, i\r\n    connect o, bar.o\r\n\r\n  public module Bar:\r\n    input c : Clock\r\n    input i : UInt<8>\r\n    output o : UInt<8>\r\n    reg r : UInt<8>, c\r\n    connect r, i\r\n    connect o, r\r\n```\r\nthrough `firtool` yields:\r\n```verilog\r\nmodule Bar(\r\n  input        r,\r\n               c,\r\n  input  [7:0] i,\r\n  output [7:0] o\r\n);\r\n```\r\n\r\nWe have modified the ports of Bar by adding `r`, changing its public interface.  I expect that boring the reset signal would not modify the public module interface, but I do not know exactly what should happen.  Possibly we cut the reset domain boundary at public modules, or maybe we clone `Bar` into a private module with the added port, and instantiate that instead under `Foo`.","createdAt":"2024-07-03T00:55:20Z","labels":[{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":7276,"state":"OPEN","title":"[FIRRTL] FART: Should not modify public module ports","url":"https://github.com/llvm/circt/issues/7276"},{"body":"For certain designs within a separable compilation unit (without a fixed port-level interface), it can be beneficial to \"simplify\" the connections between them by removing ports when possible. I think this can be pretty easily handled by allowing for any \"U-turn\" connections to be removed.  \r\n\r\nE.g., consider the following. This is conceptually doing `qux.a <= baz.a`. However, it is being done in a roundabout way.\r\n\r\n```\r\ncircuit Foo:\r\n  extmodule Baz:\r\n    output a: UInt<1>\r\n\r\n  extmodule Qux:\r\n    input a: UInt<1>\r\n\r\n  module Bar:\r\n    output baz_a: UInt<1>\r\n    input qux_a: UInt<1>\r\n\r\n    inst baz of Baz\r\n    inst qux of Qux\r\n    baz_a <= baz.a\r\n    qux.a <= qux_a\r\n\r\n  module Foo:\r\n\r\n    inst bar of Bar\r\n    bar.qux_a <= bar.baz_a\r\n```\r\n\r\nCIRCT currently preserves the port-level interface to produce:\r\n\r\n```verilog\r\n// external module Baz\r\n\r\n// external module Qux\r\n\r\nmodule Bar(\r\n  input  qux_a,\r\n  output baz_a\r\n);\r\n\r\n  Baz baz (\r\n    .a (baz_a)\r\n  );\r\n  Qux qux (\r\n    .a (qux_a)\r\n  );\r\nendmodule\r\n\r\nmodule Foo();\r\n  wire _bar_baz_a;\r\n  Bar bar (\r\n    .qux_a (_bar_baz_a),\r\n    .baz_a (_bar_baz_a)\r\n  );\r\nendmodule\r\n```\r\n\r\nHowever, this could be simplified to:\r\n\r\n```verilog\r\n// external module Baz\r\n\r\n// external module Qux\r\n\r\nmodule Bar();\r\n  wire x;\r\n  Baz baz (\r\n    .a (x)\r\n  );\r\n  Qux qux (\r\n    .a (x)\r\n  );\r\nendmodule\r\n\r\nmodule Foo();\r\n  Bar bar ();\r\nendmodule\r\n```\r\n\r\nRoughly the cost model is \"a port costs 1 unit\" and no port is free. There is a similar approach that can be taken to convert real ports to ref type ports.\r\n\r\nThis may be beneficial to have on HW as opposed to just on FIRRTL.\r\n\r\nThis approach has problems because it fundamentally destroys design intent. It's also sketchy to rely on this for anything other than optimization within a hierarchy whose internals you do not care about.","createdAt":"2023-02-07T23:30:47Z","labels":[],"number":4638,"state":"OPEN","title":"[FIRRTL][HW?] Port Simplification Pass","url":"https://github.com/llvm/circt/issues/4638"},{"body":"`module(input : bundle<all flips>` should be transformed to `module(output : bundle<non-flipped>`","createdAt":"2023-11-28T16:04:54Z","labels":[],"number":6457,"state":"OPEN","title":"[FIRRTL] port bundle flip fixups","url":"https://github.com/llvm/circt/issues/6457"},{"body":"Currently, there's no way to verify the legality of `firrtl.domain.define` when a `WireOp` is involved. E.g., the following is trivially an error after domain inference, but there is no way to actually enshrine the legality/illegality in the IR:\n\n``` mlir\nfirrtl.circuit \"Foo\" {\n  firrtl.domain @ClockDomain\n  firrtl.domain @PowerDomain\n  firrtl.module @Foo(\n    in %in: !firrtl.domain of @ClockDomain,\n    out %out: !firrtl.domain of @PowerDomain\n  ) {\n    %w = firrtl.wire : !firrtl.domain // We don't have syntax or storage to mark the domain that %w is in.\n    firrtl.domain.define %w, %in\n    firrtl.domain.define %out, %w\n  }\n}\n```\n\nModify FIRRTL's `WireOp` to include optional domain information, i.e., a `DominInfoAttr`. Update passes to support this.","createdAt":"2025-12-30T22:22:59Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIw","name":"enhancement","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":9398,"state":"OPEN","title":"[FIRRTL] Add Domain Info to WireOp","url":"https://github.com/llvm/circt/issues/9398"},{"body":"Consider following IR (this kind of IR is frequently used to express FIRRTL's inout ports):\r\n```mlir\r\nhw.module @Foo(%x: i8) -> (y: i8, z: i8) {\r\n    %.z.output = sv.wire : !hw.inout<i8>\r\n    %0 = sv.read_inout %.z.output : !hw.inout<i8>\r\n    sv.assign %.z.output, %x : i8\r\n    hw.output %0, %0 : i8, i8\r\n }\r\n```\r\n`circt-opt -export-verilog`:\r\n```verilog\r\nmodule Foo(\t// foo.mlir:1:1\r\n  input  [7:0] x,\r\n  output [7:0] y,\r\n               z);\r\n\r\n  wire [7:0] _z_output;\t// foo.mlir:2:18\r\n\r\n  assign _z_output = x;\t// foo.mlir:4:5\r\n  assign y = _z_output;\t// foo.mlir:3:10, :5:5\r\n  assign z = _z_output;\t// foo.mlir:3:10, :5:5\r\nendmodule\r\n```\r\n\r\nIdeally we don't have to create temporary wires for output ports, e.g:\r\n```verilog\r\nmodule Foo(\t// foo.mlir:1:1\r\n  input  [7:0] x,\r\n  output [7:0] y,\r\n               z);\r\n\r\n  assign z = x;\t// foo.mlir:4:5\r\n  assign y = x;\t// foo.mlir:3:10, :5:5\r\nendmodule","createdAt":"2022-05-16T13:39:50Z","labels":[],"number":3133,"state":"OPEN","title":"[ExportVerilog] Reuse output ports if possible","url":"https://github.com/llvm/circt/issues/3133"},{"body":"When designing an arbiter (something which accepts N channels and muxes them into one), it'd be ideal to support lowering the following:\r\n\r\n```\r\nhw.module @Arb (%inputs: !hw.array<4 x !esi.channel<i32>>) -> ()\r\n```\r\n\r\nto something like:\r\n\r\n```\r\nhw.module @Arb (%inputs: !hw.array<4 x i32>, %inputs_valids: !hw.array<4 x i1>) -> (%inputs_readys: !hw.array<4 x i1>)\r\n```","createdAt":"2023-05-05T20:53:10Z","labels":[{"id":"MDU6TGFiZWwyNzY3ODUyMDMx","name":"ESI","description":"","color":"91D9EF"}],"number":5143,"state":"OPEN","title":"[ESI] Lower ports with arrays of channels","url":"https://github.com/llvm/circt/issues/5143"},{"body":"```mlir\n  hw.module @aiger_top(in %a5B05D \"\\\\a[0]\" : i1, in %a5B15D \"\\\\a[1]\" : i1, in %b5B05D \"\\\\b[0]\" : i1, in %b5B15D \"\\\\b[1]\" : i1, out \"\\\\c[0]\" : i1, out \"\\\\c[1]\" : i1) {\n    %true = hw.constant true\n    %0 = comb.xor bin %b5B15D, %true : i1\n    %1 = comb.xor bin %a5B15D, %true : i1\n    %2 = comb.and bin %0, %1 : i1\n    %true_0 = hw.constant true\n    %3 = comb.xor bin %b5B05D, %true_0 : i1\n    %4 = comb.xor bin %a5B05D, %true_0 : i1\n    %5 = comb.and bin %3, %4 : i1\n    hw.output %2, %5 : i1, i1\n  } \n```\n\n`$circt-opt -export-verilog %s` \n```verilog\nmodule aiger_top(       // bar.mlir:1:3\n  input  _5Ca5B05D,     // bar.mlir:1:27\n         _5Ca5B15D,     // bar.mlir:1:53\n         _5Cb5B05D,     // bar.mlir:1:79\n         _5Cb5B15D,     // bar.mlir:1:105\n  output _5Cc5B05D,     // bar.mlir:1:132\n         _5Cc5B15D      // bar.mlir:1:151\n);\n\n  wire _GEN = ~_5Cb5B15D & ~_5Ca5B15D;  // bar.mlir:3:10, :4:10, :5:10\n  assign _5Cc5B05D = _GEN;      // bar.mlir:5:10, :10:5\n  assign _5Cc5B15D = _GEN;      // bar.mlir:5:10, :10:5\nendmodule\n```\n\nIt's nice if we don't have to legalize `\\a[0]`. https://github.com/llvm/circt/commit/eef60c8a4998ad60f6bf7834dbc6b3065f1b5e3e handles instance/module names but not for signals. ","createdAt":"2025-06-14T22:00:33Z","labels":[],"number":8566,"state":"OPEN","title":"[ExportVerilog] Allow escaped names for ports and variables etc","url":"https://github.com/llvm/circt/issues/8566"},{"body":"FIRRTL's `LoweXMR` pass will currently produce invalid IR if it is given a module which has duplicate port names.\r\n\r\n```mlir\r\nfirrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [\"a\", \"a\"]} {\r\n    %b = firrtl.wire interesting_name : !firrtl.uint<1>\r\n    %0 = firrtl.ref.send %b : !firrtl.uint<1>\r\n    firrtl.ref.define %a, %0 : !firrtl.probe<uint<1>>\r\n    %1 = firrtl.ref.send %b : !firrtl.uint<1>\r\n    firrtl.ref.define %a0, %1 : !firrtl.probe<uint<1>>\r\n  }\r\n}\r\n```\r\n\r\nThis produces:\r\n\r\n```\r\n# circt-opt Foo.mlir -firrtl-lower-xmr                                   \r\nfirrtl-snippets/issues/x.mlir:3:5: error: redefinition of symbol named 'ref_Foo_Foo_a'\r\n    firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [\"a\", \"a\"]} {\r\n    ^\r\nfirrtl-snippets/issues/x.mlir:3:5: note: see current operation: \"sv.macro.decl\"() {sym_name = \"ref_Foo_Foo_a\"} : () -> ()\r\nfirrtl-snippets/issues/x.mlir:3:5: note: see existing symbol definition here\r\n```","createdAt":"2023-07-28T21:07:23Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":5727,"state":"OPEN","title":"[FIRRTL] Lower XMR assumes unique port names","url":"https://github.com/llvm/circt/issues/5727"},{"body":"in FIRRTL there is RemoveUnusedPortsPass but it would be nice to implement the same pass\r\nat HW dialect since Comb canonicalization is stronger. Also it would be useful functionality to CIRCT users. \r\n\r\nFrom a perspective FIRRTL, a recent change of name preservation prohibits RemoveUnusedPortsPass at FIRRTL level so \r\nit is necessary to run the pass after eliminating dead named wires. ","createdAt":"2022-05-19T07:21:36Z","labels":[{"id":"MDU6TGFiZWwyMTUyNzU0NzU0","name":"HW","description":"Involving the `hw` dialect","color":"081f7a"}],"number":3146,"state":"OPEN","title":"[HW] Pass to remove dead ports","url":"https://github.com/llvm/circt/issues/3146"},{"body":"Input:\r\n\r\n```firrtl\r\ncircuit Ext :\r\n  extmodule Ext :\r\n      input x : UInt<1>\r\n```\r\n\r\nProduces:\r\n\r\n```\r\n// Generated by CIRCT 1.31.0g20230217_f4a1235\r\n// external module Ext\r\n```\r\n\r\nWe don't need the port, but SFC apparently does, which seems to also accept this (producing an empty file) as of 1.5.3, FWIW.\r\n\r\nThis isn't unreasonable behavior, but probably should be rejected?  Kinda surprised (in a good way) nothing breaks along the way with this! :laughing: \r\n\r\nLooks like `defname` can be used to rename the main module too, FWIW. :thinking: ","createdAt":"2023-02-17T23:44:46Z","labels":[{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":4674,"state":"OPEN","title":"[FIRRTL] extmodule as main module","url":"https://github.com/llvm/circt/issues/4674"},{"body":"Follow-up on #6388/#6416\r\n\r\nThe merged PR hotfixes the crash during compilation, but there remain inconsistencies in the serialized output format.\r\nPushing the example of #6388  through `circt-opt --mlir-print-debuginfo --mlir-print-local-scope` prints:\r\n\r\n```\r\nmodule {\r\n  hw.module @test(in %I : i1, out O : i1) {\r\n    hw.output %I : i1 loc(\"<stdin>\":3:9)\r\n  } loc(\"<stdin>\":2:5)\r\n} loc(\"<stdin>\":1:1)\r\n```\r\n\r\nThe explicitly unknown locations are missing. Parsing and printing this output again produces:\r\n\r\n```\r\nmodule {\r\n  hw.module @test(in %I : i1 loc(\"<stdin>\":2:22), out O : i1 loc(\"<stdin>\":2:35)) {\r\n    hw.output %I : i1 loc(\"<stdin>\":3:9)\r\n  } loc(\"<stdin>\":2:5)\r\n} loc(\"<stdin>\":1:1)\r\n```\r\n\r\nWhile this could likely be fixed in `module_like_impl::printModuleSignatureNew`, this indicates that there is a semantic difference between having no location vs. having an unknown location. So, removing unknown location attributes from ports and reconstructing them on demand could be problematic in general. There are also concerns regarding performance (see #6257).","createdAt":"2023-11-15T14:16:48Z","labels":[],"number":6417,"state":"OPEN","title":"[HW] Unkown location attributes on HWModule ports missing in serialized IR","url":"https://github.com/llvm/circt/issues/6417"}]
[{"body":"As pointed out by @Scheremo on #9199, the following SV snippet from sv-tests:\n\n```\n// Copyright (C) 2019-2021  The SymbiFlow Authors.\n//\n// Use of this source code is governed by a ISC-style\n// license that can be found in the LICENSE file or at\n// https://opensource.org/licenses/ISC\n//\n// SPDX-License-Identifier: ISC\n\n\n/*\n:name: string_len\n:description: string.len()  tests\n:tags: 6.16.1\n*/\nmodule top();\n\tstring a = \"Test\";\n\tint b = a.len();\nendmodule\n```\n\nproduces a moore.conversion op from an int to string, but there's a dedicated moore.int_to_string op that we would expect to be materialized there instead","createdAt":"2025-11-07T16:36:26Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"},{"id":"LA_kwDODpuCgs8AAAABp1j0gg","name":"ImportVerilog","description":"","color":"e99695"}],"number":9206,"state":"OPEN","title":"[ImportVerilog] moore.conversion generated instead of moore.int_to_string","url":"https://github.com/llvm/circt/issues/9206"},{"body":"Input test case:\n\n```verilog\nmodule bug (\n    input logic wr_clk,\n    input logic wr_data,\n    output logic [1:0] mem\n);\n`ifdef CASE_1\n  always_ff @(posedge (wr_clk)) begin\n      mem[0] <= wr_data;\n  end\n  always_ff @(posedge (wr_clk)) begin\n      mem[1] <= wr_data;\n  end\n`else\n  always_ff @(posedge (wr_clk)) begin\n      mem[0] <= wr_data;\n      mem[1] <= wr_data;\n  end\n`endif\nendmodule\n```\n\nthe two results in different outputs\n\n```mlir\nmodule {\n  hw.module @bug(in %wr_clk : i1 loc(#loc2), in %wr_data : i1 loc(#loc3), out mem : i2) {\n    %0 = comb.replicate %wr_data : (i1) -> i2 loc(#loc4)\n    %1 = seq.to_clock %wr_clk loc(#loc5)\n    %mem = seq.firreg %0 clock %1 : i2 loc(#loc5)\n    hw.output %mem : i2 loc(#loc1)\n  } loc(#loc1)\n} loc(#loc)\n```\n\nvs\n\n```mlir\nmodule {\n  hw.module @bug(in %wr_clk : i1 loc(#loc2), in %wr_data : i1 loc(#loc3), out mem : i2) {\n    %0 = llhd.constant_time <0ns, 0d, 1e> loc(#loc2)\n    %c0_i2 = hw.constant 0 : i2 loc(#loc4)\n    %mem = llhd.sig %c0_i2 : i2 loc(#loc4)\n    %1 = comb.extract %6 from 1 : (i2) -> i1 loc(#loc5)\n    %2 = comb.concat %1, %wr_data : i1, i1 loc(#loc5)\n    %3 = seq.to_clock %wr_clk loc(#loc4)\n    %mem_0 = seq.firreg %2 clock %3 {name = \"mem\"} : i2 loc(#loc4)\n    llhd.drv %mem, %mem_0 after %0 : !hw.inout<i2> loc(#loc4)\n    %4 = comb.extract %6 from 0 : (i2) -> i1 loc(#loc6)\n    %5 = comb.concat %wr_data, %4 : i1, i1 loc(#loc6)\n    %mem_1 = seq.firreg %5 clock %3 {name = \"mem\"} : i2 loc(#loc4)\n    llhd.drv %mem, %mem_1 after %0 : !hw.inout<i2> loc(#loc4)\n    %6 = llhd.prb %mem : !hw.inout<i2> loc(#loc4)\n    hw.output %6 : i2 loc(#loc1)\n  } loc(#loc1)\n} loc(#loc)\n```\n\n(splitting the mem output into 2 separate outputs also result in same output with and without def).","createdAt":"2025-10-05T19:56:14Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"},{"id":"LA_kwDODpuCgs8AAAABp1j0gg","name":"ImportVerilog","description":"","color":"e99695"}],"number":9052,"state":"CLOSED","title":"[circt-verilog] Import difference of results in arcilator failure with remaining llhd constant_time","url":"https://github.com/llvm/circt/issues/9052"},{"body":"Is there a strong reason to go from PowUOp to math.ipow as opposed to lowering to a sequence of multiplications?\n\nIs there any existing lowering from math.ipow to the core dialects? \n\nhttps://github.com/llvm/circt/blob/83effb21cd6b1cebc060b4f57180f16683309cd9/lib/Conversion/MooreToCore/MooreToCore.cpp#L1379-L1398","createdAt":"2025-09-16T14:19:34Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8973,"state":"OPEN","title":"[MooreToCore] Lowering to math.ipow?","url":"https://github.com/llvm/circt/issues/8973"},{"body":"For input\n\n```mlir\nmodule {\n  moore.module @a(in %b : !moore.l1, in %in : !moore.l64, out out : !moore.l64) {\n    %out = moore.variable : <l64>\n    %0 = moore.read %out : <l64>\n    moore.output %0 : !moore.l64\n  }\n  moore.module @c(out d : !moore.array<1 x l1>, out e : !moore.array<1 x array<1 x l3>>, out f : !moore.l1, out g : !moore.l64) {\n    %h = moore.variable : <l3>\n    %d = moore.variable : <array<1 x l1>>\n    %f = moore.variable : <l1>\n    %g = moore.variable : <l64>\n    %j = moore.variable : <array<1 x array<1 x l3>>>\n    %0 = moore.extract_ref %j from 0 : <array<1 x array<1 x l3>>> -> <array<1 x l3>>\n    %1 = moore.extract_ref %0 from 0 : <array<1 x l3>> -> <l3>\n    %2 = moore.read %h : <l3>\n    moore.assign %1, %2 : l3\n    %3 = moore.read %j : <array<1 x array<1 x l3>>>\n    %4 = moore.read %f : <l1>\n    %.out = moore.instance \"\" @a(b: %4: !moore.l1, in: %.out: !moore.l64) -> (out: !moore.l64)\n    %5 = moore.read %d : <array<1 x l1>>\n    %6 = moore.read %f : <l1>\n    %7 = moore.read %g : <l64>\n    moore.output %5, %3, %6, %7 : !moore.array<1 x l1>, !moore.array<1 x array<1 x l3>>, !moore.l1, !moore.l64\n  }\n}\n```\n\nthe output of convert-moore-to-core results in\n\n```\nsmall.mlir:13:10: error: 'llhd.sig.array_slice' op failed to verify that arrays element type must match\n    %0 = moore.extract_ref %j from 0 : <array<1 x array<1 x l3>>> -> <array<1 x l3>>\n         ^\nsmall.mlir:13:10: note: see current operation: %13 = \"llhd.sig.array_slice\"(%11, %12) : (!hw.inout<array<1xarray<1xi3>>>, i0) -> !hw.inout<array<1xi3>>\n```\n\nsnippet\n\n```\n%11 = \"llhd.sig\"(%10) <{name = \"j\"}> : (!hw.array<1xarray<1xi3>>) -> !hw.inout<array<1xarray<1xi3>>>\n    %12 = \"hw.constant\"() <{value = 0 : i0}> : () -> i0\n    %13 = \"llhd.sig.array_slice\"(%11, %12) : (!hw.inout<array<1xarray<1xi3>>>, i0) -> !hw.inout<array<1xi3>>\n```\n\nfrom `ExtractRefOpConversion`.","createdAt":"2025-09-10T19:08:23Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8939,"state":"CLOSED","title":"[MooreToCore] Generating invalid llhd.sig.array_slice","url":"https://github.com/llvm/circt/issues/8939"},{"body":"New circt user here, trying to run circt-verilog on my design.\nI run into an issue when trying to parse the $fatal  system verilog system task.\n\nThe System Verilog code in question is:\n```verilog\n $fatal(1, \"Timeout exceeded!\");\n```\n\nThe moore IR emitted is:\n```mlir\n%12 = moore.fmt.literal \"Timeout exceeded!\"\nmoore.builtin.severity fatal %12\nmoore.builtin.finish_message false\nmoore.builtin.finish 1\nmoore.unreachable\n```\n\nI suppose this should be converted into a `sim.terminate` op, but I am unsure how to match/combine moore.builtin.finish. Any advice?","createdAt":"2025-09-09T14:03:38Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8934,"state":"CLOSED","title":"[MooreToCore] Unsupported $fatal to sim.terminate conversion","url":"https://github.com/llvm/circt/issues/8934"},{"body":"It failed when trying to compile https://github.com/pulp-platform/ELAU/blob/b0d113aff6a2d800076f5ebb84f09fba93625bc7/src/SqrtArrUns.sv#L96-L105. \n```\nmoore.module @behavioural_SqrtArrUns(in %X : !moore.l8, out Q : !moore.l4, out R : !moore.l4) {\n  %0 = moore.constant 2 : l8\n  %1 = moore.conversion %X : !moore.l8 -> !moore.real\n  %2 = moore.builtin.sqrt %1 : real\n  %3 = moore.builtin.floor %2 : real\n  %4 = moore.conversion %3 : !moore.real -> !moore.l4\n  %5 = moore.zext %4 : l4 -> l8\n  %6 = moore.powu %5, %0 : l8\n  %7 = moore.sub %X, %6 : l8\n  %8 = moore.trunc %7 : l8 -> l4\n  moore.output %4, %8 : !moore.l4, !moore.l4\n}\n```\n\n```\n[circt-verilog] Running \"convert-moore-to-core\"\ncirct-verilog: /home/uenoku/dev/circt-synth/llvm/llvm/include/llvm/Support/Casting.h:650: decltype(auto) llvm::dyn_cast(const From &) [To = mlir::IntegerType, From = mlir::Type]: Assertion `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.      Program arguments: circt-verilog ../out/SqrtArrUns_behavioral.sv -o build/SqrtArrUns_behavioral/circt/SqrtArrUns_behavioral.mlir --mlir-timing -y ../out ../ext/ELAU/src/arith_utils.sv -mlir-print-ir-after-all -verbose-pass-executions\n #0 0x00005a3051df92b8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/uenoku/dev/circt-synth/llvm/llvm/lib/Support/Unix/Signals.inc:834:13\n #1 0x00005a3051df6e93 llvm::sys::RunSignalHandlers() /home/uenoku/dev/circt-synth/llvm/llvm/lib/Support/Signals.cpp:105:18\n #2 0x00005a3051dfa051 SignalHandler(int, siginfo_t*, void*) /home/uenoku/dev/circt-synth/llvm/llvm/lib/Support/Unix/Signals.inc:426:38\n #3 0x00007ecdbca42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #4 0x00007ecdbca969fc __pthread_kill_implementation ./nptl/./nptl/pthread_kill.c:44:76\n #5 0x00007ecdbca969fc __pthread_kill_internal ./nptl/./nptl/pthread_kill.c:78:10\n #6 0x00007ecdbca969fc pthread_kill ./nptl/./nptl/pthread_kill.c:89:10\n #7 0x00007ecdbca42476 gsignal ./signal/../sysdeps/posix/raise.c:27:6\n #8 0x00007ecdbca287f3 abort ./stdlib/./stdlib/abort.c:81:7\n #9 0x00007ecdbca2871b _nl_load_domain ./intl/./intl/loadmsgcat.c:1177:9\n#10 0x00007ecdbca39e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n#11 0x00005a3050b0d8c4 decltype(auto) llvm::dyn_cast<mlir::IntegerType, mlir::Type>(mlir::Type const&) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x1ad8c4)\n#12 0x00005a3050cb10c5 decltype(auto) llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Type, long>, mlir::Type>::castValue<mlir::IntegerType, mlir::Type const&>(mlir::Type const&) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x3510c5)\n#13 0x00005a3050c9d8da llvm::TypeSwitch<mlir::Type, long>& llvm::TypeSwitch<mlir::Type, long>::Case<mlir::IntegerType, circt::hw::getBitWidth(mlir::Type)::$_0>(circt::hw::getBitWidth(mlir::Type)::$_0&&) HWTypes.cpp:0:0\n#14 0x00005a3050c9d7e6 circt::hw::getBitWidth(mlir::Type) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x33d7e6)\n#15 0x00005a30510f9908 (anonymous namespace)::ConversionOpConversion::matchAndRewrite(circt::moore::ConversionOp, circt::moore::ConversionOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n#16 0x00005a30510fa631 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::ConversionOp>, circt::moore::ConversionOp>(mlir::OpConversionPattern<circt::moore::ConversionOp> const&, circt::moore::ConversionOp, circt::moore::ConversionOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange> >, mlir::ConversionPatternRewriter&) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x79a631)\n```","createdAt":"2025-09-06T09:21:38Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8930,"state":"OPEN","title":"[MooreToCore] Crash with sqrt/floor","url":"https://github.com/llvm/circt/issues/8930"},{"body":"@jiahanxie353 has added the Math dialect to circt-opt in #8475. This is a great precedent to start using that dialect in the MooreToCore conversion. For example, the `moore.pow` operation could be lowered to `math.ipowi` and `math.powf` depending on its type.","createdAt":"2025-05-12T16:08:01Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIx","name":"good first issue","description":"Good for newcomers","color":"7057ff"},{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8476,"state":"OPEN","title":"[MooreToCore] Lower exponentiation to `math.ipowi`","url":"https://github.com/llvm/circt/issues/8476"},{"body":"I'm looking into the failing testcase for `real` constants [on sv-tests-results](https://chipsalliance.github.io/sv-tests-results/?v=circt_verilog+5.7.2+real-constants). Just want to put it up here to make sure no one else has already started working on it.","createdAt":"2025-02-23T19:01:31Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8269,"state":"OPEN","title":"[MooreToCore] Support `real` constants","url":"https://github.com/llvm/circt/issues/8269"},{"body":"If I understand IEEE 1800-2017 §7.4.6 Indexing and slicing of arrays right, an unpacked array slice should be 0/X in its entirety even if only a part of the slice is OOB. Currently, only the OOB part is 0/X because they are lowered just like packed arrays.","createdAt":"2025-02-10T13:02:44Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8215,"state":"OPEN","title":"[MooreToCore] OOB array slices of unpacked arrays lowered like packed arrays","url":"https://github.com/llvm/circt/issues/8215"},{"body":"Please check this PR(https://github.com/llvm/circt/pull/8210/files) to view the details.\n\nOr for example:\n```\nmoore.module @crash(in %in0: !moore.i32, in %in1: !moore.i32) {\n  %var = moore.variable : <!moore.i32>\n  moore.procedure always_comb {\n    %0 = moore.pows %in0, %in1 : !moore.i32\n    moore.blocking_assign %var, %0 : !moore.i32\n    moore.return\n  }\n}\n```\n\n`%var` will be regarded as one member of the implicit sensitivity list. But this act is illegal❌.","createdAt":"2025-02-08T13:58:49Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8211,"state":"OPEN","title":"[MooreToCore]Unexpected observed values in llhd.wait.","url":"https://github.com/llvm/circt/issues/8211"},{"body":"The following crashes due to an unattached region when calling `getValuesToObserve`.\n\n```mlir\nmoore.module @crash(in %in0: !moore.i32, in %in1: !moore.i32) {\n  %var = moore.variable : <!moore.i32>\n  moore.procedure always_comb {\n    %0 = moore.pows %in0, %in1 : !moore.i32\n    moore.blocking_assign %var, %0 : !moore.i32\n    moore.return\n  }\n}\n```","createdAt":"2025-02-03T10:27:41Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8176,"state":"OPEN","title":"[MooreToCore] Crash when getting values to observe","url":"https://github.com/llvm/circt/issues/8176"},{"body":"In Verilog it's legal to access arrays/bitvectors out-of-bounds which will yield X or 0. Thus a lowBit attribute not within the range is allowed by `moore.extract`. This is currently lowered 1-1 to `comb.extract` which does verify that the lowBit attribute is within range. Therefore, MooreToCore needs to check if the attribute is out of bounds and lower it to a constant in that case.","createdAt":"2025-01-31T13:37:09Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8163,"state":"OPEN","title":"[MooreToCore] Out-of-bounds moore.extract lowered incorrectly","url":"https://github.com/llvm/circt/issues/8163"},{"body":"Apparently we're missing a conversion from `moore.array_create` in MooreToCore. Thanks @uenoku for finding this.","createdAt":"2025-01-25T00:27:15Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIx","name":"good first issue","description":"Good for newcomers","color":"7057ff"},{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8128,"state":"CLOSED","title":"[MooreToCore] Support `moore.array_create`","url":"https://github.com/llvm/circt/issues/8128"},{"body":"Now, we ignore statement block symbols. But in some cases, we'll trigger the dominance error. For example:\n```\nmodule top_module;\n    always @(*) begin\n        integer j;\n        for(j = 0; j < 4; j++);\n    end \nendmodule\n```\n**Error:**\n``` cxx\nforLoop.sv:2:12: error: operand #0 does not dominate this use\n    always @(*) begin\n           ^\nforLoop.sv:2:12: note: see current operation: %20 = \"moore.read\"(%0) : (!moore.ref<l32>) -> !moore.l32\nforLoop.sv:3:17: note: note: operand defined here (op in a parent region)\n        integer j;\n```\nor\n```\nmodule top_module;\n    always @(*) begin\n        for(int i = 0;i<4;i++);\n    end\nendmodule\n```\n**Error:**\n```cxx\nforLoop.sv:2:12: error: operand #0 does not dominate this use\n    always @(*) begin\n           ^\nforLoop.sv:2:12: note: see current operation: %9 = \"moore.read\"(%1) : (!moore.ref<i32>) -> !moore.i32\nforLoop.sv:3:17: note: operand defined here (op in a parent region)\n        for(int i = 0;i<4;i++);\n```\n\nThis error is caused by the `moore.wait_event`. When we handle `always @(*)`, we must ensure which signal will lead to recalculating the whole always block. If we declare `integer j` out of the always block, we can generate the following Moore IR:\n```\nmodule {\n  moore.module @top_module() {\n    %j = moore.variable : <l32>\n    moore.procedure always {\n      moore.wait_event {\n        %10 = moore.read %j : <l32>\n        moore.detect_event any %10 : l32\n      }\n      %0 = moore.constant 0 : i32\n      %1 = moore.conversion %0 : !moore.i32 -> !moore.l32\n      moore.blocking_assign %j, %1 : l32\n      cf.br ^bb1\n    ^bb1:  // 2 preds: ^bb0, ^bb3\n      %2 = moore.read %j : <l32>\n      %3 = moore.constant 4 : i32\n      %4 = moore.conversion %3 : !moore.i32 -> !moore.l32\n      %5 = moore.slt %2, %4 : l32 -> l1\n      %6 = moore.conversion %5 : !moore.l1 -> i1\n      cf.cond_br %6, ^bb2, ^bb4\n    ^bb2:  // pred: ^bb1\n      cf.br ^bb3\n    ^bb3:  // pred: ^bb2\n      %7 = moore.read %j : <l32>\n      %8 = moore.constant 1 : l32\n      %9 = moore.add %7, %8 : l32\n      moore.blocking_assign %j, %9 : l32\n      cf.br ^bb1\n    ^bb4:  // pred: ^bb1\n      moore.return\n    }\n    moore.output\n  }\n}\n```\nThe `%10 = moore.read %j : <l32>` means that we must have already created the `%j = moore.variable : <l32>`. So I think maybe we don't ignore `slang::ast::StatementBlockSymbol`.","createdAt":"2024-12-30T05:55:59Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"},{"id":"LA_kwDODpuCgs8AAAABp1j0gg","name":"ImportVerilog","description":"","color":"e99695"}],"number":8021,"state":"OPEN","title":"[ImportVerilog] Support handling the slang::ast::StatementBlockSymbol.","url":"https://github.com/llvm/circt/issues/8021"},{"body":"I have a mmu.sv module for RISC-V implementation: \r\n```Verilog\r\nmodule mmu #(\r\n    parameter integer DEVICE_COUNT = 0\r\n) (\r\n...\r\noutput logic [31:2] dev_addr[DEVICE_COUNT]\r\n...\r\n```\r\n\r\nthat is used in top module like:\r\n\r\n```Verilog\r\nmmu #(\r\n        .DEVICE_COUNT(8)\r\n    ) mmu (\r\n...\r\n        .dev_addr(\r\n        '{\r\n            rom_addr,\r\n            ram_addr[0],\r\n            ram_addr[1],\r\n            ram_addr[2],\r\n            ram_addr[3],\r\n            led_addr,\r\n            mtime_addr,\r\n            mtimecmp_addr\r\n        }\r\n\r\n...\r\n```\r\n\r\nwhen trying to compile with `circt-verilog mmu.sv` i get this error:\r\n\r\n```bash\r\ncore/mmu.sv:17:34: error: value must be positive\r\n    output logic [31:2] dev_addr[DEVICE_COUNT],\r\n```\r\n\r\nis it impossible to compile such module? why so?","createdAt":"2024-10-31T00:20:57Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":7753,"state":"OPEN","title":"[circt-verilog] zero parameter at module declaration fails when used ","url":"https://github.com/llvm/circt/issues/7753"},{"body":"Lower the `moore.fmt.*` string formatting operations to the corresponding ops in the Sim dialect. The Sim dialect ops might need additional width, alignment, and padding arguments.\r\n\r\nThe following might be a useful test ([taken from sv-tests](https://chipsalliance.github.io/sv-tests-results/?v=circt_verilog+7.1+basic-packed-structures)):\r\n```mlir\r\nmodule {\r\n  moore.module @top() {\r\n    %0 = moore.constant 90 : i8\r\n    %p1 = moore.variable : <struct<{lo: i4, hi: i4}>>\r\n    moore.procedure initial {\r\n      %1 = moore.conversion %0 : !moore.i8 -> !moore.struct<{lo: i4, hi: i4}>\r\n      moore.blocking_assign %p1, %1 : struct<{lo: i4, hi: i4}>\r\n      %2 = moore.fmt.literal \":assert: ('\"\r\n      %3 = moore.read %p1 : <struct<{lo: i4, hi: i4}>>\r\n      %4 = moore.conversion %3 : !moore.struct<{lo: i4, hi: i4}> -> !moore.i8\r\n      %5 = moore.fmt.int hex_lower %4, width 2, align right, pad zero : i8\r\n      %6 = moore.fmt.literal \"' == '5a')\"\r\n      %7 = moore.fmt.literal \"\\0A\"\r\n      %8 = moore.fmt.concat (%2, %5, %6, %7)\r\n      moore.builtin.display %8\r\n      %9 = moore.fmt.literal \":assert: (('\"\r\n      %10 = moore.read %p1 : <struct<{lo: i4, hi: i4}>>\r\n      %11 = moore.struct_extract %10, \"hi\" : struct<{lo: i4, hi: i4}> -> i4\r\n      %12 = moore.fmt.int hex_lower %11, width 1, align right, pad zero : i4\r\n      %13 = moore.fmt.literal \"' == 'a') and ('\"\r\n      %14 = moore.struct_extract %10, \"lo\" : struct<{lo: i4, hi: i4}> -> i4\r\n      %15 = moore.fmt.int hex_lower %14, width 1, align right, pad zero : i4\r\n      %16 = moore.fmt.literal \"' == '5'))\"\r\n      %17 = moore.fmt.concat (%9, %12, %13, %15, %16, %7)\r\n      moore.builtin.display %17\r\n      moore.return\r\n    }\r\n    moore.output\r\n  }\r\n}\r\n```","createdAt":"2024-09-28T21:12:30Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIx","name":"good first issue","description":"Good for newcomers","color":"7057ff"},{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":7648,"state":"CLOSED","title":"[MooreToCore] Support format strings","url":"https://github.com/llvm/circt/issues/7648"},{"body":"Add conversion patterns from `moore.{assert,assume,cover}` to the corresponding `verif.*` op in MooreToConv. Consider rejecting deferred assertions for now. https://chipsalliance.github.io/sv-tests-results/?v=circt_verilog+16.2+assert_test","createdAt":"2024-09-25T03:35:30Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":7630,"state":"CLOSED","title":"[MooreToCore] Support assert, assume, cover ops","url":"https://github.com/llvm/circt/issues/7630"},{"body":"Add a conversion for the `moore.net` op to MooreToConv: https://chipsalliance.github.io/sv-tests-results/?v=circt_verilog+12.4+if","createdAt":"2024-09-25T03:28:07Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIx","name":"good first issue","description":"Good for newcomers","color":"7057ff"},{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":7629,"state":"OPEN","title":"[MooreToCore] Support net op","url":"https://github.com/llvm/circt/issues/7629"},{"body":"Add a conversion for the `moore.string_constant` op to MooreToCore: https://chipsalliance.github.io/sv-tests-results/?v=circt_verilog+11.10+string_bit_array","createdAt":"2024-09-25T03:26:11Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIx","name":"good first issue","description":"Good for newcomers","color":"7057ff"},{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":7628,"state":"CLOSED","title":"[MooreToCore] Support string constants","url":"https://github.com/llvm/circt/issues/7628"},{"body":"The following input crashes the MooreToCore conversion. Might be fixed by #7625.\r\n```mlir\r\nmodule {\r\n  moore.module @top() {\r\n    %mem = moore.variable : <uarray<1024 x l8>>\r\n    %a = moore.variable : <l8>\r\n    moore.procedure initial {\r\n      %0 = moore.read %mem : <uarray<1024 x l8>>\r\n      %1 = moore.extract %0 from 123 : uarray<1024 x l8> -> l8\r\n      moore.blocking_assign %a, %1 : l8\r\n      moore.return\r\n    }\r\n    moore.output\r\n  }\r\n}\r\n```","createdAt":"2024-09-25T03:24:07Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":7627,"state":"CLOSED","title":"[MooreToCore] Unpacked array causes crash","url":"https://github.com/llvm/circt/issues/7627"}]
[{"body":"Making this issue for tracking as I gradually replace all the uses of to_builtin_bool with to_builtin_int (not totally trivial since we now have to explicitly cast to int type), as I'll split it across PRs to keep the diffs small and make sure I'm not missing anything\n\nPlaces to change:\n- [x] Assertion builtin handling\n- [ ] AssertionExpr.cpp convertToI1 function\n- [ ] Statements.cpp conditions\n- [ ] MooreToCore","createdAt":"2026-01-29T18:09:01Z","labels":[],"number":9542,"state":"OPEN","title":"[Moore] to_builtin_bool should be replaced with to_builtin_int","url":"https://github.com/llvm/circt/issues/9542"},{"body":"## Description\n\nCIRCT crashes with assertion `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"` when compiling SystemVerilog modules that use packed union types as module ports.\n\n**Likely cause**: MooreToCore conversion pass lacks a type conversion rule for packed union types (`UnionType`). When processing module ports, the type converter fails to convert `UnionType`, resulting in an invalid/null type that causes assertion failures in downstream port processing code (`getModulePortInfo` at line 259).\n\n> **Validation**: Test case accepted by: verilator, iverilog, slang\n> **IEEE 1800-2005**: Packed unions are valid (Section 7.3)\n\n## Steps to Reproduce\n\n1. Save following code as `bug.sv`\n2. Run: `circt-verilog --ir-hw bug.sv`\n\n## Test Case\n\n```systemverilog\ntypedef union packed {\n  logic [31:0] a;\n  logic [31:0] b;\n} my_union;\n\nmodule Sub(input my_union in_val, output my_union out_val);\n  assign out_val = in_val;\nendmodule\n\nmodule Top;\n  my_union data_in, data_out;\n  \n  Sub s(.in_val(data_in), .out_val(data_out));\nendmodule\n```\n\n## Error Output\n\n```\n #4 0x00007f8176f898ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007f8176f89b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007f8176f89530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n```\n\n<details>\n<summary>Full Stack Trace</summary>\n\n```\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.      Program arguments: /opt/firtool/bin/circt-verilog --ir-hw bug.sv\n #0 0x00007f8172d678a8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x2008a8)\n #1 0x00007f8172d652f5 llvm::sys::RunSignalHandlers() (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x1fe2f5)\n #2 0x00007f8172d68631 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x00007f8172875330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #4 0x00007f8176f898ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007f8176f89b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007f8176f89530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n #7 0x00007f817529b438 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2a438)\n #8 0x00007f81752658ed void llvm::function_ref<void ()>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_0>(long) PatternApplicator.cpp:0:0\n #9 0x00007f8175262774 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/opt/firtool-1.139.0/bin/../lib/libMLIRRewrite.so+0x7774)\n#10 0x00007f817529cc6f (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*) DialectConversion.cpp:0:0\n#11 0x00007f817529c470 mlir::OperationConverter::convert(mlir::Operation*, bool) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2b470)\n#12 0x00007f817529cdae mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2bdae)\n#13 0x00007f81752aa8e4 void llvm::function_ref<void ()>::callback_fn<applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode)::$_0>(long) DialectConversion.cpp:0:0\n#14 0x00007f81752a1f7d applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode) DialectConversion.cpp:0:0\n#15 0x00007f81752a20fe mlir::applyFullConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x310fe)\n#16 0x00007f8176f5b231 (anonymous namespace)::MooreToCorePass::runOnOperation() MooreToCore.cpp:0:0\n#17 0x00007f81750572a5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x172a5)\n#18 0x00007f817505a7a9 mlir::PassManager::run(mlir::Operation*) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x1a7a9)\n#19 0x0000563df3daf5d0 executeWithSources(mlir::MLIRContext*, llvm::SourceMgr&) circt-verilog.cpp:0:0\n#20 0x0000563df3daadd5 execute(mlir::MLIRContext*) circt-verilog.cpp:0:0\n#21 0x0000563df3daa4b8 main (/opt/firtool/bin/circt-verilog+0x84b8)\n#22 0x00007f817285a1ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#23 0x00007f817285a28b call_init ./csu/../csu/libc-start.c:128:20\n#24 0x00007f817285a28b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#25 0x0000563df3da9b05 _start (/opt/firtool/bin/circt-verilog+0x7b05)\n[1]    1143009 segmentation fault (core dumped)  /opt/firtool/bin/circt-verilog --ir-hw bug.sv\n\n```\n\n</details>\n\n## Root Cause Analysis\n\n- **Dialect**: Moore\n- **Failing Pass**: MooreToCore\n\n### Hypotheses\n\n1. **Missing UnionType type conversion rule** (confidence: high)\n   - Evidence: [\"Test case uses 'typedef union packed' as module port type\", 'Stack trace shows crash in getModulePortInfo during port processing at line 259', \"Assertion message indicates 'dyn_cast<InOutType>' failed on non-existent value\", 'No conversion rule for UnionType exists in populateTypeConversion function (lines 2268-2409)', 'Similar types like StructType have conversion rules, but UnionType does not', 'Both UnionType and StructType implement DestructurableTypeInterface, suggesting they should be handled similarly']\n   - Mechanism: The typeConverter fails to convert UnionType when processing module ports, resulting in an invalid type that causes assertion failures\n\n2. **Type converter returns invalid non-null type** (confidence: medium)\n   - Evidence: [\"Line 245-248 checks 'if (!portTy)' and emits error\", 'However, crash still occurs, suggesting either the check is not being reached or the type is non-null but invalid', 'The assertion occurs in a different code path that may not be covered by the initial null check']\n   - Mechanism: The typeConverter may return a non-null type with incorrect MLIR type ID or metadata\n\n## Environment\n\n- **CIRCT Version**: LLVM (http://llvm.org/):\n  LLVM version 22.0.0git\n  Optimized build.\nCIRCT firtool-1.139.0\nslang version 9.1.0+0\n\n---\n**Labels**: bug, Moore","createdAt":"2026-02-01T02:15:22Z","labels":[],"number":9570,"state":"OPEN","title":"[Moore] Assertion in MooreToCore when module uses packed union type as port","url":"https://github.com/llvm/circt/issues/9570"},{"body":"## Bug Description\n\n`circt-verilog` crashes with an assertion failure when processing a SystemVerilog module that has a `string` type output port. The crash occurs during the MooreToCore conversion pass when the `getModulePortInfo()` function fails to properly handle cases where type conversion returns an invalid/empty type, causing a `dyn_cast` assertion failure in `ModulePortInfo::sanitizeInOut()`.\n\nThis is a valid SystemVerilog construct per IEEE 1800-2017 Section 6.16 (String data type). Both **slang** and **verilator** accept the code without errors.\n\n## Steps to Reproduce\n\n1. Save the following test case as `bug.sv`\n2. Run: `circt-verilog --ir-hw bug.sv`\n\n## Test Case\n\n```systemverilog\nmodule test_module(output string a);\nendmodule\n```\n\n## Expected Behavior\n\nCIRCT should either:\n1. Support simulation constructs like string ports appropriately, OR\n2. Emit a proper diagnostic error message indicating that string ports are not supported for hardware synthesis\n\n## Actual Behavior\n\nThe tool crashes with an assertion failure:\n\n```\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: circt-verilog --ir-hw bug.sv\n #0 0x00007fe810a738a8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x2008a8)\n #1 0x00007fe810a712f5 llvm::sys::RunSignalHandlers() (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x1fe2f5)\n #2 0x00007fe810a74631 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x00007fe810581330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #4 0x00007fe814c958ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007fe814c95b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007fe814c95530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n #7 0x00007fe812fa7438 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2a438)\n #8 0x00007fe812f718ed void llvm::function_ref<void ()>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_0>(long) PatternApplicator.cpp:0:0\n #9 0x00007fe812f6e774 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/opt/firtool-1.139.0/bin/../lib/libMLIRRewrite.so+0x7774)\n#10 0x00007fe812fa8c6f (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*) DialectConversion.cpp:0:0\n#11 0x00007fe812fa8470 mlir::OperationConverter::convert(mlir::Operation*, bool) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2b470)\n#12 0x00007fe812fa8dae mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2bdae)\n#13 0x00007fe812fb68e4 void llvm::function_ref<void ()>::callback_fn<applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode)::$_0>(long) DialectConversion.cpp:0:0\n#14 0x00007fe812fadf7d applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode) DialectConversion.cpp:0:0\n#15 0x00007fe812fae0fe mlir::applyFullConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x310fe)\n#16 0x00007fe814c67231 (anonymous namespace)::MooreToCorePass::runOnOperation() MooreToCore.cpp:0:0\n#17 0x00007fe812d632a5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x172a5)\n#18 0x00007fe812d667a9 mlir::PassManager::run(mlir::Operation*) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x1a7a9)\n#19 0x0000561bab9605d0 executeWithSources(mlir::MLIRContext*, llvm::SourceMgr&) circt-verilog.cpp:0:0\n#20 0x0000561bab95bdd5 execute(mlir::MLIRContext*) circt-verilog.cpp:0:0\n#21 0x0000561bab95b4b8 main (/opt/firtool-1.139.0/bin/circt-verilog+0x84b8)\n#22 0x00007fe8105661ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#23 0x00007fe81056628b call_init ./csu/../csu/libc-start.c:128:20\n#24 0x00007fe81056628b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#25 0x0000561bab95ab05 _start (/opt/firtool-1.139.0/bin/circt-verilog+0x7b05)\n\n```\n\n## Root Cause Analysis\n\n### Crash Location\n- **File**: `lib/Conversion/MooreToCore/MooreToCore.cpp`\n- **Function**: `getModulePortInfo()` → calls `ModulePortInfo::sanitizeInOut()`\n- **Assertion**: `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"`\n\n### Analysis\n\nThe root cause is **missing validation of type conversion result** in `getModulePortInfo()`:\n\n```cpp\n// MooreToCore.cpp:233-259\nstatic hw::ModulePortInfo getModulePortInfo(const TypeConverter &typeConverter,\n                                            SVModuleOp op) {\n  // ...\n  for (auto port : moduleTy.getPorts()) {\n    Type portTy = typeConverter.convertType(port.type);  // <-- May return empty Type!\n    // ...\n    ports.push_back(hw::PortInfo({{port.name, portTy, port.dir}, ...}));  // <-- Stores empty Type\n  }\n  return hw::ModulePortInfo(ports);  // <-- Constructor calls sanitizeInOut()\n}\n```\n\nWhen `typeConverter.convertType()` fails for the `string` port type (returns empty `Type`), this invalid type is passed to `sanitizeInOut()` which calls `dyn_cast<hw::InOutType>(p.type)` on the empty type, triggering the assertion.\n\n### Suggested Fix\n\nAdd validation in `getModulePortInfo()` to check if `typeConverter.convertType()` returns a valid type:\n\n```cpp\nType portTy = typeConverter.convertType(port.type);\nif (!portTy) {\n  // Emit proper diagnostic error\n  return failure();\n}\n```\n\n## Environment\n\n- **CIRCT Version**: firtool-1.139.0 (LLVM 22.0.0git)\n- **OS**: Linux 5.15.0 (x86_64)\n\n## Cross-Tool Validation\n\n| Tool | Version | Status | Notes |\n|------|---------|--------|-------|\n| slang | 10.0.6+3d7e6cd2e | ✅ Pass | Build succeeded: 0 errors, 0 warnings |\n| verilator | 5.022 | ✅ Pass | No errors |\n| iverilog | - | ❌ Error | \"Port with type string is not supported\" (tool limitation, not syntax error) |\n\nThis confirms the test case is **syntactically valid** SystemVerilog per IEEE 1800-2017.\n","createdAt":"2026-02-01T03:00:12Z","labels":[],"number":9572,"state":"OPEN","title":"[Moore] Assertion failure when module has string type output port","url":"https://github.com/llvm/circt/issues/9572"},{"body":"Is there a strong reason to go from PowUOp to math.ipow as opposed to lowering to a sequence of multiplications?\n\nIs there any existing lowering from math.ipow to the core dialects? \n\nhttps://github.com/llvm/circt/blob/83effb21cd6b1cebc060b4f57180f16683309cd9/lib/Conversion/MooreToCore/MooreToCore.cpp#L1379-L1398","createdAt":"2025-09-16T14:19:34Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8973,"state":"OPEN","title":"[MooreToCore] Lowering to math.ipow?","url":"https://github.com/llvm/circt/issues/8973"},{"body":"It failed when trying to compile https://github.com/pulp-platform/ELAU/blob/b0d113aff6a2d800076f5ebb84f09fba93625bc7/src/SqrtArrUns.sv#L96-L105. \n```\nmoore.module @behavioural_SqrtArrUns(in %X : !moore.l8, out Q : !moore.l4, out R : !moore.l4) {\n  %0 = moore.constant 2 : l8\n  %1 = moore.conversion %X : !moore.l8 -> !moore.real\n  %2 = moore.builtin.sqrt %1 : real\n  %3 = moore.builtin.floor %2 : real\n  %4 = moore.conversion %3 : !moore.real -> !moore.l4\n  %5 = moore.zext %4 : l4 -> l8\n  %6 = moore.powu %5, %0 : l8\n  %7 = moore.sub %X, %6 : l8\n  %8 = moore.trunc %7 : l8 -> l4\n  moore.output %4, %8 : !moore.l4, !moore.l4\n}\n```\n\n```\n[circt-verilog] Running \"convert-moore-to-core\"\ncirct-verilog: /home/uenoku/dev/circt-synth/llvm/llvm/include/llvm/Support/Casting.h:650: decltype(auto) llvm::dyn_cast(const From &) [To = mlir::IntegerType, From = mlir::Type]: Assertion `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.      Program arguments: circt-verilog ../out/SqrtArrUns_behavioral.sv -o build/SqrtArrUns_behavioral/circt/SqrtArrUns_behavioral.mlir --mlir-timing -y ../out ../ext/ELAU/src/arith_utils.sv -mlir-print-ir-after-all -verbose-pass-executions\n #0 0x00005a3051df92b8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/uenoku/dev/circt-synth/llvm/llvm/lib/Support/Unix/Signals.inc:834:13\n #1 0x00005a3051df6e93 llvm::sys::RunSignalHandlers() /home/uenoku/dev/circt-synth/llvm/llvm/lib/Support/Signals.cpp:105:18\n #2 0x00005a3051dfa051 SignalHandler(int, siginfo_t*, void*) /home/uenoku/dev/circt-synth/llvm/llvm/lib/Support/Unix/Signals.inc:426:38\n #3 0x00007ecdbca42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #4 0x00007ecdbca969fc __pthread_kill_implementation ./nptl/./nptl/pthread_kill.c:44:76\n #5 0x00007ecdbca969fc __pthread_kill_internal ./nptl/./nptl/pthread_kill.c:78:10\n #6 0x00007ecdbca969fc pthread_kill ./nptl/./nptl/pthread_kill.c:89:10\n #7 0x00007ecdbca42476 gsignal ./signal/../sysdeps/posix/raise.c:27:6\n #8 0x00007ecdbca287f3 abort ./stdlib/./stdlib/abort.c:81:7\n #9 0x00007ecdbca2871b _nl_load_domain ./intl/./intl/loadmsgcat.c:1177:9\n#10 0x00007ecdbca39e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n#11 0x00005a3050b0d8c4 decltype(auto) llvm::dyn_cast<mlir::IntegerType, mlir::Type>(mlir::Type const&) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x1ad8c4)\n#12 0x00005a3050cb10c5 decltype(auto) llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Type, long>, mlir::Type>::castValue<mlir::IntegerType, mlir::Type const&>(mlir::Type const&) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x3510c5)\n#13 0x00005a3050c9d8da llvm::TypeSwitch<mlir::Type, long>& llvm::TypeSwitch<mlir::Type, long>::Case<mlir::IntegerType, circt::hw::getBitWidth(mlir::Type)::$_0>(circt::hw::getBitWidth(mlir::Type)::$_0&&) HWTypes.cpp:0:0\n#14 0x00005a3050c9d7e6 circt::hw::getBitWidth(mlir::Type) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x33d7e6)\n#15 0x00005a30510f9908 (anonymous namespace)::ConversionOpConversion::matchAndRewrite(circt::moore::ConversionOp, circt::moore::ConversionOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n#16 0x00005a30510fa631 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::ConversionOp>, circt::moore::ConversionOp>(mlir::OpConversionPattern<circt::moore::ConversionOp> const&, circt::moore::ConversionOp, circt::moore::ConversionOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange> >, mlir::ConversionPatternRewriter&) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x79a631)\n```","createdAt":"2025-09-06T09:21:38Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8930,"state":"OPEN","title":"[MooreToCore] Crash with sqrt/floor","url":"https://github.com/llvm/circt/issues/8930"},{"body":"I'm looking into the failing testcase for `real` constants [on sv-tests-results](https://chipsalliance.github.io/sv-tests-results/?v=circt_verilog+5.7.2+real-constants). Just want to put it up here to make sure no one else has already started working on it.","createdAt":"2025-02-23T19:01:31Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8269,"state":"OPEN","title":"[MooreToCore] Support `real` constants","url":"https://github.com/llvm/circt/issues/8269"},{"body":"Add a conversion for the `moore.net` op to MooreToConv: https://chipsalliance.github.io/sv-tests-results/?v=circt_verilog+12.4+if","createdAt":"2024-09-25T03:28:07Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIx","name":"good first issue","description":"Good for newcomers","color":"7057ff"},{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":7629,"state":"OPEN","title":"[MooreToCore] Support net op","url":"https://github.com/llvm/circt/issues/7629"},{"body":"Dear @maerhart @fabianschuiki ,\r\n When lowering `SV` to `Hw` Dialect, there is a stack dump. \r\nDriver: circt-verilog %s\r\n```\r\nmodule top();\r\n  typedef struct {\r\n    int a;\r\n    int b;\r\n  } ms_t;\r\n\r\n  ms_t ms;\r\n\r\n  initial begin\r\n    ms = '{ 0, 1};\r\n\r\n    ms = '{ default:1, int:1};\r\n\r\n    ms = '{ int:0, int:1};\r\n  end\r\n\r\nendmodule\r\n```\r\nIt can be converted to `moore` Dialect like this\r\nDriver:  circt-verilog --ir-moore %s\r\n```\r\nmodule {\r\n  moore.module @top() {\r\n    %0 = moore.constant 1 : i32\r\n    %1 = moore.constant 0 : i32\r\n    %ms = moore.variable : <ustruct<{a: i32, b: i32}>>\r\n    moore.procedure initial {\r\n      %2 = moore.struct_create %1, %0 : !moore.i32, !moore.i32 -> ustruct<{a: i32, b: i32}>\r\n      moore.blocking_assign %ms, %2 : ustruct<{a: i32, b: i32}>\r\n      %3 = moore.struct_create %0, %0 : !moore.i32, !moore.i32 -> ustruct<{a: i32, b: i32}>\r\n      moore.blocking_assign %ms, %3 : ustruct<{a: i32, b: i32}>\r\n      moore.blocking_assign %ms, %3 : ustruct<{a: i32, b: i32}>\r\n      moore.return\r\n    }\r\n    moore.output\r\n  }\r\n}\r\n```\r\nBut it got stack dump when casting `hw::InOutType`. Maybe `structType` should be converted somehow.\r\nThis is part of error codes.\r\n```\r\n#19 0x00005f9660f42af4 (anonymous namespace)::OperationLegalizer::legalizeWithPattern(mlir::Operation*, mlir::ConversionPatternRewriter&) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:1958:21\r\n#20 0x00005f9660f3b100 (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:1850:17\r\n#21 0x00005f9660f3aa73 mlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:2384:26\r\n#22 0x00005f9660f3b41f mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:2436:16\r\n#23 0x00005f9660f3fdfc mlir::applyFullConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:3447:22\r\n#24 0x00005f9660f3fe9d mlir::applyFullConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:3453:10\r\n#25 0x00005f965faed60d (anonymous namespace)::MooreToCorePass::runOnOperation() /home/pluto/Documents/circt/circt/lib/Conversion/MooreToCore/MooreToCore.cpp:1398:14\r\n```","createdAt":"2024-08-20T01:51:29Z","labels":[],"number":7535,"state":"OPEN","title":"[MooreToCore] VariableOp lowered failed","url":"https://github.com/llvm/circt/issues/7535"},{"body":"Currently, CIRCT's MooreToCore pass converts unpacked arrays to packed arrays (hw::ArrayType),\nlosing the unpacked semantics.\n\nWhen we've attempted to preserve unpacked arrays by emitting hw::UnpackedArrayType,\nMLIR raises \"failed to legalize operation\" errors.\n\n## Minimal Reproduction\n\nWhen running `circt-opt` on the following input,\n\n```systemverilog\nmodule a (\n  input logic b[3:0]\n);\nendmodule\n```\n\nwe get the following result:\n\n```mlir\nmodule {\n  hw.module @a(in %b : !hw.array<4xi1>) {\n    hw.output\n  }\n}\n```\n\nas you can clearly see, the `uarray` is converted to a `array`.\n","createdAt":"2025-02-26T14:37:40Z","labels":[],"number":8276,"state":"OPEN","title":"[MooreToCore] Support for UnpackedArrayType emission","url":"https://github.com/llvm/circt/issues/8276"},{"body":"@jiahanxie353 has added the Math dialect to circt-opt in #8475. This is a great precedent to start using that dialect in the MooreToCore conversion. For example, the `moore.pow` operation could be lowered to `math.ipowi` and `math.powf` depending on its type.","createdAt":"2025-05-12T16:08:01Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIx","name":"good first issue","description":"Good for newcomers","color":"7057ff"},{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8476,"state":"OPEN","title":"[MooreToCore] Lower exponentiation to `math.ipowi`","url":"https://github.com/llvm/circt/issues/8476"},{"body":"Unsized array type in systemverilog like `OpenArrayType`, `QueueType` can't be lower to Arc Dialect, because Arc only has sized array type. \n\nCommon programming language like `Cpp` can directly call `mmap` provided by OS to get dynamic size array. I can't see this kind of ability in systemverilog.\n\nSo how to achieve that if we want to solve #8276? Can you give me some advice?","createdAt":"2025-03-04T15:38:48Z","labels":[],"number":8292,"state":"OPEN","title":"[MooreToCore] Support for Unsized Array Type","url":"https://github.com/llvm/circt/issues/8292"},{"body":"Please check this PR(https://github.com/llvm/circt/pull/8210/files) to view the details.\n\nOr for example:\n```\nmoore.module @crash(in %in0: !moore.i32, in %in1: !moore.i32) {\n  %var = moore.variable : <!moore.i32>\n  moore.procedure always_comb {\n    %0 = moore.pows %in0, %in1 : !moore.i32\n    moore.blocking_assign %var, %0 : !moore.i32\n    moore.return\n  }\n}\n```\n\n`%var` will be regarded as one member of the implicit sensitivity list. But this act is illegal❌.","createdAt":"2025-02-08T13:58:49Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8211,"state":"OPEN","title":"[MooreToCore]Unexpected observed values in llhd.wait.","url":"https://github.com/llvm/circt/issues/8211"},{"body":"The following crashes due to an unattached region when calling `getValuesToObserve`.\n\n```mlir\nmoore.module @crash(in %in0: !moore.i32, in %in1: !moore.i32) {\n  %var = moore.variable : <!moore.i32>\n  moore.procedure always_comb {\n    %0 = moore.pows %in0, %in1 : !moore.i32\n    moore.blocking_assign %var, %0 : !moore.i32\n    moore.return\n  }\n}\n```","createdAt":"2025-02-03T10:27:41Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8176,"state":"OPEN","title":"[MooreToCore] Crash when getting values to observe","url":"https://github.com/llvm/circt/issues/8176"},{"body":"In Verilog it's legal to access arrays/bitvectors out-of-bounds which will yield X or 0. Thus a lowBit attribute not within the range is allowed by `moore.extract`. This is currently lowered 1-1 to `comb.extract` which does verify that the lowBit attribute is within range. Therefore, MooreToCore needs to check if the attribute is out of bounds and lower it to a constant in that case.","createdAt":"2025-01-31T13:37:09Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8163,"state":"OPEN","title":"[MooreToCore] Out-of-bounds moore.extract lowered incorrectly","url":"https://github.com/llvm/circt/issues/8163"},{"body":"Hi! Now I try to add types and operators in sim to get the lowered operators in moore, and then lower them to llvm dialect, so that the corresponding dynamic size container can be implemented in arcilator.\n\nFirst, add IntType and RefType in sim, as well as VariableOp, BlockAssignOp, Print, ReadOp, and ConcatOp operators.\nTaking Variable as an example, creating a stringtype VariableOp in Moore will create an int type through string_constant, and then perform conversionOp to convert the int type to Stringtype, and finally create VariableOp. In sim, if VariableOp can directly accept int type, the conversion time can be saved. Therefore, I think it is not necessary to add StringType separately, and only use Int Type and RefType to represent it.\n\nIn sim to llvm dialect, VariableOp will be converted into a series of Ops. First, llvm.alloca will be used to create an i128 memory, which will be divided into i32 size to record the string length, and i96 data to record the string content. Then, llvm.getelementptrOp and llvm.storeOp are used to store the contents in the corresponding locations. This memory will be dynamically doubled according to the length of the string.\n\nCan you give me some advise?","createdAt":"2025-03-20T02:36:53Z","labels":[],"number":8332,"state":"OPEN","title":"[MooreToCore] Support for StringType from moore to llvm dialect","url":"https://github.com/llvm/circt/issues/8332"},{"body":"If I understand IEEE 1800-2017 §7.4.6 Indexing and slicing of arrays right, an unpacked array slice should be 0/X in its entirety even if only a part of the slice is OOB. Currently, only the OOB part is 0/X because they are lowered just like packed arrays.","createdAt":"2025-02-10T13:02:44Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8215,"state":"OPEN","title":"[MooreToCore] OOB array slices of unpacked arrays lowered like packed arrays","url":"https://github.com/llvm/circt/issues/8215"},{"body":"I want to support this [sv-tests-results/string_concat_op](https://chipsalliance.github.io/sv-tests-results/?v=circt_verilog+11.4.12.2+string_concat_op) feature, but not sure how to fix it properly.\n\n``` sv\nmodule top();\n\nstring str;\n\ninitial begin\n    str = \"Hello\";\nend\n\nendmodule\n```\n\n`circt-verilog`  has the following complaints when compiling the string.sv file:\n```s.sv:3:8: error: failed to legalize operation 'moore.variable'\nstring str;\n       ^\ns.sv:3:8: note: see current operation: %0 = \"moore.variable\"() <{name = \"str\"}> : () -> !moore.ref<string>\n```\n\nThis error is due to MooreToCore's lack of string-type conversion. It only has `StringConstantOpConv` and `Format*OpConversion`; none of these conversions can handle the `string` type.\n","createdAt":"2025-02-28T08:51:12Z","labels":[],"number":8283,"state":"OPEN","title":"[ImportVerilog] Cannot compile forward decleared string type","url":"https://github.com/llvm/circt/issues/8283"},{"body":"Given this module:\n\n```mlir\nmodule {\n  moore.module @test(out x : !moore.l4) {\n    %arr = moore.variable : <array<2 x array<3 x l4>>>\n    %0 = moore.read %arr : <array<2 x array<3 x l4>>>\n    %1 = moore.extract %0 from 1 : array<2 x array<3 x l4>> -> array<3 x l4>\n    %2 = moore.extract %1 from 2 : array<3 x l4> -> l4\n    moore.output %2 : !moore.l4\n  }\n}\n```\n\nHere is the result of running `MooreToCore`:\n\n```mlir\nmodule {\n  hw.module @test(out x : i4) {\n    %c0_i24 = hw.constant 0 : i24\n    %0 = hw.bitcast %c0_i24 : (i24) -> !hw.array<2xarray<3xi4>>\n    %arr = llhd.sig %0 : !hw.array<2xarray<3xi4>>\n    %1 = llhd.prb %arr : !hw.inout<array<2xarray<3xi4>>>\n    %true = hw.constant true\n    %2 = hw.array_slice %1[%true] : (!hw.array<2xarray<3xi4>>) -> !hw.array<3xi4>\n    %c-2_i2 = hw.constant -2 : i2\n    %3 = hw.array_get %2[%c-2_i2] : !hw.array<3xi4>, i2\n    hw.output %3 : i4\n  }\n}\n```\n\nIt can be seen that `%1 = moore.extract ...` was translated to `%2 = hw.array_slice ...`: `moore.extract`'s result type is an array, so it was mistaken for a slicing operation.\n\nThe resulting module is malformed and fails validation after canonicalization (due to `hw.output`'s argument not matching the output port's type).","createdAt":"2024-11-28T19:09:10Z","labels":[],"number":7918,"state":"OPEN","title":"[MooreToCore] `moore.extract` is converted to `hw.array_slice` when array's element type is also array","url":"https://github.com/llvm/circt/issues/7918"},{"body":"Hello, I'm having an issue when trying to import Verilog generated with Yosys. It leads into a combinatorial cycle that isn't present in the Verilog program.\nHere is a simple example of problematic Verilog:\n```sv\nmodule outline_control_3(output [1:0] result, input arg0);\n  assign result[1] = arg0;\n  assign result[0] = result[1];\nendmodule\n```\nWhen I import the Verilog into Moore with `./circt-translate --import-verilog test.sv` it generates the following program:\n```mlir\nmodule {\n  moore.module @outline_control_3(out result : !moore.l2, in %arg0 : !moore.l1) {\n    %result = moore.net wire : <l2>\n    %arg0_0 = moore.net name \"arg0\" wire : <l1>\n    %0 = moore.extract_ref %result from 1 : <l2> -> <l1>\n    %1 = moore.read %arg0_0 : <l1>\n    moore.assign %0, %1 : l1\n    %2 = moore.extract_ref %result from 0 : <l2> -> <l1>\n    %3 = moore.read %result : <l2>\n    %4 = moore.extract %3 from 1 : l2 -> l1\n    moore.assign %2, %4 : l1\n    %5 = moore.read %result : <l2>\n    moore.assign %arg0_0, %arg0 : l1\n    moore.output %5 : !moore.l2\n  }\n}\n```\nBut then, when I lower it into the comb/HW dialects with `./circt-translate --import-verilog test.sv | ./circt-opt --moore-lower-concatref --canonicalize --cse --convert-moore-to-core --llhd-sig2reg --canonicalize --cse`. It generates the following program:\n```mlir\nmodule {\n  hw.module @outline_control_3(out result : i2, in %arg0 : i1) {\n    %false = hw.constant false\n    %0 = comb.concat %false, %3 : i1, i1\n    %1 = comb.concat %arg0, %false : i1, i1\n    %2 = comb.or %1, %0 : i2\n    %3 = comb.extract %2 from 1 : (i2) -> i1\n    hw.output %2 : i2\n  }\n}\n```\nMy problem here is that `%3` depends on `%2`, which in turn depends on `%0`, which also depends on `%3`. As the hw.module contains a `graph` region, it doesn't seem to be an invalid MLIR program. But is it the expected behavior? There is a combinatorial cycle that wasn't present in the imported Verilog.","createdAt":"2025-10-06T12:22:11Z","labels":[{"id":"LA_kwDODpuCgs8AAAABp1j0gg","name":"ImportVerilog","description":"","color":"e99695"}],"number":9057,"state":"CLOSED","title":"[MooreToCore] Unexpected topological cycle after importing generated verilog","url":"https://github.com/llvm/circt/issues/9057"},{"body":"Lowering the following with `circt-verilog`\n```sv\nmodule combo (  input   a, b, c, d, e,  output  reg z);\n\n        always @ (*) begin\n                z = ((a & b) | (c ^ d) & ~e);\n        end\n\nendmodule\n```\nresults in this MLIR:\n```mlir\n  hw.module @combo(in %a : i1, in %b : i1, in %c : i1, in %d : i1, in %e : i1, out z : i1) {\n    %0 = llhd.constant_time <0ns, 0d, 1e>\n    %true = hw.constant true\n    %false = hw.constant false\n    %a_0 = llhd.sig name \"a\" %false : i1\n    %1 = llhd.prb %a_0 : !hw.inout<i1>\n    %b_1 = llhd.sig name \"b\" %false : i1\n    %2 = llhd.prb %b_1 : !hw.inout<i1>\n    %c_2 = llhd.sig name \"c\" %false : i1\n    %3 = llhd.prb %c_2 : !hw.inout<i1>\n    %d_3 = llhd.sig name \"d\" %false : i1\n    %4 = llhd.prb %d_3 : !hw.inout<i1>\n    %e_4 = llhd.sig name \"e\" %false : i1\n    %5 = llhd.prb %e_4 : !hw.inout<i1>\n    %z = llhd.sig %false : i1\n    llhd.process {\n      cf.br ^bb1\n    ^bb1:  // 3 preds: ^bb0, ^bb2, ^bb3\n      %7 = llhd.prb %a_0 : !hw.inout<i1>\n      %8 = llhd.prb %b_1 : !hw.inout<i1>\n      %9 = llhd.prb %c_2 : !hw.inout<i1>\n      %10 = llhd.prb %d_3 : !hw.inout<i1>\n      %11 = llhd.prb %e_4 : !hw.inout<i1>\n      llhd.wait (%1, %2, %3, %4, %5 : i1, i1, i1, i1, i1), ^bb2\n    ^bb2:  // pred: ^bb1\n      %12 = llhd.prb %a_0 : !hw.inout<i1>\n      %13 = comb.icmp bin ne %7, %12 : i1\n      %14 = llhd.prb %b_1 : !hw.inout<i1>\n      %15 = comb.icmp bin ne %8, %14 : i1\n      %16 = llhd.prb %c_2 : !hw.inout<i1>\n      %17 = comb.icmp bin ne %9, %16 : i1\n      %18 = llhd.prb %d_3 : !hw.inout<i1>\n      %19 = comb.icmp bin ne %10, %18 : i1\n      %20 = llhd.prb %e_4 : !hw.inout<i1>\n      %21 = comb.icmp bin ne %11, %20 : i1\n      %22 = comb.or bin %13, %15, %17, %19, %21 : i1\n      cf.cond_br %22, ^bb3, ^bb1\n    ^bb3:  // pred: ^bb2\n      %23 = llhd.prb %a_0 : !hw.inout<i1>\n      %24 = llhd.prb %b_1 : !hw.inout<i1>\n      %25 = comb.and %23, %24 : i1\n      %26 = llhd.prb %c_2 : !hw.inout<i1>\n      %27 = llhd.prb %d_3 : !hw.inout<i1>\n      %28 = comb.xor %26, %27 : i1\n      %29 = llhd.prb %e_4 : !hw.inout<i1>\n      %30 = comb.xor %29, %true : i1\n      %31 = comb.and %28, %30 : i1\n      %32 = comb.or %25, %31 : i1\n      llhd.drv %z, %32 after %0 : !hw.inout<i1>\n      cf.br ^bb1\n    }\n    llhd.drv %a_0, %a after %0 : !hw.inout<i1>\n    llhd.drv %b_1, %b after %0 : !hw.inout<i1>\n    llhd.drv %c_2, %c after %0 : !hw.inout<i1>\n    llhd.drv %d_3, %d after %0 : !hw.inout<i1>\n    llhd.drv %e_4, %e after %0 : !hw.inout<i1>\n    %6 = llhd.prb %z : !hw.inout<i1>\n    hw.output %6 : i1\n  }\n```\n\n`%22` will always evaluate to `true` because the wait operation will only branch if one of its sensitivity values changes. We should add a folder/canonicalizer that performs this simplification.\n\nThe code responsible for generating this pattern is in MooreToCore in the WaitEventOp lowering pattern.","createdAt":"2024-12-22T12:56:02Z","labels":[{"id":"MDU6TGFiZWwyMTY1NDc5NTk1","name":"LLHD","description":"","color":"e07b00"}],"number":8013,"state":"OPEN","title":"[LLHD] Canonicalizer for processes produced by always @(*)","url":"https://github.com/llvm/circt/issues/8013"}]
[{"body":"## Bug Description\n\n`circt-verilog` crashes with an assertion failure when processing a SystemVerilog module that has a `string` type output port. The crash occurs during the MooreToCore conversion pass when the `getModulePortInfo()` function fails to properly handle cases where type conversion returns an invalid/empty type, causing a `dyn_cast` assertion failure in `ModulePortInfo::sanitizeInOut()`.\n\nThis is a valid SystemVerilog construct per IEEE 1800-2017 Section 6.16 (String data type). Both **slang** and **verilator** accept the code without errors.\n\n## Steps to Reproduce\n\n1. Save the following test case as `bug.sv`\n2. Run: `circt-verilog --ir-hw bug.sv`\n\n## Test Case\n\n```systemverilog\nmodule test_module(output string a);\nendmodule\n```\n\n## Expected Behavior\n\nCIRCT should either:\n1. Support simulation constructs like string ports appropriately, OR\n2. Emit a proper diagnostic error message indicating that string ports are not supported for hardware synthesis\n\n## Actual Behavior\n\nThe tool crashes with an assertion failure:\n\n```\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: circt-verilog --ir-hw bug.sv\n #0 0x00007fe810a738a8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x2008a8)\n #1 0x00007fe810a712f5 llvm::sys::RunSignalHandlers() (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x1fe2f5)\n #2 0x00007fe810a74631 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x00007fe810581330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #4 0x00007fe814c958ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007fe814c95b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007fe814c95530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n #7 0x00007fe812fa7438 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2a438)\n #8 0x00007fe812f718ed void llvm::function_ref<void ()>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_0>(long) PatternApplicator.cpp:0:0\n #9 0x00007fe812f6e774 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/opt/firtool-1.139.0/bin/../lib/libMLIRRewrite.so+0x7774)\n#10 0x00007fe812fa8c6f (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*) DialectConversion.cpp:0:0\n#11 0x00007fe812fa8470 mlir::OperationConverter::convert(mlir::Operation*, bool) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2b470)\n#12 0x00007fe812fa8dae mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2bdae)\n#13 0x00007fe812fb68e4 void llvm::function_ref<void ()>::callback_fn<applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode)::$_0>(long) DialectConversion.cpp:0:0\n#14 0x00007fe812fadf7d applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode) DialectConversion.cpp:0:0\n#15 0x00007fe812fae0fe mlir::applyFullConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x310fe)\n#16 0x00007fe814c67231 (anonymous namespace)::MooreToCorePass::runOnOperation() MooreToCore.cpp:0:0\n#17 0x00007fe812d632a5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x172a5)\n#18 0x00007fe812d667a9 mlir::PassManager::run(mlir::Operation*) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x1a7a9)\n#19 0x0000561bab9605d0 executeWithSources(mlir::MLIRContext*, llvm::SourceMgr&) circt-verilog.cpp:0:0\n#20 0x0000561bab95bdd5 execute(mlir::MLIRContext*) circt-verilog.cpp:0:0\n#21 0x0000561bab95b4b8 main (/opt/firtool-1.139.0/bin/circt-verilog+0x84b8)\n#22 0x00007fe8105661ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#23 0x00007fe81056628b call_init ./csu/../csu/libc-start.c:128:20\n#24 0x00007fe81056628b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#25 0x0000561bab95ab05 _start (/opt/firtool-1.139.0/bin/circt-verilog+0x7b05)\n\n```\n\n## Root Cause Analysis\n\n### Crash Location\n- **File**: `lib/Conversion/MooreToCore/MooreToCore.cpp`\n- **Function**: `getModulePortInfo()` → calls `ModulePortInfo::sanitizeInOut()`\n- **Assertion**: `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"`\n\n### Analysis\n\nThe root cause is **missing validation of type conversion result** in `getModulePortInfo()`:\n\n```cpp\n// MooreToCore.cpp:233-259\nstatic hw::ModulePortInfo getModulePortInfo(const TypeConverter &typeConverter,\n                                            SVModuleOp op) {\n  // ...\n  for (auto port : moduleTy.getPorts()) {\n    Type portTy = typeConverter.convertType(port.type);  // <-- May return empty Type!\n    // ...\n    ports.push_back(hw::PortInfo({{port.name, portTy, port.dir}, ...}));  // <-- Stores empty Type\n  }\n  return hw::ModulePortInfo(ports);  // <-- Constructor calls sanitizeInOut()\n}\n```\n\nWhen `typeConverter.convertType()` fails for the `string` port type (returns empty `Type`), this invalid type is passed to `sanitizeInOut()` which calls `dyn_cast<hw::InOutType>(p.type)` on the empty type, triggering the assertion.\n\n### Suggested Fix\n\nAdd validation in `getModulePortInfo()` to check if `typeConverter.convertType()` returns a valid type:\n\n```cpp\nType portTy = typeConverter.convertType(port.type);\nif (!portTy) {\n  // Emit proper diagnostic error\n  return failure();\n}\n```\n\n## Environment\n\n- **CIRCT Version**: firtool-1.139.0 (LLVM 22.0.0git)\n- **OS**: Linux 5.15.0 (x86_64)\n\n## Cross-Tool Validation\n\n| Tool | Version | Status | Notes |\n|------|---------|--------|-------|\n| slang | 10.0.6+3d7e6cd2e | ✅ Pass | Build succeeded: 0 errors, 0 warnings |\n| verilator | 5.022 | ✅ Pass | No errors |\n| iverilog | - | ❌ Error | \"Port with type string is not supported\" (tool limitation, not syntax error) |\n\nThis confirms the test case is **syntactically valid** SystemVerilog per IEEE 1800-2017.\n","createdAt":"2026-02-01T03:00:12Z","labels":[],"number":9572,"state":"OPEN","title":"[Moore] Assertion failure when module has string type output port","url":"https://github.com/llvm/circt/issues/9572"},{"body":"It failed when trying to compile https://github.com/pulp-platform/ELAU/blob/b0d113aff6a2d800076f5ebb84f09fba93625bc7/src/SqrtArrUns.sv#L96-L105. \n```\nmoore.module @behavioural_SqrtArrUns(in %X : !moore.l8, out Q : !moore.l4, out R : !moore.l4) {\n  %0 = moore.constant 2 : l8\n  %1 = moore.conversion %X : !moore.l8 -> !moore.real\n  %2 = moore.builtin.sqrt %1 : real\n  %3 = moore.builtin.floor %2 : real\n  %4 = moore.conversion %3 : !moore.real -> !moore.l4\n  %5 = moore.zext %4 : l4 -> l8\n  %6 = moore.powu %5, %0 : l8\n  %7 = moore.sub %X, %6 : l8\n  %8 = moore.trunc %7 : l8 -> l4\n  moore.output %4, %8 : !moore.l4, !moore.l4\n}\n```\n\n```\n[circt-verilog] Running \"convert-moore-to-core\"\ncirct-verilog: /home/uenoku/dev/circt-synth/llvm/llvm/include/llvm/Support/Casting.h:650: decltype(auto) llvm::dyn_cast(const From &) [To = mlir::IntegerType, From = mlir::Type]: Assertion `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.      Program arguments: circt-verilog ../out/SqrtArrUns_behavioral.sv -o build/SqrtArrUns_behavioral/circt/SqrtArrUns_behavioral.mlir --mlir-timing -y ../out ../ext/ELAU/src/arith_utils.sv -mlir-print-ir-after-all -verbose-pass-executions\n #0 0x00005a3051df92b8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/uenoku/dev/circt-synth/llvm/llvm/lib/Support/Unix/Signals.inc:834:13\n #1 0x00005a3051df6e93 llvm::sys::RunSignalHandlers() /home/uenoku/dev/circt-synth/llvm/llvm/lib/Support/Signals.cpp:105:18\n #2 0x00005a3051dfa051 SignalHandler(int, siginfo_t*, void*) /home/uenoku/dev/circt-synth/llvm/llvm/lib/Support/Unix/Signals.inc:426:38\n #3 0x00007ecdbca42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #4 0x00007ecdbca969fc __pthread_kill_implementation ./nptl/./nptl/pthread_kill.c:44:76\n #5 0x00007ecdbca969fc __pthread_kill_internal ./nptl/./nptl/pthread_kill.c:78:10\n #6 0x00007ecdbca969fc pthread_kill ./nptl/./nptl/pthread_kill.c:89:10\n #7 0x00007ecdbca42476 gsignal ./signal/../sysdeps/posix/raise.c:27:6\n #8 0x00007ecdbca287f3 abort ./stdlib/./stdlib/abort.c:81:7\n #9 0x00007ecdbca2871b _nl_load_domain ./intl/./intl/loadmsgcat.c:1177:9\n#10 0x00007ecdbca39e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n#11 0x00005a3050b0d8c4 decltype(auto) llvm::dyn_cast<mlir::IntegerType, mlir::Type>(mlir::Type const&) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x1ad8c4)\n#12 0x00005a3050cb10c5 decltype(auto) llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Type, long>, mlir::Type>::castValue<mlir::IntegerType, mlir::Type const&>(mlir::Type const&) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x3510c5)\n#13 0x00005a3050c9d8da llvm::TypeSwitch<mlir::Type, long>& llvm::TypeSwitch<mlir::Type, long>::Case<mlir::IntegerType, circt::hw::getBitWidth(mlir::Type)::$_0>(circt::hw::getBitWidth(mlir::Type)::$_0&&) HWTypes.cpp:0:0\n#14 0x00005a3050c9d7e6 circt::hw::getBitWidth(mlir::Type) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x33d7e6)\n#15 0x00005a30510f9908 (anonymous namespace)::ConversionOpConversion::matchAndRewrite(circt::moore::ConversionOp, circt::moore::ConversionOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n#16 0x00005a30510fa631 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::ConversionOp>, circt::moore::ConversionOp>(mlir::OpConversionPattern<circt::moore::ConversionOp> const&, circt::moore::ConversionOp, circt::moore::ConversionOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange> >, mlir::ConversionPatternRewriter&) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x79a631)\n```","createdAt":"2025-09-06T09:21:38Z","labels":[{"id":"LA_kwDODpuCgs7olJFv","name":"Moore","description":"","color":"04673D"}],"number":8930,"state":"OPEN","title":"[MooreToCore] Crash with sqrt/floor","url":"https://github.com/llvm/circt/issues/8930"},{"body":"@seldridge did some digging:\n\nThe issue appears to be that we have an i8 attribute and it is being converted to an APSInt:\n\n```\n[firtool]   Running \"firrtl-imconstprop\"\nAssertion failed: (!getType().isSignlessInteger() && \"Signless integers don't carry a sign for APSInt\"), function getAPSInt, file BuiltinAttributes.cpp, line 376.\nProcess 26737 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = hit program assert\n    frame #4: 0x0000000100c0eeb8 firtool`mlir::IntegerAttr::getAPSInt() const (.cold.1) at BuiltinAttributes.cpp:375:3 [opt]\n   372 \t/// Return the value as an APSInt which carries the signed from the type of\n   373 \t/// the attribute.  This traps on signless integers types!\n   374 \tAPSInt IntegerAttr::getAPSInt() const {\n-> 375 \t  assert(!getType().isSignlessInteger() &&\n   376 \t         \"Signless integers don't carry a sign for APSInt\");\n   377 \t  return APSInt(getValue(), getType().isUnsignedInteger());\n   378 \t}\nTarget 0: (firtool) stopped.\nwarning: firtool was compiled with optimization - stepping may behave oddly; variables may not be available.\n(lldb) frame select 6\nframe #6: 0x000000010062b1b4 firtool`circt::firrtl::IntegerAddOp::fold(circt::firrtl::IntegerAddOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>) at FIRRTLFolds.cpp:176:17 [opt]\n   173 \t  if (auto attr = dyn_cast<BoolAttr>(operand))\n   174 \t    return APSInt(APInt(1, attr.getValue()));\n   175 \t  if (auto attr = dyn_cast<IntegerAttr>(operand))\n-> 176 \t    return attr.getAPSInt();\n   177 \t  return {};\n   178 \t}\n   179 \t\n(lldb) print attr\n(mlir::IntegerAttr) {\n  mlir::Attribute::AttrBase<IntegerAttr, ::mlir::Attribute, detail::IntegerAttrStorage, mlir::TypedAttr::Trait> = {\n    mlir::Attribute = {\n      impl = 0x000000011c714548\n    }\n  }\n}\n(lldb) print attr->dump()\n2 : i8\n  Evaluated this expression after applying Fix-It(s):\n    attr.dump()\n```","createdAt":"2025-02-23T04:02:57Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":8266,"state":"OPEN","title":"[FIRRTL] Integer Property folders assert in getAPSInt","url":"https://github.com/llvm/circt/issues/8266"},{"body":"## Description\n\nCIRCT crashes with assertion `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"` when compiling SystemVerilog modules that use packed union types as module ports.\n\n**Likely cause**: MooreToCore conversion pass lacks a type conversion rule for packed union types (`UnionType`). When processing module ports, the type converter fails to convert `UnionType`, resulting in an invalid/null type that causes assertion failures in downstream port processing code (`getModulePortInfo` at line 259).\n\n> **Validation**: Test case accepted by: verilator, iverilog, slang\n> **IEEE 1800-2005**: Packed unions are valid (Section 7.3)\n\n## Steps to Reproduce\n\n1. Save following code as `bug.sv`\n2. Run: `circt-verilog --ir-hw bug.sv`\n\n## Test Case\n\n```systemverilog\ntypedef union packed {\n  logic [31:0] a;\n  logic [31:0] b;\n} my_union;\n\nmodule Sub(input my_union in_val, output my_union out_val);\n  assign out_val = in_val;\nendmodule\n\nmodule Top;\n  my_union data_in, data_out;\n  \n  Sub s(.in_val(data_in), .out_val(data_out));\nendmodule\n```\n\n## Error Output\n\n```\n #4 0x00007f8176f898ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007f8176f89b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007f8176f89530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n```\n\n<details>\n<summary>Full Stack Trace</summary>\n\n```\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.      Program arguments: /opt/firtool/bin/circt-verilog --ir-hw bug.sv\n #0 0x00007f8172d678a8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x2008a8)\n #1 0x00007f8172d652f5 llvm::sys::RunSignalHandlers() (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x1fe2f5)\n #2 0x00007f8172d68631 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x00007f8172875330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #4 0x00007f8176f898ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007f8176f89b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007f8176f89530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n #7 0x00007f817529b438 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2a438)\n #8 0x00007f81752658ed void llvm::function_ref<void ()>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_0>(long) PatternApplicator.cpp:0:0\n #9 0x00007f8175262774 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/opt/firtool-1.139.0/bin/../lib/libMLIRRewrite.so+0x7774)\n#10 0x00007f817529cc6f (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*) DialectConversion.cpp:0:0\n#11 0x00007f817529c470 mlir::OperationConverter::convert(mlir::Operation*, bool) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2b470)\n#12 0x00007f817529cdae mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2bdae)\n#13 0x00007f81752aa8e4 void llvm::function_ref<void ()>::callback_fn<applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode)::$_0>(long) DialectConversion.cpp:0:0\n#14 0x00007f81752a1f7d applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode) DialectConversion.cpp:0:0\n#15 0x00007f81752a20fe mlir::applyFullConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x310fe)\n#16 0x00007f8176f5b231 (anonymous namespace)::MooreToCorePass::runOnOperation() MooreToCore.cpp:0:0\n#17 0x00007f81750572a5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x172a5)\n#18 0x00007f817505a7a9 mlir::PassManager::run(mlir::Operation*) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x1a7a9)\n#19 0x0000563df3daf5d0 executeWithSources(mlir::MLIRContext*, llvm::SourceMgr&) circt-verilog.cpp:0:0\n#20 0x0000563df3daadd5 execute(mlir::MLIRContext*) circt-verilog.cpp:0:0\n#21 0x0000563df3daa4b8 main (/opt/firtool/bin/circt-verilog+0x84b8)\n#22 0x00007f817285a1ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#23 0x00007f817285a28b call_init ./csu/../csu/libc-start.c:128:20\n#24 0x00007f817285a28b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#25 0x0000563df3da9b05 _start (/opt/firtool/bin/circt-verilog+0x7b05)\n[1]    1143009 segmentation fault (core dumped)  /opt/firtool/bin/circt-verilog --ir-hw bug.sv\n\n```\n\n</details>\n\n## Root Cause Analysis\n\n- **Dialect**: Moore\n- **Failing Pass**: MooreToCore\n\n### Hypotheses\n\n1. **Missing UnionType type conversion rule** (confidence: high)\n   - Evidence: [\"Test case uses 'typedef union packed' as module port type\", 'Stack trace shows crash in getModulePortInfo during port processing at line 259', \"Assertion message indicates 'dyn_cast<InOutType>' failed on non-existent value\", 'No conversion rule for UnionType exists in populateTypeConversion function (lines 2268-2409)', 'Similar types like StructType have conversion rules, but UnionType does not', 'Both UnionType and StructType implement DestructurableTypeInterface, suggesting they should be handled similarly']\n   - Mechanism: The typeConverter fails to convert UnionType when processing module ports, resulting in an invalid type that causes assertion failures\n\n2. **Type converter returns invalid non-null type** (confidence: medium)\n   - Evidence: [\"Line 245-248 checks 'if (!portTy)' and emits error\", 'However, crash still occurs, suggesting either the check is not being reached or the type is non-null but invalid', 'The assertion occurs in a different code path that may not be covered by the initial null check']\n   - Mechanism: The typeConverter may return a non-null type with incorrect MLIR type ID or metadata\n\n## Environment\n\n- **CIRCT Version**: LLVM (http://llvm.org/):\n  LLVM version 22.0.0git\n  Optimized build.\nCIRCT firtool-1.139.0\nslang version 9.1.0+0\n\n---\n**Labels**: bug, Moore","createdAt":"2026-02-01T02:15:22Z","labels":[],"number":9570,"state":"OPEN","title":"[Moore] Assertion in MooreToCore when module uses packed union type as port","url":"https://github.com/llvm/circt/issues/9570"},{"body":"The `EmitHGLDD` target can emit the necessary HGLDD JSON bits to encode arrays and structs when it sees `dbg.array` and `dbg.struct` operations, but it ignores `dbg.variable` ops with `!hw.array` and `!hw.struct` types. Supporting these native HW types and creating the corresponding JSON structures should be fairly straightforward.","createdAt":"2024-03-12T16:04:40Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIx","name":"good first issue","description":"Good for newcomers","color":"7057ff"},{"id":"LA_kwDODpuCgs8AAAABa7cUEg","name":"Debug","description":"","color":"D4C5F9"}],"number":6816,"state":"OPEN","title":"[HGLDD] Emit HW struct and array types","url":"https://github.com/llvm/circt/issues/6816"},{"body":"This results in Arcilator being unable to perform effective reset grouping in the GroupResetAndEnable pass.\n\n```c\n      // Canonicalize registers.\n      if (auto reg = dyn_cast<seq::FirRegOp>(&op)) {\n        OpBuilder builder(reg);\n        Value next;\n        // Note: this register will have an sync reset regardless.\n        if (reg.hasReset())\n          next = comb::MuxOp::create(builder, reg.getLoc(), reg.getReset(),\n                                     reg.getResetValue(), reg.getNext(), false);\n        else\n          next = reg.getNext();\n\n        Value presetValue;\n        // Materialize initial value, assume zero initialization as default.\n        if (reg.getPreset() && !reg.getPreset()->isZero()) {\n          assert(hw::type_isa<IntegerType>(reg.getType()) &&\n                 \"cannot lower non integer preset\");\n          presetValue = circt::seq::createConstantInitialValue(\n              builder, reg.getLoc(),\n              IntegerAttr::get(reg.getType(), *reg.getPreset()));\n        }\n\n        Value compReg = seq::CompRegOp::create(\n            builder, reg.getLoc(), next.getType(), next, reg.getClk(),\n            reg.getNameAttr(), Value{}, Value{}, /*initialValue*/ presetValue,\n            reg.getInnerSymAttr());\n        reg.replaceAllUsesWith(compReg);\n        opsToDelete.push_back(reg);\n        continue;\n      }\n```","createdAt":"2025-12-08T02:11:40Z","labels":[{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":9310,"state":"CLOSED","title":"[arcilator] Why use a Mux to reset a register, instead of creating a CompRegOp with the reset signal and the reset value?","url":"https://github.com/llvm/circt/issues/9310"},{"body":"```bash\n\n$ cat test.fir\nFIRRTL version 4.0.0\ncircuit Foo: %[[\n  {\n    \"class\": \"sifive.enterprise.firrtl.MarkDUTAnnotation\",\n    \"target\": \"~Foo|Bar\"\n  }\n]]\n  module Baz:\n    wire a: UInt<1>\n    invalidate a\n  module Bar:\n    inst baz of Baz\n  public module Foo:\n    inst bar of Bar\n\n$ firtool test.fir  -ir-fir  | grep \"dutNLA\" -a1\n  firrtl.circuit \"Foo\" {\n    hw.hierpath private @dutNLA [@Foo::@sym]\n    firrtl.module @Bar() attributes {annotations = [{class = \"sifive.enterprise.firrtl.MarkDUTAnnotation\"}]} {\n--\n    firrtl.module @Foo(out %metadataObj: !firrtl.anyref) attributes {convention = #firrtl<convention scalarized>} {\n      firrtl.instance bar sym @sym {annotations = [{circt.nonlocal = @dutNLA, class = \"circt.tracker\", id = distinct[0]<>}]} @Bar()\n      %sifive_metadata = firrtl.object @SiFive_Metadata(out dutModulePath_field_0: !firrtl.list<path>)\n\n$ firtool test.fir  -ir-fir | circt-opt -firrtl-inliner  | grep \"dutNLA\" -a1\n    firrtl.module @Foo(out %metadataObj: !firrtl.anyref) attributes {convention = #firrtl<convention scalarized>} {\n      firrtl.instance bar sym @sym {annotations = [{circt.nonlocal = @dutNLA, class = \"circt.tracker\", id = distinct[0]<>}]} @Bar()\n      %sifive_metadata = firrtl.object @SiFive_Metadata(out dutModulePath_field_0: !firrtl.list<path>)\n\n\n# Cause crash when running LowerClass\n$ firtool test.fir  -ir-fir | circt-opt -firrtl-inliner  -firrtl-lower-classes\ncirct-opt: /scratch/hidetou/circt-synth/llvm/llvm/include/llvm/Support/Casting.h:656: decltype(auto) llvm::dyn_cast(From*) [with To = circt::hw::HierPathOp; From = mlir::Operation]: Assertion `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.      Program arguments: ./build/bin/circt-opt -firrtl-inliner -firrtl-lower-classes\n #0 0x00000000015c713b llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /scratch/hidetou/circt-synth/llvm/llvm/lib/Support/Unix/Signals.inc:838:3\n #1 0x00000000015c401b llvm::sys::RunSignalHandlers() /scratch/hidetou/circt-synth/llvm/llvm/lib/Support/Signals.cpp:104:20\n #2 0x00000000015c478a SignalHandler(int, siginfo_t*, void*) /scratch/hidetou/circt-synth/llvm/llvm/lib/Support/Unix/Signals.inc:426:14\n #3 0x00007f7346d07990 __restore_rt (/lib64/libpthread.so.0+0x12990)\n #4 0x00007f7345da252f raise (/lib64/libc.so.6+0x4e52f)\n #5 0x00007f7345d75e65 abort (/lib64/libc.so.6+0x21e65)\n #6 0x00007f7345d75d39 _nl_load_domain.cold.0 (/lib64/libc.so.6+0x21d39)\n #7 0x00007f7345d9ae86 (/lib64/libc.so.6+0x46e86)\n #8 0x0000000001dfb6f9 llvm::ArrayRef<mlir::Attribute>::drop_front(unsigned long) const /scratch/hidetou/circt-synth/llvm/llvm/include/llvm/ADT/ArrayRef.h:196:7\n #9 0x0000000001dfb6f9 llvm::ArrayRef<mlir::Attribute>::drop_front(unsigned long) const /scratch/hidetou/circt-synth/llvm/llvm/include/llvm/ADT/ArrayRef.h:195:17\n#10 0x0000000001dfb6f9 (anonymous namespace)::PathTracker::processPathTrackers(circt::firrtl::AnnoTarget const&)::'lambda'(circt::firrtl::Annotation)::operator()(circt::firrtl::Annotation) const /scratch/hidetou/circt-synth/lib/Dialect/FIRRTL/Transforms/LowerClasses.cpp:630:78\n#11 0x0000000001c85ef7 circt::firrtl::AnnotationSet::removeAnnotations(llvm::function_ref<bool (circt::firrtl::Annotation)>) /scratch/hidetou/circt-synth/lib/Dialect/FIRRTL/FIRRTLAnnotations.cpp:266:28\n#12 0x0000000001dd8f9c (anonymous namespace)::PathTracker::processPathTrackers(circt::firrtl::AnnoTarget const&) /scratch/hidetou/circt-synth/lib/Dialect/FIRRTL/Transforms/LowerClasses.cpp:696:3\n#13 0x0000000001dedd65 operator() /scratch/hidetou/circt-synth/lib/Dialect/FIRRTL/Transforms/LowerClasses.cpp:454:36\n```","createdAt":"2025-12-09T01:04:29Z","labels":[],"number":9315,"state":"CLOSED","title":"[FIRRTL] ModuleInliner removes NLA referred by circt.tracker","url":"https://github.com/llvm/circt/issues/9315"},{"body":"fstring type would never be on port from the current fir parser but it crashes at LowerToHW:\n\n```mlir\nfirrtl.circuit \"Printf\"{\n  // CHECK-LABEL: module Printf\n  firrtl.module @Printf(in %clock: !firrtl.fstring) attributes {convention = #firrtl<convention scalarized>} {\n  }\n}\n```\n\n```\n$  firtool bar.mlir\n\nfirtool: /scratch/hidetou/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:2562: llvm::LogicalResult (anonymous namespace)::FIRRTLLowering::setLowering(mlir::Value, mlir::Value): Assertion `(!result || !type_isa<FIRRTLType>(result.getType())) && \"Lowering didn't turn a FIRRTL value into a non-FIRRTL value\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.      Program arguments: ./build/bin/firtool bar.mlir\n #0 0x00000000007ceb97 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:804:13\n #1 0x00000000007ccad0 llvm::sys::RunSignalHandlers() /scratch/hidetou/circt/llvm/llvm/lib/Support/Signals.cpp:106:18\n #2 0x00000000007cf4aa SignalHandler(int, siginfo_t*, void*) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3\n #3 0x00007f083c2b1cf0 __restore_rt (/lib64/libpthread.so.0+0x12cf0)\n #4 0x00007f083b36aacf raise (/lib64/libc.so.6+0x4eacf)\n #5 0x00007f083b33dea5 abort (/lib64/libc.so.6+0x21ea5)\n #6 0x00007f083b33dd79 _nl_load_domain.cold.0 (/lib64/libc.so.6+0x21d79)\n #7 0x00007f083b363426 (/lib64/libc.so.6+0x47426)\n #8 0x0000000000d2176a decltype(auto) llvm::dyn_cast<circt::firrtl::LHSType, mlir::Type>(mlir::Type const&) /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/Casting.h:650:3\n #9 0x0000000000d2176a decltype(auto) llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Type, circt::firrtl::FIRRTLBaseType>, mlir::Type>::castValue<circt::firrtl::LHSType, mlir::Type const&>(mlir::Type const&) /scratch/hidetou/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:67:12\n#10 0x0000000000d2176a llvm::TypeSwitch<mlir::Type, circt::firrtl::FIRRTLBaseType>& llvm::TypeSwitch<mlir::Type, circt::firrtl::FIRRTLBaseType>::Case<circt::firrtl::LHSType, circt::firrtl::getBaseType(mlir::Type)::'lambda0'(auto)>(circt::firrtl::getBaseType(mlir::Type)::'lambda0'(auto)&&) /scratch/hidetou/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:101:26\n#11 0x0000000000d2176a circt::firrtl::getBaseType(mlir::Type) /scratch/hidetou/circt/include/circt/Dialect/FIRRTL/FIRRTLUtils.h:225:8\n#12 0x0000000000d2176a (anonymous namespace)::FIRRTLLowering::setLowering(mlir::Value, mlir::Value) /scratch/hidetou/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:2565:21\n#13 0x0000000000d1ee1f llvm::LogicalResult::failed() const /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:43:43\n#14 0x0000000000d1ee1f llvm::failed(llvm::LogicalResult) /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:71:58\n#15 0x0000000000d1ee1f (anonymous namespace)::FIRRTLLowering::run() /scratch/hidetou/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1985:9\n#16 0x0000000000d1ee1f (anonymous namespace)::FIRRTLModuleLowering::lowerModuleOperations(circt::hw::HWModuleOp, (anonymous namespace)::CircuitLoweringState&) /scratch/hidetou/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1977:48\n#17 0x0000000000d152a8 llvm::LogicalResult::failed() const /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:43:43\n#18 0x0000000000d152a8 llvm::failed(llvm::LogicalResult) /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:71:58\n#19 0x0000000000d152a8 llvm::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_10>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_10&&) /scratch/hidetou/circt/llvm/llvm/../mlir/include/mlir/IR/Threading.h:46:11\n#20 0x0000000000d152a8 llvm::LogicalResult mlir::failableParallelForEach<llvm::iota_range<unsigned long>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_10>(mlir::MLIRContext*, llvm::iota_range<unsigned long>&&, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_10&&) /scratch/hidetou/circt/llvm/llvm/../mlir/include/mlir/IR/Threading.h:92:10\n#21 0x0000000000d152a8 llvm::LogicalResult mlir::failableParallelForEachN<(anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_10>(mlir::MLIRContext*, unsigned long, unsigned long, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_10&&) /scratch/hidetou/circt/llvm/llvm/../mlir/include/mlir/IR/Threading.h:107:10\n#22 0x0000000000d152a8 (anonymous namespace)::FIRRTLModuleLowering::runOnOperation() /scratch/hidetou/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:753:17\n#23 0x000000000148cff9 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_7::operator()() const /scratch/hidetou/circt/llvm/mlir/lib/Pass/Pass.cpp:0:17\n#24 0x000000000148cff9 void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_7>(long) /scratch/hidetou/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:46:12\n#25 0x000000000148cff9 llvm::function_ref<void ()>::operator()() const /scratch/hidetou/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:69:12\n#26 0x000000000148cff9 void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(llvm::function_ref<void ()>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) /scratch/hidetou/circt/llvm/mlir/include/mlir/IR/MLIRContext.h:288:7\n#27 0x000000000148cff9 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /scratch/hidetou/circt/llvm/mlir/lib/Pass/Pass.cpp:520:21\n#28 0x000000000148fdbf llvm::LogicalResult::failed() const /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:43:43\n#29 0x000000000148fdbf llvm::failed(llvm::LogicalResult) /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:71:58\n#30 0x000000000148fdbf mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /scratch/hidetou/circt/llvm/mlir/lib/Pass/Pass.cpp:592:9\n#31 0x000000000148fdbf mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /scratch/hidetou/circt/llvm/mlir/lib/Pass/Pass.cpp:905:10\n#32 0x000000000148fdbf mlir::PassManager::run(mlir::Operation*) /scratch/hidetou/circt/llvm/mlir/lib/Pass/Pass.cpp:885:60\n#33 0x0000000000758686 llvm::LogicalResult::failed() const /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:43:43\n#34 0x0000000000758686 llvm::failed(llvm::LogicalResult) /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:71:58\n#35 0x0000000000758686 processBuffer(mlir::MLIRContext&, circt::firtool::FirtoolOptions&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /scratch/hidetou/circt/tools/firtool/firtool.cpp:561:7\n#36 0x00000000007572fb processInputSplit(mlir::MLIRContext&, circt::firtool::FirtoolOptions&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /scratch/hidetou/circt/tools/firtool/firtool.cpp:619:12\n#37 0x0000000000752e60 processInput(mlir::MLIRContext&, circt::firtool::FirtoolOptions&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /scratch/hidetou/circt/tools/firtool/firtool.cpp:635:12\n#38 0x0000000000752e60 executeFirtool(mlir::MLIRContext&, circt::firtool::FirtoolOptions&) /scratch/hidetou/circt/tools/firtool/firtool.cpp:727:14\n#39 0x0000000000751288 llvm::LogicalResult::failed() const /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:43:43\n#40 0x0000000000751288 llvm::failed(llvm::LogicalResult) /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:71:58\n#41 0x0000000000751288 main /scratch/hidetou/circt/tools/firtool/firtool.cpp:822:8\n#42 0x00007f083b356d85 __libc_start_main (/lib64/libc.so.6+0x3ad85)\n#43 0x000000000075030e _start (./build/bin/firtool+0x75030e)\nAborted\n```\n\nIdeally IR verifier should catch this ","createdAt":"2025-04-02T11:46:38Z","labels":[],"number":8382,"state":"OPEN","title":"[FIRRTL] Crash with fstring type on port","url":"https://github.com/llvm/circt/issues/8382"},{"body":"Consider:\r\n```\r\nfirrtl.circuit \"MatchInline\" {\r\n  firrtl.module @MatchInline(in %i: !firrtl.enum<Some: uint<8>, None: uint<0>>, out %o: !firrtl.uint<8>) attributes {convention = #firrtl<convention scalarized>} {\r\n    %c255_ui8 = firrtl.constant 255 : !firrtl.uint<8> {name = \"c_out\"}\r\n    %c0_ui8 = firrtl.constant 0 : !firrtl.uint<8> {name = \"c_in\"}\r\n    %c0_ui0 = firrtl.constant 0 : !firrtl.uint<0>\r\n    %0 = firrtl.enumcreate Some(%c0_ui8) : (!firrtl.uint<8>) -> !firrtl.enum<Some: uint<8>, None: uint<0>>\r\n    %1 = firrtl.enumcreate None(%c0_ui0) : (!firrtl.uint<0>) -> !firrtl.enum<Some: uint<8>, None: uint<0>>\r\n    %2 = firrtl.istag %i Some : !firrtl.enum<Some: uint<8>, None: uint<0>>\r\n    %c_out = firrtl.wire : !firrtl.uint<8>\r\n    %3 = firrtl.mux(%2, %c_out, %c255_ui8) : (!firrtl.uint<1>, !firrtl.uint<8>, !firrtl.uint<8>) -> !firrtl.uint<8>\r\n    firrtl.matchingconnect %o, %3 : !firrtl.uint<8>\r\n  }\r\n}\r\n```\r\n\r\n(obtained from valid FIRRTL, disabling `LowerSignatures` to workaround #7106))\r\n\r\nThis crashes when fed through `circt-opt --lower-firrtl-to-hw`:\r\n\r\n```\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/firtool match-inline.fir\r\n #0 0x00005621d9f41e96 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:723:13\r\n #1 0x00005621d9f3ff90 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:106:18\r\n #2 0x00005621d9f4253b SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\r\n #3 0x00007f500ee52f30 __restore_rt (/nix/store/k7zgvzp2r31zkg9xqgjim7mbknryv6bs-glibc-2.39-52/lib/libc.so.6+0x3ff30)\r\n #4 0x00005621da420ca0 void mlir::detail::IROperandBase::insertInto<mlir::IRObjectWithUseList<mlir::OpOperand>>(mlir::IRObjectWithUseList<mlir::OpOperand>*) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/UseDefLists.h:99:24\r\n #5 0x00005621da420ca0 mlir::IROperand<mlir::OpOperand, mlir::Value>::insertIntoCurrent() /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/UseDefLists.h:186:30\r\n #6 0x00005621da420ca0 mlir::IROperand<mlir::OpOperand, mlir::Value>::IROperand(mlir::Operation*, mlir::Value) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/UseDefLists.h:132:5\r\n #7 0x00005621da420ca0 mlir::OpOperand::OpOperand(mlir::Operation*, mlir::Value) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Value.h:284:38\r\n #8 0x00005621da420ca0 mlir::detail::OperandStorage::OperandStorage(mlir::Operation*, mlir::OpOperand*, mlir::ValueRange) /home/will/src/sifive/circt/llvm/mlir/lib/IR/OperationSupport.cpp:245:30\r\n #9 0x00005621da414ac8 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:122:3\r\n#10 0x00005621da414465 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:75:10\r\n#11 0x00005621da414465 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:58:7\r\n#12 0x00005621da4142f7 llvm::SmallVectorTemplateCommon<mlir::NamedAttribute, void>::begin() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:280:45\r\n#13 0x00005621da4142f7 llvm::SmallVectorTemplateCommon<mlir::NamedAttribute, void>::end() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:282:27\r\n#14 0x00005621da4142f7 llvm::SmallVector<mlir::NamedAttribute, 4u>::~SmallVector() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:1215:46\r\n#15 0x00005621da4142f7 mlir::NamedAttrList::~NamedAttrList() /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:801:7\r\n#16 0x00005621da4142f7 mlir::Operation::create(mlir::OperationState const&) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:36:7\r\n#17 0x00005621da352ddc mlir::OpBuilder::create(mlir::OperationState const&) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Builders.cpp:465:10\r\n#18 0x00005621da473b1a llvm::ValueIsPresent<mlir::Operation*, void>::isPresent(mlir::Operation* const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/Casting.h:622:55\r\n#19 0x00005621da473b1a bool llvm::detail::isPresent<mlir::Operation*>(mlir::Operation* const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/Casting.h:630:10\r\n#20 0x00005621da473b1a decltype(auto) llvm::dyn_cast<circt::hw::UnionCreateOp, mlir::Operation>(mlir::Operation*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/Casting.h:662:3\r\n#21 0x00005621da473b1a circt::hw::UnionCreateOp mlir::OpBuilder::create<circt::hw::UnionCreateOp, mlir::Type&, mlir::StringAttr&, mlir::Value&>(mlir::Location, mlir::Type&, mlir::StringAttr&, mlir::Value&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Builders.h:513:19\r\n#22 0x00005621da45485a circt::hw::UnionCreateOp mlir::ImplicitLocOpBuilder::create<circt::hw::UnionCreateOp, mlir::Type&, mlir::StringAttr&, mlir::Value&>(mlir::Type&, mlir::StringAttr&, mlir::Value&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/ImplicitLocOpBuilder.h:67:23\r\n#23 0x00005621da45485a (anonymous namespace)::FIRRTLLowering::visitExpr(circt::firrtl::FEnumCreateOp) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:2868:28\r\n#24 0x00005621da45485a llvm::LogicalResult circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, llvm::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::firrtl::FEnumCreateOp>(auto) const /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:71:32\r\n#25 0x00005621da45485a llvm::TypeSwitch<mlir::Operation*, llvm::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, llvm::LogicalResult>::Case<circt::firrtl::FEnumCreateOp, circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, llvm::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, llvm::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:102:22\r\n#26 0x00005621da45485a circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, llvm::LogicalResult>::dispatchExprVisitor(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:32:19\r\n#27 0x00005621da4507e9 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLLowering, llvm::LogicalResult>::dispatchVisitor(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:404:18\r\n#28 0x00005621da4507e9 (anonymous namespace)::FIRRTLLowering::run() /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1802:27\r\n#29 0x00005621da4507e9 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleOperations(circt::hw::HWModuleOp, (anonymous namespace)::CircuitLoweringState&) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1785:48\r\n#30 0x00005621da4507e9 _ZZN12_GLOBAL__N_120FIRRTLModuleLowering14runOnOperationEvENK3$_5clImEEDaT_ /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:731:16\r\n#31 0x00005621da44b6fb llvm::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:43:43\r\n#32 0x00005621da44b6fb llvm::failed(llvm::LogicalResult) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:71:58\r\n#33 0x00005621da44b6fb llvm::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:11\r\n#34 0x00005621da44b6fb llvm::LogicalResult mlir::failableParallelForEach<llvm::iota_range<unsigned long>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::iota_range<unsigned long>&&, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10\r\n#35 0x00005621da44b6fb llvm::LogicalResult mlir::failableParallelForEachN<(anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, unsigned long, unsigned long, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:107:10\r\n#36 0x00005621da44b6fb (anonymous namespace)::FIRRTLModuleLowering::runOnOperation() /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:729:17\r\n#37 0x00005621dab60b7f mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1::operator()() const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:17\r\n#38 0x00005621dab60b7f void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1>(long) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12\r\n#39 0x00005621dab60b7f llvm::function_ref<void ()>::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n#40 0x00005621dab60b7f void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(llvm::function_ref<void ()>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/MLIRContext.h:275:7\r\n#41 0x00005621dab60b7f mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:521:21\r\n#42 0x00005621dab635a2 llvm::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:43:43\r\n#43 0x00005621dab635a2 llvm::failed(llvm::LogicalResult) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:71:58\r\n#44 0x00005621dab635a2 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:593:9\r\n#45 0x00005621dab635a2 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:904:10\r\n#46 0x00005621dab635a2 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:884:60\r\n#47 0x00005621d9e915d7 llvm::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:43:43\r\n#48 0x00005621d9e915d7 llvm::failed(llvm::LogicalResult) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:71:58\r\n#49 0x00005621d9e915d7 processBuffer(mlir::MLIRContext&, circt::firtool::FirtoolOptions&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:494:7\r\n#50 0x00005621d9e90432 processInputSplit(mlir::MLIRContext&, circt::firtool::FirtoolOptions&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:566:12\r\n#51 0x00005621d9e8ff04 processInput(mlir::MLIRContext&, circt::firtool::FirtoolOptions&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:582:12\r\n#52 0x00005621d9e8ff04 executeFirtool(mlir::MLIRContext&, circt::firtool::FirtoolOptions&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:674:14\r\n#53 0x00005621d9e8faf8 llvm::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:43:43\r\n#54 0x00005621d9e8faf8 llvm::failed(llvm::LogicalResult) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/LogicalResult.h:71:58\r\n#55 0x00005621d9e8faf8 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:769:8\r\n#56 0x00007f500ee3d10e __libc_start_call_main (/nix/store/k7zgvzp2r31zkg9xqgjim7mbknryv6bs-glibc-2.39-52/lib/libc.so.6+0x2a10e)\r\n#57 0x00007f500ee3d1c9 __libc_start_main@GLIBC_2.2.5 (/nix/store/k7zgvzp2r31zkg9xqgjim7mbknryv6bs-glibc-2.39-52/lib/libc.so.6+0x2a1c9)\r\n#58 0x00005621d9e8f895 _start (./build/bin/firtool+0x80b895)\r\nzsh: segmentation fault (core dumped)  ./build/bin/firtool match-inline.fir\r\n```\r\n\r\nI have not investigated beyond this, just reporting for now.","createdAt":"2024-07-25T16:54:39Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":7388,"state":"OPEN","title":"[FIRRTL][LowerToHW] crash lowering enum code","url":"https://github.com/llvm/circt/issues/7388"},{"body":"For example:\n```\nmodule {\n  esi.manifest.sym @CoerceBundleTransform name \"CoerceBundleTransform\"\n  hw.module @CoerceBundleTransform(in %b_in : !esi.bundle<[!esi.channel<i32> to \"req\", !esi.channel<i8> from \"resp\"]>,\n                                   out b_out : !esi.bundle<[!esi.channel<i24> to \"arg\", !esi.channel<i16> from \"result\"]>)\n                                   attributes {output_file = #hw.output_file<\"CoerceBundleTransform.sv\", includeReplicatedOps>} {\n\n    %rawOutput, %valid = esi.unwrap.vr %result, %ready : i16\n    %0 = comb.extract %rawOutput from 0 : (i16) -> i8\n    %chanOutput, %ready = esi.wrap.vr %0, %valid : i8\n    %req = esi.bundle.unpack %chanOutput from %b_in : !esi.bundle<[!esi.channel<i32> to \"req\", !esi.channel<i8> from \"resp\"]>\n    %rawOutput_0, %valid_1 = esi.unwrap.vr %req, %ready_3 : i32\n    %1 = comb.extract %rawOutput_0 from 0 : (i32) -> i24\n    %chanOutput_2, %ready_3 = esi.wrap.vr %1, %valid_1 : i24\n    %bundle, %result = esi.bundle.pack %chanOutput_2 : !esi.bundle<[!esi.channel<i24> to \"arg\", !esi.channel<i16> from \"result\"]>\n    hw.output %bundle : !esi.bundle<[!esi.channel<i24> to \"arg\", !esi.channel<i16> from \"result\"]>\n  }\n}\n```\n\n`circt-opt --esi-clean-metadata --lower-esi-bundles --lower-esi-to-hw %s` will trigger a stack crash.\n\nPlease let me know if this command line is an error.\n\n```\nCasting.h:662: decltype(auto) llvm::dyn_cast(From *) [To = circt::esi::WrapValidReadyOp, From = mlir::Operation]: Assertion `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: ./circt-opt /home/phoenix/test/esi.mlir --esi-clean-metadata --lower-esi-bundles --lower-esi-to-hw\n #0 0x0000638db276f9fd llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/phoenix/work/circt/llvm/llvm/lib/Support/Unix/Signals.inc:796:11\n #1 0x0000638db276feeb PrintStackTraceSignalHandler(void*) /home/phoenix/work/circt/llvm/llvm/lib/Support/Unix/Signals.inc:872:1\n #2 0x0000638db276df56 llvm::sys::RunSignalHandlers() /home/phoenix/work/circt/llvm/llvm/lib/Support/Signals.cpp:105:5\n #3 0x0000638db27706a5 SignalHandler(int) /home/phoenix/work/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\n #4 0x00007e1453242520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #5 0x00007e14532969fc __pthread_kill_implementation ./nptl/./nptl/pthread_kill.c:44:76\n #6 0x00007e14532969fc __pthread_kill_internal ./nptl/./nptl/pthread_kill.c:78:10\n #7 0x00007e14532969fc pthread_kill ./nptl/./nptl/pthread_kill.c:89:10\n #8 0x00007e1453242476 gsignal ./signal/../sysdeps/posix/raise.c:27:6\n #9 0x00007e14532287f3 abort ./stdlib/./stdlib/abort.c:81:7\n#10 0x00007e145322871b _nl_load_domain ./intl/./intl/loadmsgcat.c:1177:9\n#11 0x00007e1453239e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n#12 0x0000638db2e1e988 decltype(auto) llvm::dyn_cast<circt::esi::WrapValidReadyOp, mlir::Operation>(mlir::Operation*) /home/phoenix/work/circt/llvm/llvm/include/llvm/Support/Casting.h:663:49\n#13 0x0000638db2e82e83 (anonymous namespace)::RemoveWrapUnwrap::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::Value>, mlir::ConversionPatternRewriter&) const /home/phoenix/work/circt/lib/Dialect/ESI/Passes/ESILowerToHW.cpp:190:14\n#14 0x0000638db2e9220f mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const /home/phoenix/work/circt/llvm/mlir/include/mlir/Transforms/DialectConversion.h:568:12\n```","createdAt":"2025-02-11T07:50:46Z","labels":[{"id":"MDU6TGFiZWwyNzY3ODUyMDMx","name":"ESI","description":"","color":"91D9EF"}],"number":8219,"state":"CLOSED","title":"[ESI]Assersion: dyn_cast on a non-existent value","url":"https://github.com/llvm/circt/issues/8219"},{"body":"The following FIRRTL program:\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_a: UInt\r\n    output _tmp46: UInt\r\n    _tmp46 <= inp_a\r\n```\r\n\r\nCompiled with `firtool a_top_mod.fir --lower-to-hw --expand-whens --infer-widths --lowering-options=noAlwaysFF --verilog -o=a_top_mod_new.v` fails with the following core dump:\r\n\r\n```\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-hw --expand-whens --infer-widths --lowering-options=noAlwaysFF --mlir-timing --verilog -o=a_top_mod_new.v\r\n1.       #0 0x000000000048512d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (../../llvm/circt/build/bin/firtool+0x48512d)\r\n #1 0x0000000000482f64 llvm::sys::RunSignalHandlers() (../../llvm/circt/build/bin/firtool+0x482f64)\r\n #2 0x00000000004830c3 SignalHandler(int) (../../llvm/circt/build/bin/firtool+0x4830c3)\r\n #3 0x0000000004890a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)\r\n #4 0x0000000004cb24a5 raise (/lib64/libc.so.6+0x3d4a5)\r\n #5 0x0000000004c9b864 abort (/lib64/libc.so.6+0x26864)\r\n #6 0x0000000004c9b749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #7 0x0000000004caa9b6 (/lib64/libc.so.6+0x359b6)\r\n #8 0x00000000005b7305 llvm::isa_impl_cl<(anonymous namespace)::RootExpr, (anonymous namespace)::Expr const*>::doit((anonymous namespace)::Expr const*) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/Support/Casting.h:105:36\r\n #9 0x00000000005b59c2 llvm::isa_impl_wrap<(anonymous namespace)::RootExpr, (anonymous namespace)::Expr const*, (anonymous namespace)::Expr const*>::doit((anonymous namespace)::Expr const* const&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/Support/Casting.h:132:3\r\n#10 0x00000000005b3c0f llvm::isa_impl_wrap<(anonymous namespace)::RootExpr, (anonymous namespace)::Expr const* const, (anonymous namespace)::Expr const*>::doit((anonymous namespace)::Expr const* const&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/Support/Casting.h:124:3\r\n#11 0x00000000005b126b bool llvm::isa<(anonymous namespace)::RootExpr, (anonymous namespace)::Expr const*>((anonymous namespace)::Expr const* const&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/Support/Casting.h:144:1\r\n#12 0x00000000005ae5b4 llvm::cast_retty<(anonymous namespace)::RootExpr, (anonymous namespace)::Expr const*>::ret_type llvm::dyn_cast<(anonymous namespace)::RootExpr, (anonymous namespace)::Expr const>((anonymous namespace)::Expr const*) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/Support/Casting.h:345:22\r\n#13 0x00000000005abb3b auto llvm::detail::TypeSwitchBase<llvm::TypeSwitch<(anonymous namespace)::Expr const*, (anonymous namespace)::Expr* const*>, (anonymous namespace)::Expr const*>::castValue<(anonymous namespace)::RootExpr, (anonymous namespace)::Expr const*>((anonymous namespace)::Expr const*, std::enable_if<!(llvm::detail::detector<void, llvm::detail::TypeSwitchBase<llvm::TypeSwitch<(anonymous namespace)::Expr const*, (anonymous namespace)::Expr* const*>, (anonymous namespace)::Expr const*>::has_dyn_cast_t, (anonymous namespace)::Expr const*, (anonymous namespace)::RootExpr>::value_t::value), void>::type*) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:82:3\r\n#14 0x00000000005abb9a llvm::TypeSwitch<(anonymous namespace)::Expr const*, (anonymous namespace)::Expr* const*>& llvm::TypeSwitch<(anonymous namespace)::Expr const*, (anonymous namespace)::Expr* const*>::Case<(anonymous namespace)::RootExpr, (anonymous namespace)::Expr::begin() const::'lambda'(auto*)&>((anonymous namespace)::Expr::begin() const::'lambda'(auto*)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:115:58\r\n#15 0x00000000005a8efb llvm::TypeSwitch<(anonymous namespace)::Expr const*, (anonymous namespace)::Expr* const*>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<(anonymous namespace)::Expr const*, (anonymous namespace)::Expr* const*>, (anonymous namespace)::Expr const*>::Case<(anonymous namespace)::RootExpr, (anonymous namespace)::VarExpr, (anonymous namespace)::KnownExpr, (anonymous namespace)::AddExpr, (anonymous namespace)::PowExpr, (anonymous namespace)::MaxExpr, (anonymous namespace)::MinExpr, (anonymous namespace)::Expr::begin() const::'lambda'(auto*)>((anonymous namespace)::Expr::begin() const::'lambda'(auto*)&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:41:42\r\n#16 0x00000000005a6df6 (anonymous namespace)::Expr::begin() const /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Transforms/InferWidths.cpp:224:42\r\n#17 0x00000000005a6e6a llvm::GraphTraits<(anonymous namespace)::Expr*>::child_begin((anonymous namespace)::Expr*) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Transforms/InferWidths.cpp:247:3\r\n#18 0x00000000005ad092 llvm::po_iterator<(anonymous namespace)::Expr*, llvm::SmallPtrSet<(anonymous namespace)::Expr*, 8u>, false, llvm::GraphTraits<(anonymous namespace)::Expr*> >::traverseChild() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/PostOrderIterator.h:136:64\r\n#19 0x00000000005b28d7 llvm::po_iterator<(anonymous namespace)::Expr*, llvm::SmallPtrSet<(anonymous namespace)::Expr*, 8u>, false, llvm::GraphTraits<(anonymous namespace)::Expr*> >::po_iterator((anonymous namespace)::Expr*) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/PostOrderIterator.h:115:3\r\n#20 0x00000000005af808 llvm::po_iterator<(anonymous namespace)::Expr*, llvm::SmallPtrSet<(anonymous namespace)::Expr*, 8u>, false, llvm::GraphTraits<(anonymous namespace)::Expr*> >::begin((anonymous namespace)::Expr* const&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/PostOrderIterator.h:145:3\r\n#21 0x00000000005aca1f llvm::po_iterator<(anonymous namespace)::Expr*, llvm::SmallPtrSet<llvm::GraphTraits<(anonymous namespace)::Expr*>::NodeRef, 8u>, false, llvm::GraphTraits<(anonymous namespace)::Expr*> > llvm::po_begin<(anonymous namespace)::Expr*>((anonymous namespace)::Expr* const&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/PostOrderIterator.h:184:72\r\n#22 0x00000000005a95ca llvm::iterator_range<llvm::po_iterator<(anonymous namespace)::Expr*, llvm::SmallPtrSet<llvm::GraphTraits<(anonymous namespace)::Expr*>::NodeRef, 8u>, false, llvm::GraphTraits<(anonymous namespace)::Expr*> > > llvm::post_order<(anonymous namespace)::Expr*>((anonymous namespace)::Expr* const&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/PostOrderIterator.h:189:43\r\n#23 0x00000000005a74f2 (anonymous namespace)::ConstraintSolver::solve() /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Transforms/InferWidths.cpp:410:64\r\n#24 0x00000000005a8c4c (anonymous namespace)::InferWidthsPass::runOnOperation() /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Transforms/InferWidths.cpp:936:3\r\n#25 0x000000000090e2f5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x90e2f5)\r\n#26 0x000000000090e450 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x90e450)\r\n#27 0x000000000090db14 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (../../llvm/circt/build/bin/firtool+0x90db14)\r\n#28 0x000000000090e0b6 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x90e0b6)\r\n#29 0x000000000090e450 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x90e450)\r\n#30 0x0000000000911517 mlir::PassManager::run(mlir::Operation*) (../../llvm/circt/build/bin/firtool+0x911517)\r\n#31 0x000000000040c785 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, mlir::TimingScope&, mlir::MLIRContext&, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:246:13\r\n#32 0x000000000040ce73 executeFirtool(mlir::MLIRContext&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:322:63\r\n#33 0x000000000040cffc main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:352:39\r\n#34 0x0000000004c9cb25 __libc_start_main (/lib64/libc.so.6+0x27b25)\r\n#35 0x000000000040bd7e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 16: 11134 Aborted                 (core dumped) valgrind -q ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-hw --expand-whens --infer-widths --lowering-options=noAlwaysFF --mlir-timing --verilog -o=$VFILE2\r\nf```\r\n","createdAt":"2021-05-20T23:21:41Z","labels":[{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"},{"id":"MDU6TGFiZWwzMDE0NDc1ODc1","name":"infer width","description":"","color":"FD8C15"}],"number":1109,"state":"CLOSED","title":"[FIRRTL] infer width (io) (core dump)","url":"https://github.com/llvm/circt/issues/1109"},{"body":"The following FIRRTL program\r\n\r\n```python\r\n; seed: 497\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input inp_a: UInt<5>\r\n    input inp_b: {inp_c: {inp_j: UInt<5>}, inp_d: {inp_e: SInt<7>, inp_i: SInt<2>}, inp_g: {inp_h: UInt<14>}}\r\n    input inp_f: UInt<13>\r\n    output tmp8: SInt<25>\r\n    reg tmp6: UInt<5>, clock with: (reset => (reset, UInt<5>(0)))\r\n    reg tmp9: UInt<13>, clock\r\n    reg tmp10: SInt<8>, clock\r\n    wire tmp11: SInt<23>\r\n    reg tmp12: SInt<1>, clock with: (reset => (reset, SInt<1>(0)))\r\n    reg tmp13: SInt<11>, clock\r\n    reg tmp15: UInt<8>, clock\r\n    wire _tmp17: UInt<12>\r\n    wire tmp18: SInt<11>\r\n    reg tmp19: UInt<13>, clock with: (reset => (reset, UInt<13>(0)))\r\n    reg tmp23: SInt<11>, clock with: (reset => (reset, SInt<11>(0)))\r\n    tmp6 <= bits(inp_b.inp_g.inp_h, 4, 0)\r\n    tmp8 <= mux(head(tmp6, 1), SInt<23>(\"h1d0137\"), asSInt(UInt<25>(\"b100101111111101010010010\")))\r\n    tmp9 <= xor(inp_f, inp_b.inp_c.inp_j)\r\n    tmp10 <= neg(UInt<7>(\"h26\"))\r\n    tmp11 <= asSInt(UInt<23>(\"o5674546\"))\r\n    tmp12 <= validif(head(inp_f, 1), SInt<1>(\"b-1\"))\r\n    tmp13 <= shr(tmp8, 14)\r\n    tmp15 <= not(tmp10)\r\n    _tmp17 <= add(UInt<11>(\"b110001010\"), tmp15)\r\n    tmp18 <= rem(tmp13, asSInt(UInt<24>(9972122)))\r\n    tmp19 <= bits(inp_f, 12, 0)\r\n    tmp23 <= validif(head(asUInt(SInt<20>(\"o-71634\")), 1), tmp13)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --enable-lower-types --verilog` gives an error:\r\n\r\n```mlir\r\nfirtool\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv\r\n #0 0x00000000004bc921 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004bc9d8 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004ba9d8 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004bc374 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007fb20ef94a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)\r\n #5 0x0000000000694d5e llvm::PointerIntPair<void*, 1u, int, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Dialect*, mlir::MLIRContext*>, llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Dialect*, mlir::MLIRContext*> > >::getInt() const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/PointerIntPair.h:61:57\r\n #6 0x0000000000695db3 bool llvm::PointerUnion<mlir::Dialect*, mlir::MLIRContext*>::is<mlir::Dialect*>() const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/PointerUnion.h:181:34\r\n #7 0x000000000069113c mlir::Dialect* llvm::PointerUnion<mlir::Dialect*, mlir::MLIRContext*>::dyn_cast<mlir::Dialect*>() const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/PointerUnion.h:195:5\r\n #8 0x0000000000687b59 mlir::Identifier::getDialect() /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/MLIRContext.cpp:801:1\r\n #9 0x00000000006a96f7 mlir::OperationName::getDialect() const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:328:56\r\n#10 0x00000000006a176e mlir::Operation::getDialect() /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:214:67\r\n#11 0x00000000006a27fb mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:557:32\r\n#12 0x00000000007d23e9 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13\r\n#13 0x00000000007d1d6e mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13\r\n#14 0x00000000007b7f09 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21\r\n#15 0x00000000007b8234 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35\r\n#16 0x00000000007b8120 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1\r\n#17 0x00000000006ed6ae (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:35:3\r\n#18 0x00000000008a4563 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:36\r\n#19 0x00000000008a478f mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:444:15\r\n#20 0x00000000008a68cf mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:896:74\r\n#21 0x000000000040dbfc processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) (../../llvm/circt/build/bin/firtool+0x40dbfc)\r\n#22 0x000000000040b203 main (../../llvm/circt/build/bin/firtool+0x40b203)\r\n#23 0x00007fb20ea02b25 __libc_start_main (/lib64/libc.so.6+0x27b25)\r\n#24 0x000000000040b56e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: строка 25: 25590 Segmentation fault      (стек памяти сброшен на диск) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2\r\n```\r\n\r\nThe issue appears at random.\r\n","createdAt":"2021-03-16T23:44:05Z","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":773,"state":"CLOSED","title":"[FIRRTL] crash","url":"https://github.com/llvm/circt/issues/773"}]
