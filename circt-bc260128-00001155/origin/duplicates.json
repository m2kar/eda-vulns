{
  "version": "1.0",
  "timestamp": "2026-02-01T05:18:39.555334",
  "search_terms": {
    "dialect": "Moore",
    "failing_pass": "MooreToCore",
    "crash_type": "assertion",
    "keywords": [
      "StringType",
      "MooreToCore",
      "sanitizeInOut",
      "dyn_cast non-existent",
      "type conversion",
      "module port",
      "string port",
      "circt-verilog",
      "populateTypeConversion"
    ],
    "assertion_message": "dyn_cast on a non-existent value"
  },
  "results": {
    "total_found": 70,
    "top_score": 12.0,
    "issues": [
      {
        "body": "## Description\n\nCIRCT crashes with assertion `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"` when compiling SystemVerilog modules that use packed union types as module ports.\n\n**Likely cause**: MooreToCore conversion pass lacks a type conversion rule for packed union types (`UnionType`). When processing module ports, the type converter fails to convert `UnionType`, resulting in an invalid/null type that causes assertion failures in downstream port processing code (`getModulePortInfo` at line 259).\n\n> **Validation**: Test case accepted by: verilator, iverilog, slang\n> **IEEE 1800-2005**: Packed unions are valid (Section 7.3)\n\n## Steps to Reproduce\n\n1. Save following code as `bug.sv`\n2. Run: `circt-verilog --ir-hw bug.sv`\n\n## Test Case\n\n```systemverilog\ntypedef union packed {\n  logic [31:0] a;\n  logic [31:0] b;\n} my_union;\n\nmodule Sub(input my_union in_val, output my_union out_val);\n  assign out_val = in_val;\nendmodule\n\nmodule Top;\n  my_union data_in, data_out;\n  \n  Sub s(.in_val(data_in), .out_val(data_out));\nendmodule\n```\n\n## Error Output\n\n```\n #4 0x00007f8176f898ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007f8176f89b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007f8176f89530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n```\n\n<details>\n<summary>Full Stack Trace</summary>\n\n```\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.      Program arguments: /opt/firtool/bin/circt-verilog --ir-hw bug.sv\n #0 0x00007f8172d678a8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x2008a8)\n #1 0x00007f8172d652f5 llvm::sys::RunSignalHandlers() (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x1fe2f5)\n #2 0x00007f8172d68631 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x00007f8172875330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #4 0x00007f8176f898ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007f8176f89b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007f8176f89530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n #7 0x00007f817529b438 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2a438)\n #8 0x00007f81752658ed void llvm::function_ref<void ()>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_0>(long) PatternApplicator.cpp:0:0\n #9 0x00007f8175262774 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/opt/firtool-1.139.0/bin/../lib/libMLIRRewrite.so+0x7774)\n#10 0x00007f817529cc6f (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*) DialectConversion.cpp:0:0\n#11 0x00007f817529c470 mlir::OperationConverter::convert(mlir::Operation*, bool) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2b470)\n#12 0x00007f817529cdae mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2bdae)\n#13 0x00007f81752aa8e4 void llvm::function_ref<void ()>::callback_fn<applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode)::$_0>(long) DialectConversion.cpp:0:0\n#14 0x00007f81752a1f7d applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode) DialectConversion.cpp:0:0\n#15 0x00007f81752a20fe mlir::applyFullConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x310fe)\n#16 0x00007f8176f5b231 (anonymous namespace)::MooreToCorePass::runOnOperation() MooreToCore.cpp:0:0\n#17 0x00007f81750572a5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x172a5)\n#18 0x00007f817505a7a9 mlir::PassManager::run(mlir::Operation*) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x1a7a9)\n#19 0x0000563df3daf5d0 executeWithSources(mlir::MLIRContext*, llvm::SourceMgr&) circt-verilog.cpp:0:0\n#20 0x0000563df3daadd5 execute(mlir::MLIRContext*) circt-verilog.cpp:0:0\n#21 0x0000563df3daa4b8 main (/opt/firtool/bin/circt-verilog+0x84b8)\n#22 0x00007f817285a1ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#23 0x00007f817285a28b call_init ./csu/../csu/libc-start.c:128:20\n#24 0x00007f817285a28b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#25 0x0000563df3da9b05 _start (/opt/firtool/bin/circt-verilog+0x7b05)\n[1]    1143009 segmentation fault (core dumped)  /opt/firtool/bin/circt-verilog --ir-hw bug.sv\n\n```\n\n</details>\n\n## Root Cause Analysis\n\n- **Dialect**: Moore\n- **Failing Pass**: MooreToCore\n\n### Hypotheses\n\n1. **Missing UnionType type conversion rule** (confidence: high)\n   - Evidence: [\"Test case uses 'typedef union packed' as module port type\", 'Stack trace shows crash in getModulePortInfo during port processing at line 259', \"Assertion message indicates 'dyn_cast<InOutType>' failed on non-existent value\", 'No conversion rule for UnionType exists in populateTypeConversion function (lines 2268-2409)', 'Similar types like StructType have conversion rules, but UnionType does not', 'Both UnionType and StructType implement DestructurableTypeInterface, suggesting they should be handled similarly']\n   - Mechanism: The typeConverter fails to convert UnionType when processing module ports, resulting in an invalid type that causes assertion failures\n\n2. **Type converter returns invalid non-null type** (confidence: medium)\n   - Evidence: [\"Line 245-248 checks 'if (!portTy)' and emits error\", 'However, crash still occurs, suggesting either the check is not being reached or the type is non-null but invalid', 'The assertion occurs in a different code path that may not be covered by the initial null check']\n   - Mechanism: The typeConverter may return a non-null type with incorrect MLIR type ID or metadata\n\n## Environment\n\n- **CIRCT Version**: LLVM (http://llvm.org/):\n  LLVM version 22.0.0git\n  Optimized build.\nCIRCT firtool-1.139.0\nslang version 9.1.0+0\n\n---\n**Labels**: bug, Moore",
        "createdAt": "2026-02-01T02:15:22Z",
        "labels": [],
        "number": 9570,
        "state": "OPEN",
        "title": "[Moore] Assertion in MooreToCore when module uses packed union type as port",
        "url": "https://github.com/llvm/circt/issues/9570",
        "similarity_score": 12.0
      },
      {
        "body": "It failed when trying to compile https://github.com/pulp-platform/ELAU/blob/b0d113aff6a2d800076f5ebb84f09fba93625bc7/src/SqrtArrUns.sv#L96-L105. \n```\nmoore.module @behavioural_SqrtArrUns(in %X : !moore.l8, out Q : !moore.l4, out R : !moore.l4) {\n  %0 = moore.constant 2 : l8\n  %1 = moore.conversion %X : !moore.l8 -> !moore.real\n  %2 = moore.builtin.sqrt %1 : real\n  %3 = moore.builtin.floor %2 : real\n  %4 = moore.conversion %3 : !moore.real -> !moore.l4\n  %5 = moore.zext %4 : l4 -> l8\n  %6 = moore.powu %5, %0 : l8\n  %7 = moore.sub %X, %6 : l8\n  %8 = moore.trunc %7 : l8 -> l4\n  moore.output %4, %8 : !moore.l4, !moore.l4\n}\n```\n\n```\n[circt-verilog] Running \"convert-moore-to-core\"\ncirct-verilog: /home/uenoku/dev/circt-synth/llvm/llvm/include/llvm/Support/Casting.h:650: decltype(auto) llvm::dyn_cast(const From &) [To = mlir::IntegerType, From = mlir::Type]: Assertion `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.      Program arguments: circt-verilog ../out/SqrtArrUns_behavioral.sv -o build/SqrtArrUns_behavioral/circt/SqrtArrUns_behavioral.mlir --mlir-timing -y ../out ../ext/ELAU/src/arith_utils.sv -mlir-print-ir-after-all -verbose-pass-executions\n #0 0x00005a3051df92b8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/uenoku/dev/circt-synth/llvm/llvm/lib/Support/Unix/Signals.inc:834:13\n #1 0x00005a3051df6e93 llvm::sys::RunSignalHandlers() /home/uenoku/dev/circt-synth/llvm/llvm/lib/Support/Signals.cpp:105:18\n #2 0x00005a3051dfa051 SignalHandler(int, siginfo_t*, void*) /home/uenoku/dev/circt-synth/llvm/llvm/lib/Support/Unix/Signals.inc:426:38\n #3 0x00007ecdbca42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #4 0x00007ecdbca969fc __pthread_kill_implementation ./nptl/./nptl/pthread_kill.c:44:76\n #5 0x00007ecdbca969fc __pthread_kill_internal ./nptl/./nptl/pthread_kill.c:78:10\n #6 0x00007ecdbca969fc pthread_kill ./nptl/./nptl/pthread_kill.c:89:10\n #7 0x00007ecdbca42476 gsignal ./signal/../sysdeps/posix/raise.c:27:6\n #8 0x00007ecdbca287f3 abort ./stdlib/./stdlib/abort.c:81:7\n #9 0x00007ecdbca2871b _nl_load_domain ./intl/./intl/loadmsgcat.c:1177:9\n#10 0x00007ecdbca39e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n#11 0x00005a3050b0d8c4 decltype(auto) llvm::dyn_cast<mlir::IntegerType, mlir::Type>(mlir::Type const&) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x1ad8c4)\n#12 0x00005a3050cb10c5 decltype(auto) llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Type, long>, mlir::Type>::castValue<mlir::IntegerType, mlir::Type const&>(mlir::Type const&) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x3510c5)\n#13 0x00005a3050c9d8da llvm::TypeSwitch<mlir::Type, long>& llvm::TypeSwitch<mlir::Type, long>::Case<mlir::IntegerType, circt::hw::getBitWidth(mlir::Type)::$_0>(circt::hw::getBitWidth(mlir::Type)::$_0&&) HWTypes.cpp:0:0\n#14 0x00005a3050c9d7e6 circt::hw::getBitWidth(mlir::Type) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x33d7e6)\n#15 0x00005a30510f9908 (anonymous namespace)::ConversionOpConversion::matchAndRewrite(circt::moore::ConversionOp, circt::moore::ConversionOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n#16 0x00005a30510fa631 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::ConversionOp>, circt::moore::ConversionOp>(mlir::OpConversionPattern<circt::moore::ConversionOp> const&, circt::moore::ConversionOp, circt::moore::ConversionOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange> >, mlir::ConversionPatternRewriter&) (/home/uenoku/dev/circt-synth/build/bin/circt-verilog+0x79a631)\n```",
        "createdAt": "2025-09-06T09:21:38Z",
        "labels": [
          {
            "id": "LA_kwDODpuCgs7olJFv",
            "name": "Moore",
            "description": "",
            "color": "04673D"
          }
        ],
        "number": 8930,
        "state": "OPEN",
        "title": "[MooreToCore] Crash with sqrt/floor",
        "url": "https://github.com/llvm/circt/issues/8930",
        "similarity_score": 10.5
      },
      {
        "body": "## Bug Description\n\n`circt-verilog` crashes with an assertion failure when processing a SystemVerilog module that has a `string` type output port. The crash occurs during the MooreToCore conversion pass when the `getModulePortInfo()` function fails to properly handle cases where type conversion returns an invalid/empty type, causing a `dyn_cast` assertion failure in `ModulePortInfo::sanitizeInOut()`.\n\nThis is a valid SystemVerilog construct per IEEE 1800-2017 Section 6.16 (String data type). Both **slang** and **verilator** accept the code without errors.\n\n## Steps to Reproduce\n\n1. Save the following test case as `bug.sv`\n2. Run: `circt-verilog --ir-hw bug.sv`\n\n## Test Case\n\n```systemverilog\nmodule test_module(output string a);\nendmodule\n```\n\n## Expected Behavior\n\nCIRCT should either:\n1. Support simulation constructs like string ports appropriately, OR\n2. Emit a proper diagnostic error message indicating that string ports are not supported for hardware synthesis\n\n## Actual Behavior\n\nThe tool crashes with an assertion failure:\n\n```\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: circt-verilog --ir-hw bug.sv\n #0 0x00007fe810a738a8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x2008a8)\n #1 0x00007fe810a712f5 llvm::sys::RunSignalHandlers() (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x1fe2f5)\n #2 0x00007fe810a74631 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x00007fe810581330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #4 0x00007fe814c958ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007fe814c95b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007fe814c95530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n #7 0x00007fe812fa7438 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2a438)\n #8 0x00007fe812f718ed void llvm::function_ref<void ()>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_0>(long) PatternApplicator.cpp:0:0\n #9 0x00007fe812f6e774 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/opt/firtool-1.139.0/bin/../lib/libMLIRRewrite.so+0x7774)\n#10 0x00007fe812fa8c6f (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*) DialectConversion.cpp:0:0\n#11 0x00007fe812fa8470 mlir::OperationConverter::convert(mlir::Operation*, bool) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2b470)\n#12 0x00007fe812fa8dae mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2bdae)\n#13 0x00007fe812fb68e4 void llvm::function_ref<void ()>::callback_fn<applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode)::$_0>(long) DialectConversion.cpp:0:0\n#14 0x00007fe812fadf7d applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode) DialectConversion.cpp:0:0\n#15 0x00007fe812fae0fe mlir::applyFullConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x310fe)\n#16 0x00007fe814c67231 (anonymous namespace)::MooreToCorePass::runOnOperation() MooreToCore.cpp:0:0\n#17 0x00007fe812d632a5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x172a5)\n#18 0x00007fe812d667a9 mlir::PassManager::run(mlir::Operation*) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x1a7a9)\n#19 0x0000561bab9605d0 executeWithSources(mlir::MLIRContext*, llvm::SourceMgr&) circt-verilog.cpp:0:0\n#20 0x0000561bab95bdd5 execute(mlir::MLIRContext*) circt-verilog.cpp:0:0\n#21 0x0000561bab95b4b8 main (/opt/firtool-1.139.0/bin/circt-verilog+0x84b8)\n#22 0x00007fe8105661ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#23 0x00007fe81056628b call_init ./csu/../csu/libc-start.c:128:20\n#24 0x00007fe81056628b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#25 0x0000561bab95ab05 _start (/opt/firtool-1.139.0/bin/circt-verilog+0x7b05)\n\n```\n\n## Root Cause Analysis\n\n### Crash Location\n- **File**: `lib/Conversion/MooreToCore/MooreToCore.cpp`\n- **Function**: `getModulePortInfo()` \u2192 calls `ModulePortInfo::sanitizeInOut()`\n- **Assertion**: `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"`\n\n### Analysis\n\nThe root cause is **missing validation of type conversion result** in `getModulePortInfo()`:\n\n```cpp\n// MooreToCore.cpp:233-259\nstatic hw::ModulePortInfo getModulePortInfo(const TypeConverter &typeConverter,\n                                            SVModuleOp op) {\n  // ...\n  for (auto port : moduleTy.getPorts()) {\n    Type portTy = typeConverter.convertType(port.type);  // <-- May return empty Type!\n    // ...\n    ports.push_back(hw::PortInfo({{port.name, portTy, port.dir}, ...}));  // <-- Stores empty Type\n  }\n  return hw::ModulePortInfo(ports);  // <-- Constructor calls sanitizeInOut()\n}\n```\n\nWhen `typeConverter.convertType()` fails for the `string` port type (returns empty `Type`), this invalid type is passed to `sanitizeInOut()` which calls `dyn_cast<hw::InOutType>(p.type)` on the empty type, triggering the assertion.\n\n### Suggested Fix\n\nAdd validation in `getModulePortInfo()` to check if `typeConverter.convertType()` returns a valid type:\n\n```cpp\nType portTy = typeConverter.convertType(port.type);\nif (!portTy) {\n  // Emit proper diagnostic error\n  return failure();\n}\n```\n\n## Environment\n\n- **CIRCT Version**: firtool-1.139.0 (LLVM 22.0.0git)\n- **OS**: Linux 5.15.0 (x86_64)\n\n## Cross-Tool Validation\n\n| Tool | Version | Status | Notes |\n|------|---------|--------|-------|\n| slang | 10.0.6+3d7e6cd2e | \u2705 Pass | Build succeeded: 0 errors, 0 warnings |\n| verilator | 5.022 | \u2705 Pass | No errors |\n| iverilog | - | \u274c Error | \"Port with type string is not supported\" (tool limitation, not syntax error) |\n\nThis confirms the test case is **syntactically valid** SystemVerilog per IEEE 1800-2017.\n",
        "createdAt": "2026-02-01T03:00:12Z",
        "labels": [],
        "number": 9572,
        "state": "OPEN",
        "title": "[Moore] Assertion failure when module has string type output port",
        "url": "https://github.com/llvm/circt/issues/9572",
        "similarity_score": 10.0
      },
      {
        "body": "Hi! Now I try to add types and operators in sim to get the lowered operators in moore, and then lower them to llvm dialect, so that the corresponding dynamic size container can be implemented in arcilator.\n\nFirst, add IntType and RefType in sim, as well as VariableOp, BlockAssignOp, Print, ReadOp, and ConcatOp operators.\nTaking Variable as an example, creating a stringtype VariableOp in Moore will create an int type through string_constant, and then perform conversionOp to convert the int type to Stringtype, and finally create VariableOp. In sim, if VariableOp can directly accept int type, the conversion time can be saved. Therefore, I think it is not necessary to add StringType separately, and only use Int Type and RefType to represent it.\n\nIn sim to llvm dialect, VariableOp will be converted into a series of Ops. First, llvm.alloca will be used to create an i128 memory, which will be divided into i32 size to record the string length, and i96 data to record the string content. Then, llvm.getelementptrOp and llvm.storeOp are used to store the contents in the corresponding locations. This memory will be dynamically doubled according to the length of the string.\n\nCan you give me some advise?",
        "createdAt": "2025-03-20T02:36:53Z",
        "labels": [],
        "number": 8332,
        "state": "OPEN",
        "title": "[MooreToCore] Support for StringType from moore to llvm dialect",
        "url": "https://github.com/llvm/circt/issues/8332",
        "similarity_score": 7.0
      },
      {
        "body": "The following input crashes the MooreToCore conversion. Might be fixed by #7625.\r\n```mlir\r\nmodule {\r\n  moore.module @top() {\r\n    %mem = moore.variable : <uarray<1024 x l8>>\r\n    %a = moore.variable : <l8>\r\n    moore.procedure initial {\r\n      %0 = moore.read %mem : <uarray<1024 x l8>>\r\n      %1 = moore.extract %0 from 123 : uarray<1024 x l8> -> l8\r\n      moore.blocking_assign %a, %1 : l8\r\n      moore.return\r\n    }\r\n    moore.output\r\n  }\r\n}\r\n```",
        "createdAt": "2024-09-25T03:24:07Z",
        "labels": [
          {
            "id": "MDU6TGFiZWwxODg4ODczNzE3",
            "name": "bug",
            "description": "Something isn't working",
            "color": "d73a4a"
          },
          {
            "id": "LA_kwDODpuCgs7olJFv",
            "name": "Moore",
            "description": "",
            "color": "04673D"
          }
        ],
        "number": 7627,
        "state": "CLOSED",
        "title": "[MooreToCore] Unpacked array causes crash",
        "url": "https://github.com/llvm/circt/issues/7627",
        "similarity_score": 6.5
      }
    ]
  },
  "recommendation": {
    "action": "review_existing",
    "confidence": "high",
    "top_issue_number": 9570,
    "reason": "High similarity score indicates potential duplicate"
  }
}