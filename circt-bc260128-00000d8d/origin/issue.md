<!--
  CIRCT Bug Report
  Generated by circt-bug-reporter skill
-->

<!-- Title: [Comb] [Fixed] Assertion failure in ExtractOp::canonicalize (extractConcatToConcatExtract) - use_empty() check failed -->

## Description

**NOTE**: This issue appears to be fixed in the current toolchain. The bug was reported from fuzzing on an older version and no longer reproduces.

CIRCT's Comb dialect assertion failure occurs during `ExtractOp::canonicalize` when processing bit extraction patterns involving `concat` operations. The crash happens in `extractConcatToConcatExtract` when attempting to replace an `ExtractOp` with a single operand from an inner `ConcatOp` that still has other uses.

**Crash Type**: assertion
**Dialect**: Comb
**Failing Pass**: ExtractOp::canonicalize → extractConcatToConcatExtract
**Status**: Not reproducible in current toolchain (likely fixed)

## Root Cause Summary

The bug was in `lib/Dialect/Comb/CombFolds.cpp` in the `extractConcatToConcatExtract` function. When transforming `extract(concat(...))` patterns, if the extraction result equals a single operand of the original `ConcatOp`, the replacement failed to properly handle the use-def chain before erasing the original `ExtractOp`. This caused the `eraseOp` assertion to fail because the operation still had phantom uses.

**Assertion**:
```
Assertion `op->use_empty() && "expected 'op' to have no uses"' failed.
Location: mlir/lib/IR/PatternMatch.cpp:156 in mlir::RewriterBase::eraseOp(Operation *)
```

## Steps to Reproduce (Historical)

**Note**: The following command triggered the crash on an older version of CIRCT. The bug no longer reproduces on the current toolchain.

1. Save test case below as `test.sv`
2. Run:
   ```bash
   circt-verilog --ir-hw test.sv | arcilator | opt -O0 | llc -O0 --filetype=obj -o test.o
   ```

## Test Case

```systemverilog
module counter(
  input logic clk,
  input logic rst,
  output logic [8:0] data_out
);

  // State type and variables
  typedef enum logic {STATE_A, STATE_B} state_t;
  state_t current_state, next_state;

  // 2D array for computation
  logic [1:0][1:0] temp_arr;

  // Array computation
  always_comb begin
    temp_arr[0][0] = (data_out[0] & data_out[1]);
  end

  // State transition logic
  always_comb begin
    if (temp_arr[0][0])
      next_state = STATE_A;
    else
      next_state = STATE_B;
  end

  // Sequential state update
  always_ff @(posedge clk or posedge rst) begin
    if (rst)
      current_state <= STATE_B;
    else
      current_state <= next_state;
  end

  // Counter output
  always_ff @(posedge clk or posedge rst) begin
    if (rst)
      data_out <= 9'b0;
    else
      data_out <= data_out + 1'b1;
  end

endmodule
```

## Error Output (Historical)

```
circt-verilog: /path/to/circt-1.139.0-src/llvm/mlir/lib/IR/PatternMatch.cpp:156: virtual void mlir::RewriterBase::eraseOp(Operation *): Assertion `op->use_empty() && "expected 'op' to have no uses"' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
  Program arguments: /edazz/FeatureFuzz-SV/target/circt-1.139.0/bin/circt-verilog --ir-hw /tmp/featurefuzz_sv_xfhtv50x/test_72961b4c194b.sv
  #0 0x00005622f886cdc3 circt::replaceOpAndCopyNamehint(mlir::PatternRewriter&, mlir::Operation*, mlir::Value) /home/zhiqing/edazz/FeatureFuzz-SV/target/circt-1.139.0-src/lib/Support/Naming.cpp:82:1
  #1 0x00005622f80b9f4f extractConcatToConcatExtract(circt::comb::ExtractOp, circt::comb::ConcatOp, mlir::PatternRewriter&) /home/zhiqing/edazz/FeatureFuzz-SV/target/circt-1.139.0-src/lib/Dialect/Comb/CombFolds.cpp:548:3
  #2 0x00005622f80b9f4f circt::comb::ExtractOp::canonicalize(circt::comb::ExtractOp, mlir::PatternRewriter&) /home/zhiqing/edazz/FeatureFuzz-SV/target/circt-1.139.0-src/lib/Dialect/Comb/CombFolds.cpp:615:12
  #3 0x00005622f948c1f4 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_0::operator()() const /home/zhiqing/edazz/FeatureFuzz-SV/target/circt-1.139.0-src/llvm/mlir/lib/Rewrite/PatternApplicator.cpp:223:13
  ...
```

## Root Cause Analysis

### Primary Issue: Use-Before-Replace in `extractConcatToConcatExtract`

The function `extractConcatToConcatExtract` in `CombFolds.cpp` transforms:
```
extract(lo, cat(a, b, c, d, e)) → cat(extract(lo1, b), c, extract(lo2, d))
```

**Bug Location**: Lines 546-551 in `CombFolds.cpp`:
```cpp
if (reverseConcatArgs.size() == 1) {
  replaceOpAndCopyNamehint(rewriter, op, reverseConcatArgs[0]);
} else {
  replaceOpWithNewOpAndCopyNamehint<ConcatOp>(
      rewriter, op, SmallVector<Value>(llvm::reverse(reverseConcatArgs)));
}
```

**The Problem**:
When `reverseConcatArgs.size() == 1`, the replacement value `reverseConcatArgs[0]` may be an operand of the original `ConcatOp` (`innerCat`). If this operand is also used elsewhere in the IR (e.g., by another extract or concat itself), directly replacing without properly handling the use-def chain causes the assertion.

**Specifically**:
1. `extractConcatToConcatExtract` collects values from `innerCat.getInputs()`
2. When only one value is needed (the extraction spans exactly one operand), it directly uses that concat operand
3. If that operand has multiple uses, and the replacement doesn't properly forward all uses, original `ExtractOp` may retain phantom uses during the erase phase

### Recommended Fix Direction

1. **Verify no self-reference**: Before replacing with `reverseConcatArgs[0]`, ensure it's not a value that could create circular dependencies
2. **Use `replaceAllUsesWith` explicitly** before erasure when dealing with values from original concat operands
3. **Add defensive check**: Verify `op->use_empty()` before calling `replaceOp`, and if not empty, investigate or defer the transformation

## Environment

- **CIRCT Version (original)**: 1.139.0 with LLVM 22.0.0git
- **CIRCT Version (current)**: 1.139.0 (bug no longer reproduces)
- **OS**: Linux
- **Architecture**: x86_64

## Reproduction Status

| Test | Result |
|------|--------|
| **Historical crash** | ✅ Reproduced on older CIRCT 1.139.0 (FeatureFuzz-SV) |
| **Current toolchain** | ❌ NOT REPRODUCED - Bug appears to be fixed |
| **IR Generation** | ✅ Success |
| **Canonicalization** | ✅ No assertion failure |

## Files Involved

- `lib/Dialect/Comb/CombFolds.cpp` (lines 475-553) - `extractConcatToConcatExtract`
- `lib/Support/Naming.cpp` (lines 73-82) - `replaceOpAndCopyNamehint`
- `llvm/mlir/lib/IR/PatternMatch.cpp` (line 156) - assertion location

## Testcase Metadata

- **Testcase ID**: 260128-00000d8d
- **Discovered by**: FeatureFuzz-SV
- **Triggering constructs**: Bit extraction, AND operation, 2D array assignment
- **IR operations**: comb.extract, comb.concat, comb.and

---
*This issue was generated with assistance from an automated bug reporter. The bug appears to be fixed in the current toolchain.*
