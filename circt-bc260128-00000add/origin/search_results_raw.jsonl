{"body":"## Title\n[circt-verilog][arcilator] `arcilator` fails to lower `llhd.constant_time` generated from simple SV delay (`#1`)\n\n## Summary\nI ran into a failure in the arcilator flow with a minimal SystemVerilog module using a single `#1` delay. The same design runs under Verilator, but arcilator reports `llhd.constant_time` as illegal during conversion to `arcs` and stops. I did a preliminary source-level analysis (below) and would like to discuss with maintainers whether this behavior is expected or should be treated as a bug.\n\n## Details\n\nThe SV design is intentionally minimal and only uses an `initial` block with a\nsingle `#1` delay. There are no clocks, resets, or inputs. The only signals are\ntwo outputs (`q` and `ok`) to indicate observable state and a success message.\n\nBehavior:\n- At time 0, both `q` and `ok` are set to `0`.\n- After `#1`, `q` is set to `1`, `ok` is set to `1`, and a `$display` message is\n  printed.\n\nObserved issue:\n- `circt-verilog --ir-hw` converts the `#1` delay into `llhd.constant_time`.\n- The arcilator pipeline then fails when lowering to `arcs`, reporting that\n  `llhd.constant_time` is illegal and the conversion fails.\n- The same SV code runs successfully under Verilator, so the issue appears\n  specific to the arcilator lowering path.\n\n\n## Reproduction\n### arcilator\nCreate `top.sv`:\n```systemverilog\nmodule top(output logic q, output logic ok);\n  initial begin\n    q = 1'b0;\n    ok = 1'b0;\n    #1 q = 1'b1;\n    ok = 1'b1;\n    $display(\"OK: arcilator run completed\");\n  end\nendmodule\n```\n\nRun:\n```bash\ncirct-verilog --ir-hw top.sv -o top.mlir\narcilator top.mlir --state-file=top.json | opt -O3 --strip-debug -S | llc -O3 --filetype=obj -o top.o\ncc top.o -o top\n./top\n```\n\n### verilator\nUse the same `top.sv` content as above.\n\nRun:\n```bash\nverilator -Wall --cc top.sv --exe sim_main.cpp\nmake -C obj_dir -f Vtop.mk Vtop\n./obj_dir/Vtop\n```\n\n## Actual Result (arcilator)\n```\ntop.mlir:4:10: error: failed to legalize operation 'llhd.constant_time' that was explicitly marked illegal\n    %0 = llhd.constant_time <1000000fs, 0d, 0e>\n         ^\ntop.mlir:1:1: error: conversion to arcs failed\nmodule {\n^\n```\n\n## Expected Result\nThe minimal delay should either:\n- be supported by arcilator, or\n- be lowered to something legal for `arcs` without failing.\n\n### Question:\nHow to solve this problem and simulate this sv problem?\n\n## Analysis of Failure Cause\nBased on the current sources, my preliminary analysis is that the failure stems from a missing legalization pattern in the `ConvertToArcs` pass:\n- `llhd.constant_time` is a valid LLHD op produced by `circt-verilog --ir-hw` for `#1` delays.\n- The arcilator pipeline runs `ConvertToArcs`, which marks the entire LLHD dialect illegal and only provides conversions for `llhd.combinational` and `llhd.yield`.\n\nhttps://github.com/llvm/circt/blob/3c58046f1d8fc6f5355a7f2c2b73b43ffb37ba4d/lib/Conversion/ConvertToArcs/ConvertToArcs.cpp#L567-L585\n\n- As a result, `llhd.constant_time` remains illegal with no rewrite available, and the dialect conversion reports a legalization failure.\n\n\n## Environment\n- OS: Linux 5.15.0-164-generic\n- CIRCT: firtool-1.139.0\n- LLVM: 22.0.0git\n- Verilator: 5.022 2024-02-24 (rev v5.020-157-g2b4852048)\n- Git commit: 2e2f4775452d1e0bb2c8075d845808f781268049\n\n## Notes\nThe failure appears at the `llhd.constant_time` op introduced during `circt-verilog --ir-hw`, before `arcilator` lowers to `arcs`.\n\n## Relevant Source References\n- `llhd.constant_time` is a core LLHD op that materializes a time constant. It is defined as `llhd.constant_time` in the LLHD value ops definition file. See `include/circt/Dialect/LLHD/IR/LLHDValueOps.td`.\n- The `ConvertToArcs` pass marks the entire LLHD dialect as illegal and only provides conversion patterns for `llhd.combinational` and `llhd.yield`. This means any other LLHD ops (including `llhd.constant_time`) remain illegal and will trigger a legalization failure. See `lib/Conversion/ConvertToArcs/ConvertToArcs.cpp`.\n- The arcilator pipeline explicitly runs `ConvertToArcs` as part of its arc conversion pipeline. See `lib/Tools/arcilator/pipelines.cpp`.\n","labels":[{"id":"MDU6TGFiZWwyMTY1NDc5NTk1","name":"LLHD","description":"","color":"e07b00"},{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":9467,"state":"OPEN","title":"[circt-verilog][arcilator] `arcilator` fails to lower `llhd.constant_time` generated from simple SV delay (`#1`)","url":"https://github.com/llvm/circt/issues/9467"}
{"body":"Should we call the passthrough after all arc.clock_tree calling? Take an output connected with a register for example, the output should be the latest value of the register after a clock trigger.","labels":[{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":9337,"state":"OPEN","title":"[arcilator] The position of the passthrough calling","url":"https://github.com/llvm/circt/issues/9337"}
{"body":"It looks like there are two configs of the Upload Release Artifacts CI job where check-circt fails on three arcilator tests:\n\nhttps://github.com/llvm/circt/actions/runs/19579832326/job/56099287786\n\nNot sure what changed since the last run of this CI action that causes the crash. @jpienaar could this be related to the additional arguments that are now getting passed to the simulation if run in JIT mode?","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":9260,"state":"OPEN","title":"Arcilator crashes in Upload Release Artifacts CI","url":"https://github.com/llvm/circt/issues/9260"}
{"body":"There are a bunch of features we might want to support for arcilator simulations that are a pain to implement in MLIR / LLVM IR directly and should preferably made available by a runtime library. Off the top of my head, this could include:\n- Advanced formatted printing (arbitrary width integers, binary formatting, padding, X/Z values)\n- Everything involving the file system\n- Parsing memory initialization files\n- Managing dynamic buffers and containers\n- PRNG algorithms and seeding for reproducible random initialization\n- Multi-threading (enqueue a series of simulation runs and dispatch them to a thread pool)\n\nWe also want these features to be available in JITed runs, so we need to make sure the compiled functions are visible to the execution engine. Depending on the host platform [this can get a little messy](https://github.com/llvm/llvm-project/blob/c6c2e21028cadef854cf22f6ecaa5eb9d224b76d/llvm/cmake/modules/AddLLVM.cmake#L1344). The `arc-jit-env` library (#8483) was an attempt to compile the current header-only implementation in `arcilator-runtime.h` to a shared library. \n\nI've also experimented with a Rust implementation of a runtime library. Admittedly, more out of personal curiosity rather than for technical reasons. Having the Rust Standard Library and cargo available to pull in crates like `num_bigint` certainly is nice to get things done quickly. On the other hand we inevitably have to do a fair amount of unsafe pointer ping-pong between the IR model and the runtime, potentially defeating the whole memory safety aspect of Rust. _If_ we were to go for a Rust implementation we'd also have to figure out to what extent we want to isolate it from the rest. Should we keep the sources in-tree or in a separate project? Should it be integrated in the CMake build process?\n\nBut first of all, we need a lowering pipeline that can make use of such a library. ðŸ˜…","labels":[{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":8484,"state":"OPEN","title":"[arcilator] Add functionality to the arcilator runtime library","url":"https://github.com/llvm/circt/issues/8484"}
{"body":"The arcilator-runtime.h and python script are not installed and thus not included in pre-built releases.\n\nFor more information:\nhttps://discourse.llvm.org/t/proper-way-to-obtain-arcilator-runtime-h-for-c-integration/84553","labels":[{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":8212,"state":"OPEN","title":"[arcilator] Install configuration missing for arcilator-runtime.h","url":"https://github.com/llvm/circt/issues/8212"}
{"body":"@fabianschuiki, @maerhart and I noticed while debugging some conversion that adding the flag `-DMLIR_ENABLE_EXPENSIVE_PATTERN_API_CHECKS=ON` to a CIRCT LLVM build exposes several places where our passes are using the MLIR rewriter/pattern API invalidly.\n\nRunning `ninja check-circt` produces failures on the following tests:\n\n```\nCIRCT :: Conversion/ArcToLLVM/lower-arc-to-llvm.mlir\nCIRCT :: Conversion/CombToArith/comb-to-arith.mlir\nCIRCT :: Conversion/ConvertToArcs/convert-to-arcs.mlir\nCIRCT :: Conversion/HWToLLVM/convert_aggregates.mlir\nCIRCT :: Conversion/LoopScheduleToCalyx/convert_pipeline.mlir\nCIRCT :: Conversion/LoopScheduleToCalyx/pipeline_register_pass.mlir\nCIRCT :: Conversion/SCFToCalyx/cider_source_location.mlir\nCIRCT :: Conversion/SCFToCalyx/convert_controlflow.mlir\nCIRCT :: Conversion/SCFToCalyx/convert_func.mlir\nCIRCT :: Conversion/SCFToCalyx/convert_memory.mlir\nCIRCT :: Conversion/SCFToCalyx/convert_simple.mlir\nCIRCT :: Conversion/SCFToCalyx/errors.mlir\nCIRCT :: Conversion/SCFToCalyx/float_compare.mlir\nCIRCT :: Conversion/SCFToCalyx/write_memory.mlir\nCIRCT :: Dialect/Arc/arc-canonicalizer.mlir\nCIRCT :: Dialect/Arc/canonicalizers.mlir\nCIRCT :: Dialect/Arc/lower-sim.mlir\nCIRCT :: Dialect/Calyx/affine-ploop-unparallelize.mlir\nCIRCT :: Dialect/Calyx/canonicalization.mlir\nCIRCT :: Dialect/FIRRTL/canonicalization.mlir\nCIRCT :: Dialect/LLHD/Canonicalization/processes.mlir\nCIRCT :: Transforms/memory_banking.mlir\nCIRCT :: Transforms/memory_banking_attrs.mlir\nCIRCT :: Transforms/memory_banking_multi_config.mlir\nCIRCT :: Transforms/memory_banking_multi_dim.mlir\nCIRCT :: arcilator/arcilator.mlir\nCIRCT :: arcilator/compreg.mlir\nCIRCT :: arcilator/emit-values.mlir\n\n```","labels":[],"number":9191,"state":"OPEN","title":"MLIR pattern checks failing","url":"https://github.com/llvm/circt/issues/9191"}
{"body":"Hi all!\n\nI am trying to simulate a SystemVerilog code (listed below) using `arcilator`:\n\n```verilog\nmodule dff(D, clk, Q);\n    input D; // Data input \n    input clk; // clock input \n    output reg Q; // output Q\n\n    // Simple DFF\n    always @(negedge clk) \n    begin\n        Q <= D; \n    end \nendmodule\n```\n\n with such pipeline:\n\n```bash\ncirct-verilog dff.sv | arcilator\n```\n\n`arcilator` fails with  **error: 'llhd.process' op has regions; not supported by ConvertToArcs**\n\nThen I try to use a different pipeline with `circt-opt` :\n\n```bash\ncirct-verilog dff.sv | circt-opt --llhd-early-code-motion --llhd-temporal-code-motion --llhd-desequentialize --llhd-sig2reg -canonicalize | arcilator\n```\n\n`acilator` fails with another **error: failed to legalize operation 'seq.clock_inv'**\n\nWhat is necessary to be able to run `arcilator` on such simple `DFF` example? \n","labels":[],"number":8012,"state":"OPEN","title":"[Moore][Arc][LLHD] Moore to LLVM lowering issues","url":"https://github.com/llvm/circt/issues/8012"}
{"body":"Hi! I'm trying to use circt for lowering to LLVM IR. I found such a construction in some example:\n\n```verilog\nmodule Mod (input clk, input a, input b, output logic[1:0] c);\nalways_ff @(posedge clk) begin\n    c[0] <= a;\n    c[1] <= b;\nend\nendmodule\n```\n\nI used this pipeline:\n\n```bash\ncirct-verilog ranges.sv | circt-opt --llhd-early-code-motion --llhd-temporal-code-motion --llhd-desequentialize --llhd-sig2reg --canonicalize | arcilator\n```\n\nBut I got error **body contains non-pure operation** in `arcilator`. Also I had same error when I tried to use slicing instead of indexing. What needs to be done to run `arcilator` successfully?","labels":[],"number":8065,"state":"OPEN","title":"[LLHD][Arc] Indexing and slicing lowering from Verilog to LLVM IR","url":"https://github.com/llvm/circt/issues/8065"}
{"body":"Hi all!\n\nThere are a few issues related to moore to llvm lowering pipeline.\n\nCurrently there is no possibility to lower combination logic with control flow operators into LLVM. For example:\n\n```verilog\nmodule  top  (\n    input           clk ,\n    input           rstn ,\n    input      in\n    output     out\n    );\n\n    parameter            P1   = 3'd0 ;\n    parameter            P2  = 3'd3 ;\n\n    reg [2:0]            r1 = 3'd1;\n\n    always_comb begin\n        if (in)\n            r1 = P1;\n        else\n            r1 = P2;\n    end\nendmodule\n```\n\nbecause it fails with this : `error: failed to legalize operation 'llhd.constant_time'`\n\nAnd also `arcilator` fails to lower sequential logic which contains both blocking and nonblocking assignments like this example:\n\n```verilog\nmodule  top  (\n    input           clk ,\n    input           rstn ,\n    input      in\n    output     out\n    );\n\n    parameter            P1   = 3'd0 ;\n    parameter            P2  = 3'd3 ;\n\n    reg [2:0]            r1 = 3'd1;\n\n    always @(posedge clk or negedge rstn) begin\n        r1 = P1;\n        r1 <= P2 + r1;\n    end\n\nendmodule\n```\n\nbecause it fails with that:\n\n```\n error: body contains non-pure operation\n    %2 = comb.add %1, %c3_i3 : i3\n```\n\nI'm using to lower a such cmd:\n\n```\ncirct-verilog sample.sv | arcilator \n```\n\nAlso I tried to add into \"populate LLHD\" pipeline a newly added passes  -- \"llhd-hoist-signals\" and \"llhd-mem2reg\". It didn't help.\n\nMaybe I'm doing something wrong or what could be the issue?\n\n1) What are the plans for improving verilog-to-llvm lowering  and do they exist at all?\n2) Will the \"llhd-hoist-signals\" and \"llhd-mem2reg\" passes be added to the `circt-verilog` tool or will they stay standalone?\n\n@fabianschuiki @maerhart ","labels":[],"number":8286,"state":"OPEN","title":"[circt-verilog][llhd][arcilator] Verilog-to-LLVM lowering issues","url":"https://github.com/llvm/circt/issues/8286"}
{"body":"Hi,\n\nIn #7929 , I refactored the C++ header generator Python script for the C++ code that wants to call the LLVM IR produced by `arcilator`. The PR mainly refactors its structure, paving the way for future modularization.\n\nThe reason for making it modular is that the script contains some core functions that can serve as a reusable library for other scripts. My proposals are as follows:\n\n1. **Splitting the C++ header generator script**\n   - **Core module**: Extract the generic logic for interacting with arcilator's state json and encapsulate it into a standalone Python module.\n   - **Header file generator**: Import core module and only do things around generating C++ headers.\n\n2. **Introducing a Python simulation script generator**\n   - Develop a Python script that utilizes the core module to generate Python simulation scripts. These scripts will use `llvmlite` to execute the LLVM IR generated by `arcilator`.\n   - The generated scripts will provide a simulation interface inspired by Chisel, including `poke` and `peek` methods. The generated scripts is like the generated C++ header and is used by other testbenches written in Python.\n   - Possible use cases: Enable rapid functional validation of circuits with minimal effort, leveraging Pythonâ€™s expressive syntax for quick and intuitive simulations. With a Python interface, users could efficiently automate simulation workflows and write high-level test scripts.\n\nBefore proceeding, I would greatly appreciate your feedback on this proposal.\n\nThank you for your time and guidance!  \n\nRegards\n","labels":[],"number":7942,"state":"OPEN","title":"[Arc] Introduce a Python simulation script generator for arcilator","url":"https://github.com/llvm/circt/issues/7942"}
{"body":"Arcilator is currently very easy to break if a public module is instantiated anywhere. In that case the module hierarchy does not get flattened completely, but the public module remains as an instance instead. This makes the instance behave like an external module. Fix the module flattening to also fully inline public modules (but instead also keep the public module itself around as a top-level entry point).","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":8232,"state":"OPEN","title":"[Arc] Flatten public modules","url":"https://github.com/llvm/circt/issues/8232"}
{"body":"When i run `arcilator` with `$ ./arcilator a.mlir --state-file=a.json` i get the following error:\r\n```\r\na.mlir:9:23: error: 'arc.tap' op operand #0 must be signless integer, but got '!hw.struct<valid: i1, bits: i1>'\r\n    %_registers_0_T = hw.wire %2 sym @sym_0  : !hw.struct<valid: i1, bits: i1>\r\n                      ^\r\na.mlir:9:23: note: see current operation: \"arc.tap\"(%5) {name = \"_registers_0_T\"} : (!hw.struct<valid: i1, bits: i1>) -> ()\r\n```\r\n\r\n`a.mlir`:\r\n```\r\nmodule {\r\n  hw.module @Barrier(in %clock : !seq.clock, in %reset : i1, in %io_input : !hw.array<1xstruct<valid: i1, bits: i1>>, out io_output : !hw.array<1xstruct<valid: i1, bits: i1>>) {\r\n    %false = hw.constant false\r\n    %0 = hw.array_get %io_input[%false] : !hw.array<1xstruct<valid: i1, bits: i1>>, i1\r\n    %valid = hw.struct_extract %0[\"valid\"] : !hw.struct<valid: i1, bits: i1>\r\n    %registers = seq.firreg %3 clock %clock sym @sym {firrtl.random_init_start = 0 : ui64} : !hw.array<1xstruct<valid: i1, bits: i1>>\r\n    %1 = hw.array_get %registers[%false] : !hw.array<1xstruct<valid: i1, bits: i1>>, i1\r\n    %2 = comb.mux bin %valid, %0, %1 : !hw.struct<valid: i1, bits: i1>\r\n    %_registers_0_T = hw.wire %2 sym @sym_0  : !hw.struct<valid: i1, bits: i1>\r\n    %3 = hw.array_create %_registers_0_T : !hw.struct<valid: i1, bits: i1>\r\n    hw.output %registers : !hw.array<1xstruct<valid: i1, bits: i1>>\r\n  }\r\n}\r\n```\r\n\r\n","labels":[{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":6373,"state":"OPEN","title":"[Arc] Support hw.wires of aggregate types","url":"https://github.com/llvm/circt/issues/6373"}
{"body":"Currently, CIRCT's MooreToCore pass converts unpacked arrays to packed arrays (hw::ArrayType),\nlosing the unpacked semantics.\n\nWhen we've attempted to preserve unpacked arrays by emitting hw::UnpackedArrayType,\nMLIR raises \"failed to legalize operation\" errors.\n\n## Minimal Reproduction\n\nWhen running `circt-opt` on the following input,\n\n```systemverilog\nmodule a (\n  input logic b[3:0]\n);\nendmodule\n```\n\nwe get the following result:\n\n```mlir\nmodule {\n  hw.module @a(in %b : !hw.array<4xi1>) {\n    hw.output\n  }\n}\n```\n\nas you can clearly see, the `uarray` is converted to a `array`.\n","labels":[],"number":8276,"state":"OPEN","title":"[MooreToCore] Support for UnpackedArrayType emission","url":"https://github.com/llvm/circt/issues/8276"}
{"body":"Add support for `verif.assert` and `sv.assert.concurrent` operations to the Arc dialect and passes. When lowering towards LLVM, the asserts should lower to an `scf.if` operation that checks whether their condition holds, and if it does not, calls a callback function (or aborts with a message for starters).\r\n\r\nThis is likely to uncover a lot of details about how clocked and unclocked asserts need to be handled, and where they have to be scheduled and checked in the simulation model.","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIx","name":"good first issue","description":"Good for newcomers","color":"7057ff"},{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":6810,"state":"OPEN","title":"[Arc] Add basic assertion support","url":"https://github.com/llvm/circt/issues/6810"}
{"body":"Unsized array type in systemverilog like `OpenArrayType`, `QueueType` can't be lower to Arc Dialect, because Arc only has sized array type. \n\nCommon programming language like `Cpp` can directly call `mmap` provided by OS to get dynamic size array. I can't see this kind of ability in systemverilog.\n\nSo how to achieve that if we want to solve #8276? Can you give me some advice?","labels":[],"number":8292,"state":"OPEN","title":"[MooreToCore] Support for Unsized Array Type","url":"https://github.com/llvm/circt/issues/8292"}
{"body":"Lowering the following with `circt-verilog`\n```sv\nmodule combo (  input   a, b, c, d, e,  output  reg z);\n\n        always @ (*) begin\n                z = ((a & b) | (c ^ d) & ~e);\n        end\n\nendmodule\n```\nresults in this MLIR:\n```mlir\n  hw.module @combo(in %a : i1, in %b : i1, in %c : i1, in %d : i1, in %e : i1, out z : i1) {\n    %0 = llhd.constant_time <0ns, 0d, 1e>\n    %true = hw.constant true\n    %false = hw.constant false\n    %a_0 = llhd.sig name \"a\" %false : i1\n    %1 = llhd.prb %a_0 : !hw.inout<i1>\n    %b_1 = llhd.sig name \"b\" %false : i1\n    %2 = llhd.prb %b_1 : !hw.inout<i1>\n    %c_2 = llhd.sig name \"c\" %false : i1\n    %3 = llhd.prb %c_2 : !hw.inout<i1>\n    %d_3 = llhd.sig name \"d\" %false : i1\n    %4 = llhd.prb %d_3 : !hw.inout<i1>\n    %e_4 = llhd.sig name \"e\" %false : i1\n    %5 = llhd.prb %e_4 : !hw.inout<i1>\n    %z = llhd.sig %false : i1\n    llhd.process {\n      cf.br ^bb1\n    ^bb1:  // 3 preds: ^bb0, ^bb2, ^bb3\n      %7 = llhd.prb %a_0 : !hw.inout<i1>\n      %8 = llhd.prb %b_1 : !hw.inout<i1>\n      %9 = llhd.prb %c_2 : !hw.inout<i1>\n      %10 = llhd.prb %d_3 : !hw.inout<i1>\n      %11 = llhd.prb %e_4 : !hw.inout<i1>\n      llhd.wait (%1, %2, %3, %4, %5 : i1, i1, i1, i1, i1), ^bb2\n    ^bb2:  // pred: ^bb1\n      %12 = llhd.prb %a_0 : !hw.inout<i1>\n      %13 = comb.icmp bin ne %7, %12 : i1\n      %14 = llhd.prb %b_1 : !hw.inout<i1>\n      %15 = comb.icmp bin ne %8, %14 : i1\n      %16 = llhd.prb %c_2 : !hw.inout<i1>\n      %17 = comb.icmp bin ne %9, %16 : i1\n      %18 = llhd.prb %d_3 : !hw.inout<i1>\n      %19 = comb.icmp bin ne %10, %18 : i1\n      %20 = llhd.prb %e_4 : !hw.inout<i1>\n      %21 = comb.icmp bin ne %11, %20 : i1\n      %22 = comb.or bin %13, %15, %17, %19, %21 : i1\n      cf.cond_br %22, ^bb3, ^bb1\n    ^bb3:  // pred: ^bb2\n      %23 = llhd.prb %a_0 : !hw.inout<i1>\n      %24 = llhd.prb %b_1 : !hw.inout<i1>\n      %25 = comb.and %23, %24 : i1\n      %26 = llhd.prb %c_2 : !hw.inout<i1>\n      %27 = llhd.prb %d_3 : !hw.inout<i1>\n      %28 = comb.xor %26, %27 : i1\n      %29 = llhd.prb %e_4 : !hw.inout<i1>\n      %30 = comb.xor %29, %true : i1\n      %31 = comb.and %28, %30 : i1\n      %32 = comb.or %25, %31 : i1\n      llhd.drv %z, %32 after %0 : !hw.inout<i1>\n      cf.br ^bb1\n    }\n    llhd.drv %a_0, %a after %0 : !hw.inout<i1>\n    llhd.drv %b_1, %b after %0 : !hw.inout<i1>\n    llhd.drv %c_2, %c after %0 : !hw.inout<i1>\n    llhd.drv %d_3, %d after %0 : !hw.inout<i1>\n    llhd.drv %e_4, %e after %0 : !hw.inout<i1>\n    %6 = llhd.prb %z : !hw.inout<i1>\n    hw.output %6 : i1\n  }\n```\n\n`%22` will always evaluate to `true` because the wait operation will only branch if one of its sensitivity values changes. We should add a folder/canonicalizer that performs this simplification.\n\nThe code responsible for generating this pattern is in MooreToCore in the WaitEventOp lowering pattern.","labels":[{"id":"MDU6TGFiZWwyMTY1NDc5NTk1","name":"LLHD","description":"","color":"e07b00"}],"number":8013,"state":"OPEN","title":"[LLHD] Canonicalizer for processes produced by always @(*)","url":"https://github.com/llvm/circt/issues/8013"}
{"body":"For input (derived from SV import minized and then MLIR minized)\n\n```mlir\nmodule {\n  hw.module @a() {\n    %false = hw.constant false\n    %b = llhd.sig %false : i1\n    llhd.combinational {\n      cf.br ^bb2\n    ^bb1:  // no predecessors\n      %0 = llhd.prb %b : !hw.inout<i1>\n      %1 = llhd.constant_time <0ns, 0d, 1e>\n      %g = llhd.sig %false : i1\n      llhd.drv %g, %0 after %1 : !hw.inout<i1>\n      cf.br ^bb2\n    ^bb2:  // 2 preds: ^bb0, ^bb1\n      llhd.yield\n    }\n    hw.output\n  }\n}\n```\n\nresults post llhd-mem2reg in\n\n```\nerror: operand #0 does not dominate this use\nnote: see current operation: \"llhd.drv\"(%6, %7, %9, %8) : (!hw.inout<i1>, i1, !llhd.time, i1) -> ()\n/tmp/t2.mlir:10:12: note: operand defined here (op in the same region)\n      %g = llhd.sig %false : i1\n           ^\n```\n\nprint IR after:\n\n```mlir\n\"builtin.module\"() ({\n  \"hw.module\"() <{module_type = !hw.modty<>, parameters = [], sym_name = \"a\"}> ({\n    %0 = \"hw.constant\"() <{value = false}> : () -> i1\n    %1 = \"llhd.sig\"(%0) <{name = \"b\"}> : (i1) -> !hw.inout<i1>\n    %2 = \"llhd.prb\"(%1) : (!hw.inout<i1>) -> i1\n    \"llhd.combinational\"() ({\n      %3 = \"hw.constant\"() <{value = false}> : () -> i1\n      %4 = \"hw.constant\"() <{value = false}> : () -> i1\n      \"cf.br\"(%3, %4)[^bb2] : (i1, i1) -> ()\n    ^bb1:  // no predecessors\n      %5 = \"hw.constant\"() <{value = true}> : () -> i1\n      %6 = \"llhd.sig\"(%0) <{name = \"g\"}> : (i1) -> !hw.inout<i1>\n      \"cf.br\"(%2, %5)[^bb2] : (i1, i1) -> ()\n    ^bb2(%7: i1, %8: i1):  // 2 preds: ^bb0, ^bb1\n      %9 = \"llhd.constant_time\"() <{value = #llhd.time<0ns, 0d, 1e>}> : () -> !llhd.time\n      \"llhd.drv\"(%6, %7, %9, %8) : (!hw.inout<i1>, i1, !llhd.time, i1) -> ()\n      // ^\n      \"llhd.yield\"() : () -> ()\n    }) : () -> ()\n    \"hw.output\"() : () -> ()\n  }) : () -> ()\n}) : () -> ()\n```","labels":[{"id":"MDU6TGFiZWwyMTY1NDc5NTk1","name":"LLHD","description":"","color":"e07b00"}],"number":8693,"state":"OPEN","title":"[Mem2Reg] Local signal does not dominate final drive","url":"https://github.com/llvm/circt/issues/8693"}
{"body":"The following MLIR (bear with me there's potentially a lot of un-important parts of this IR):\r\n\r\n```mlir\r\nmodule attributes {circt.loweringOptions = \"locationInfoStyle=none\"} {\r\n    hw.module @Main(%IA: i2, %IB: i2, %IS: i1) -> (O: i2) {\r\n        %0 = hw.constant 0 : i2\r\n        %1 = hw.constant 1 : i2\r\n        %2 = hw.constant 0 : i1\r\n        %3 = comb.extract %IA from 0 : (i2) -> i1\r\n        %4 = comb.extract %IA from 1 : (i2) -> i1\r\n        %5 = comb.extract %IB from 0 : (i2) -> i1\r\n        %6 = hw.constant 1 : i1\r\n        %7 = comb.extract %IB from 1 : (i2) -> i1\r\n        %14 = sv.reg : !hw.inout<i2>\r\n        %8 = sv.read_inout %14 : !hw.inout<i2>\r\n        %15 = sv.reg : !hw.inout<i2>\r\n        %9 = sv.read_inout %15 : !hw.inout<i2>\r\n        %16 = sv.reg : !hw.inout<i1>\r\n        %10 = sv.read_inout %16 : !hw.inout<i1>\r\n        %17 = sv.reg : !hw.inout<i1>\r\n        %11 = sv.read_inout %17 : !hw.inout<i1>\r\n        %18 = sv.reg : !hw.inout<i1>\r\n        %12 = sv.read_inout %18 : !hw.inout<i1>\r\n        %19 = sv.reg : !hw.inout<i1>\r\n        %13 = sv.read_inout %19 : !hw.inout<i1>\r\n        sv.alwayscomb {\r\n            sv.if %IS {\r\n                sv.bpassign %16, %2 : i1\r\n                sv.bpassign %17, %2 : i1\r\n                sv.bpassign %18, %5 : i1\r\n                sv.bpassign %19, %7 : i1\r\n            } else {\r\n                sv.bpassign %16, %3 : i1\r\n                sv.bpassign %17, %4 : i1\r\n                sv.bpassign %18, %6 : i1\r\n                sv.bpassign %19, %2 : i1\r\n            }\r\n        }\r\n        %20 = comb.concat %11, %11, %10 : i1, i1, i1\r\n        %21 = comb.concat %13, %13, %12 : i1, i1, i1\r\n        %22 = comb.add %20, %21 : i3\r\n        %23 = comb.extract %22 from 1 : (i3) -> i1\r\n        %24 = comb.extract %22 from 2 : (i3) -> i1\r\n        %25 = comb.concat %24, %23 : i1, i1\r\n        %26 = hw.constant 1 : i2\r\n        %27 = comb.icmp eq %25, %26 : i2\r\n        %28 = hw.constant 1 : i2\r\n        %29 = comb.concat %24, %23 : i1, i1\r\n        %30 = hw.constant -2 : i2\r\n        %31 = comb.icmp eq %29, %30 : i2\r\n        %32 = hw.constant 2 : i2\r\n        %33 = hw.constant 1 : i1\r\n        %34 = hw.constant 0 : i1\r\n        %35 = comb.extract %22 from 0 : (i3) -> i1\r\n        %39 = sv.reg : !hw.inout<i2>\r\n        %36 = sv.read_inout %39 : !hw.inout<i2>\r\n        %40 = sv.reg : !hw.inout<i1>\r\n        %37 = sv.read_inout %40 : !hw.inout<i1>\r\n        %41 = sv.reg : !hw.inout<i1>\r\n        %38 = sv.read_inout %41 : !hw.inout<i1>\r\n        sv.alwayscomb {\r\n            sv.if %27 {\r\n                sv.bpassign %40, %33 : i1\r\n                sv.bpassign %41, %34 : i1\r\n            } else {\r\n                sv.if %31 {\r\n                    sv.bpassign %40, %34 : i1\r\n                    sv.bpassign %41, %33 : i1\r\n                } else {\r\n                    sv.bpassign %40, %35 : i1\r\n                    sv.bpassign %41, %23 : i1\r\n                }\r\n            }\r\n        }\r\n        %42 = comb.concat %38, %37 : i1, i1\r\n        hw.output %42 : i2\r\n    }\r\n}\r\n```\r\n\r\nproduces the following Verilog:\r\n\r\n```verilog\r\n// Generated by CIRCT circtorg-0.0.0-1018-g3a39b339f\r\nmodule Main(\r\n  input  [1:0] IA,\r\n               IB,\r\n  input        IS,\r\n  output [1:0] O);\r\n\r\n  reg _GEN;\r\n  reg _GEN_0;\r\n  reg _GEN_1;\r\n  reg _GEN_2;\r\n  reg _GEN_3;\r\n  reg _GEN_4;\r\n  always_comb begin\r\n    automatic logic [2:0] _GEN_5;\r\n    _GEN_5 = {{2{_GEN_0}}, _GEN} + {{2{_GEN_2}}, _GEN_1};\r\n    if (IS) begin\r\n      _GEN = 1'h0;\r\n      _GEN_0 = 1'h0;\r\n      _GEN_1 = IB[0];\r\n      _GEN_2 = IB[1];\r\n    end\r\n    else begin\r\n      _GEN = IA[0];\r\n      _GEN_0 = IA[1];\r\n      _GEN_1 = 1'h1;\r\n      _GEN_2 = 1'h0;\r\n    end\r\n    if (_GEN_5[2:1] == 2'h1) begin\r\n      _GEN_3 = 1'h1;\r\n      _GEN_4 = 1'h0;\r\n    end\r\n    else if (_GEN_5[2:1] == 2'h2) begin\r\n      _GEN_3 = 1'h0;\r\n      _GEN_4 = 1'h1;\r\n    end\r\n    else begin\r\n      _GEN_3 = _GEN_5[0];\r\n      _GEN_4 = _GEN_5[1];\r\n    end\r\n  end // always_comb\r\n  assign O = {_GEN_4, _GEN_3};\r\nendmodule\r\n```\r\n\r\nThe issue here is that the add (`%22 = comb.add %20, %21 : i3`) which is outside of the first `always_comb` gets pushed into the *beginning* of the `always_comb` (`_GEN_5 = ... + ...`) in the Verilog, although it depends on register assignments later in that same `always_comb`. This results in a simulation where the add uses old values of the relevant registers.\r\n\r\nI believe that potentially using non-block assignments, *or* moving the add outside of the `always_comb` would fix this issue.","labels":[],"number":4532,"state":"OPEN","title":"[ExportVerilog] always_comb ordering issue","url":"https://github.com/llvm/circt/issues/4532"}
{"body":"A while ago, we have switched the LLHD dialect from a custom `!llhd.sig` wrapper type to `!hw.inout` in order to represent a reference to a signal slot that can be probed and driven. To support Verilog's `time` values, we have to be able to store an `!llhd.time` value in a variable and read and write that variable. Variables are effectively signals, and Verilog variables get mapped to `llhd.sig` allocation operations. These return a reference type. This prevents us from creating `time` variables today, since `!hw.inout` forces `isHWValueType` on the inner type, which `llhd::TimeType` is not.\n\nIdeally, we'd create something like an `!llhd.ref<T>` type to represent a reference to a signal. In the future, we might want to add additional types for multi-driver nets.","labels":[{"id":"MDU6TGFiZWwyMTY1NDc5NTk1","name":"LLHD","description":"","color":"e07b00"}],"number":8825,"state":"OPEN","title":"[LLHD] Switch from hw.inout to a custom signal reference type","url":"https://github.com/llvm/circt/issues/8825"}
{"body":"Cache whether a array or struct contains an inout type, rather than computing it.\r\nProbably want to also cache whether it contains a non-RTL type.","labels":[],"number":391,"state":"OPEN","title":"Cache non-inout bits in composite RTL types","url":"https://github.com/llvm/circt/issues/391"}
{"body":"```mlir\r\n  hw.module @Example(%clock: i1, %foo: !hw.array<3xi2>, %bar: !hw.array<4xi2>) -> (out: !hw.array<3xi1>) {\r\n    %r = sv.reg {hw.verilogName = \"r\"} : !hw.inout<array<3xi1>>\r\n    sv.always posedge %clock {\r\n      %c1_i2 = hw.constant 1 : i2\r\n      %c-1_i2 = hw.constant -1 : i2\r\n      %c0_i2 = hw.constant 0 : i2\r\n      sv.for %i = %c0_i2 to %c-1_i2 step %c1_i2 : i2 {\r\n        %1 = sv.logic {hw.verilogName = \"_GEN\"} : !hw.inout<array<3xi2>>\r\n        %2 = sv.logic {hw.verilogName = \"_GEN_0\"} : !hw.inout<array<3xi2>>\r\n        %3 = hw.aggregate_constant [-2 : i2, 1 : i2, 0 : i2] : !hw.array<3xi2>\r\n        sv.bpassign %1, %3 : !hw.array<3xi2>\r\n        %4 = hw.aggregate_constant [-1 : i2, -2 : i2, 1 : i2] : !hw.array<3xi2>\r\n        sv.bpassign %2, %4 : !hw.array<3xi2>\r\n        %5 = sv.read_inout %2 : !hw.inout<array<3xi2>>\r\n        %6 = hw.array_get %5[%i] : !hw.array<3xi2>, i2\r\n        %7 = sv.read_inout %1 : !hw.inout<array<3xi2>>\r\n        %8 = hw.array_get %7[%i] : !hw.array<3xi2>, i2\r\n        %9 = hw.array_get %bar[%6] : !hw.array<4xi2>, i2\r\n        %10 = hw.array_get %foo[%8] : !hw.array<3xi2>, i2\r\n        %11 = comb.xor bin %9, %10 : i2\r\n        %12 = comb.icmp bin eq %11, %8 : i2\r\n        %13 = sv.array_index_inout %r[%i] : !hw.inout<array<3xi1>>, i2\r\n        sv.passign %13, %12 : i1\r\n      } {hw.verilogName = \"i\", sv.attributes = [#sv.attribute<\"SV_FOR_LOOP\", emitAsComment>]}\r\n    }\r\n    %0 = sv.read_inout %r : !hw.inout<array<3xi1>>\r\n    hw.output %0 : !hw.array<3xi1>\r\n  }\r\n```\r\nis currently lowered into\r\n```verilog\r\n// Generated by CIRCT firtool-1.43.0-99-g7e99cc22d-dirty\r\nmodule Example(\r\n  input             clock,\r\n  input  [2:0][1:0] foo,\r\n  input  [3:0][1:0] bar,\r\n  output [2:0]      out\r\n);\r\n\r\n  reg [2:0] r;\r\n  always @(posedge clock) begin\r\n    for (logic [1:0] i = 2'h0; i < 2'h3; i += 2'h1) begin\r\n      automatic logic [2:0][1:0] _GEN = '{2'h2, 2'h1, 2'h0};\r\n      automatic logic [2:0][1:0] _GEN_0 = '{2'h3, 2'h2, 2'h1};\r\n      r[i] <= (bar[_GEN_0[i]] ^ foo[_GEN[i]]) == _GEN[i];\r\n    end\r\n  end // always @(posedge)\r\n  assign out = r;\r\nendmodule\r\n```\r\nBut we can canonicalize the above into:\r\n```verilog\r\n  always @(posedge clock) begin\r\n    for (logic [1:0] i = 2'h0; i < 2'h3; i += 2'h1) begin\r\n      r[i] <= (bar[i+1] ^ foo[i]) == i;\r\n    end\r\n  end // always @(posedge)\r\n```","labels":[],"number":5422,"state":"OPEN","title":"[SV] Canonicalize `array_get([n-1, n-2, ...., 1, 0], %ind_var)` into `%ind_var`","url":"https://github.com/llvm/circt/issues/5422"}
{"body":"Please sink `IndexedPartSelectOp` down to the comb dialect, and rename it to `SliceOp` (put it right after ExtractOp since they are siblings).\r\n\r\nThe inout version should stay in SV but be named `SliceInOutOp` to align with the above.\r\n\r\nI also believe both should drop the \"decrement\" attribute.  Rationale:\r\n - There is no expressive capability in the IR that this adds, it is just syntactic.\r\n - This makes it more difficult to analyze and transform the IR, because passes will have to handle two forms of the same thing.\r\n - There is no client for this that exists.\r\n - It is unproven that a future verilog parser will want to use the SV dialect at all.  Such a parser will probably want to maintain sugar and many other things that the SV dialect doesn't.  For example, these ops store the size as a constant, but in parsed verilog it can be an expression.\r\n\r\nIf there is a client and this is the right thing to add, we can add it back later when we understand the constraints better.\r\n","labels":[],"number":2181,"state":"OPEN","title":"[SV] Sink `IndexedPartSelectOp` to comb and rename Inout version","url":"https://github.com/llvm/circt/issues/2181"}
{"body":"Consider:\r\n```mlir\r\nhw.module @hoist_reg(in %dummy : i32, in %dummy2 : i32, out out : i17) {\r\n  %res_reg = sv.reg : !hw.inout<i17>\r\n  sv.initial {\r\n    %tmp = sv.reg init %dummy : !hw.inout<i32>\r\n    %17 = sv.read_inout %tmp : !hw.inout<i32>\r\n    %29 = comb.xor %dummy2, %17 : i32\r\n    %32 = comb.extract %29 from 3 : (i32) -> i17\r\n    sv.passign %res_reg, %32 : i17\r\n  }\r\n\r\n  %res_reg_data = sv.read_inout %res_reg : !hw.inout<i17>\r\n  hw.output %res_reg_data : i17\r\n}\r\n```\r\n\r\nRunning through firtool produces:\r\n```systemverilog\r\n// Generated by CIRCT firtool-1.79.0g20240729_759ef12\r\nmodule hoist_reg(\t// def-use.mlir:1:1\r\n  input  [31:0] dummy,\t// def-use.mlir:1:25\r\n                dummy2,\t// def-use.mlir:1:42\r\n  output [16:0] out\t// def-use.mlir:1:61\r\n);\r\n\r\n  reg [16:0] res_reg;\t// def-use.mlir:2:14\r\n  initial begin\t// def-use.mlir:3:3\r\n    automatic logic [31:0] _GEN = dummy2 ^ tmp;\t// def-use.mlir:5:11, :6:11\r\n    reg             [31:0] tmp = dummy;\t// def-use.mlir:4:12\r\n    res_reg <= _GEN[19:3];\t// def-use.mlir:6:11, :7:11, :8:5\r\n  end // initial\r\n  assign out = res_reg;\t// def-use.mlir:11:19, :12:3\r\nendmodule\r\n```\r\n\r\nNotice `_GEN` uses `tmp` before it's declared.\r\nThis is treated as an error by default in some tools, such as slang and VCS.","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"}],"number":7405,"state":"OPEN","title":"Emitted SV uses variable before declaration","url":"https://github.com/llvm/circt/issues/7405"}
{"body":"[In the SV `P/BPAssignOp` verifiers](https://github.com/llvm/circt/blob/main/lib/Dialect/SV/SVOps.cpp#L1142-L1156) it is assumed that the target argument is defined by an op (`isa` used on `getDefiningOp`). Hence, in the case of a `hw.inout` input port, the verifier crashes.\r\n\r\ni.e.:\r\n```mlir\r\nhw.module @unsupported(%a: !hw.inout<i42>) {\r\n  %clock = hw.constant 1 : i1\r\n  %c42 = hw.constant 42 : i42\r\n  sv.alwaysff(posedge %clock) {\r\n    sv.passign %a, %c42 : i42\r\n  }\r\n}\r\n```\r\n\r\n","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwxODg4ODczNzIx","name":"good first issue","description":"Good for newcomers","color":"7057ff"},{"id":"MDU6TGFiZWwyNjU1MzIwNzEy","name":"Verilog/SystemVerilog","description":"Involving a Verilog dialect","color":"10A761"}],"number":5566,"state":"OPEN","title":"[SV] Crash in `P/BPAssignOp` verifiers for `hw.inout` ports","url":"https://github.com/llvm/circt/issues/5566"}
{"body":"```mlir\r\nhw.module @TopXMRAsserts(%I: !hw.inout<i1>) -> () {}\r\nhw.module @Top() -> () {\r\n    %I = sv.wire : !hw.inout<i1>\r\n    hw.instance \"TopXMRAsserts_inst0\" sym @Top.TopXMRAsserts_inst0 @TopXMRAsserts(I: %I: !hw.inout<i1>) -> () {doNotPrint = 1}\r\n}\r\nsv.bind #hw.innerNameRef<@Top::@Top.TopXMRAsserts_inst0>\r\n```\r\n`circt-opt -export-verilog`:\r\n```\r\ncirct-opt: /home/uenoku/dev/circt/llvm/llvm/../mlir/include/mlir/IR/StorageUniquerSupport.h:153: static ConcreteT mlir::detail::StorageUserBase<circt::hw::InOutType, mlir::Type, circt::hw::detail::InOutTypeStorage, mlir::detail::TypeUniquer>::get(mlir::MLIRContext *, Args...) [ConcreteT = circt::hw::InOutType, BaseT = mlir::Type, StorageT = circt::hw::detail::InOutTypeStorage, UniquerT = mlir::detail::TypeUniquer, Traits = <>, Args = <mlir::Type>]: Assertion `succeeded(ConcreteT::verify(getDefaultDiagnosticEmitFn(ctx), args...))' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\n #0 0x000055ccf68fee23 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/uenoku/dev/circt/llvm/llvm/lib/Support/Unix/Signals.inc:569:13\r\n #1 0x000055ccf68fd0e0 llvm::sys::RunSignalHandlers() /home/uenoku/dev/circt/llvm/llvm/lib/Support/Signals.cpp:104:18\r\n #2 0x000055ccf68ff47a SignalHandler(int) /home/uenoku/dev/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #3 0x00007f04f0242520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #4 0x00007f04f0296a7c __pthread_kill_implementation ./nptl/pthread_kill.c:44:76\r\n #5 0x00007f04f0296a7c __pthread_kill_internal ./nptl/pthread_kill.c:78:10\r\n #6 0x00007f04f0296a7c pthread_kill ./nptl/pthread_kill.c:89:10\r\n #7 0x00007f04f0242476 gsignal ./signal/../sysdeps/posix/raise.c:27:6\r\n #8 0x00007f04f02287f3 abort ./stdlib/abort.c:81:7\r\n #9 0x00007f04f022871b _nl_load_domain ./intl/loadmsgcat.c:1177:9\r\n#10 0x00007f04f0239e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n#11 0x000055ccf6eb5897 (./bin/circt-opt+0xb1b897)\r\n#12 0x000055ccf6fd56e8 circt::sv::WireOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Type, mlir::StringAttr, mlir::StringAttr) /home/uenoku/dev/circt/lib/Dialect/SV/SVOps.cpp:1296:21\r\n#13 0x000055ccf6ffd651 circt::sv::WireOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Type, llvm::StringRef) /home/uenoku/dev/circt/build/tools/circt/include/circt/Dialect/SV/SV.cpp.inc:15061:7\r\n#14 0x000055ccf6a68d51 circt::sv::WireOp mlir::OpBuilder::create<circt::sv::WireOp, mlir::Type, llvm::SmallString<32u>&>(mlir::Location, mlir::Type&&, llvm::SmallString<32u>&) /home/uenoku/dev/circt/llvm/llvm/../mlir/include/mlir/IR/Builders.h:460:16\r\n#15 0x000055ccf6a658ac spillWiresForInstanceInputs(circt::hw::InstanceOp) /home/uenoku/dev/circt/lib/Conversion/ExportVerilog/PrepareForEmission.cpp:103:28\r\n#16 0x000055ccf6a658ac legalizeHWModule(mlir::Block&, circt::LoweringOptions const&) /home/uenoku/dev/circt/lib/Conversion/ExportVerilog/PrepareForEmission.cpp:735:9\r\n```\r\n","labels":[],"number":4036,"state":"OPEN","title":"[PrepareForEmission] Crash when inout operations are passed to instance ports","url":"https://github.com/llvm/circt/issues/4036"}
{"body":"Consider following IR (this kind of IR is frequently used to express FIRRTL's inout ports):\r\n```mlir\r\nhw.module @Foo(%x: i8) -> (y: i8, z: i8) {\r\n    %.z.output = sv.wire : !hw.inout<i8>\r\n    %0 = sv.read_inout %.z.output : !hw.inout<i8>\r\n    sv.assign %.z.output, %x : i8\r\n    hw.output %0, %0 : i8, i8\r\n }\r\n```\r\n`circt-opt -export-verilog`:\r\n```verilog\r\nmodule Foo(\t// foo.mlir:1:1\r\n  input  [7:0] x,\r\n  output [7:0] y,\r\n               z);\r\n\r\n  wire [7:0] _z_output;\t// foo.mlir:2:18\r\n\r\n  assign _z_output = x;\t// foo.mlir:4:5\r\n  assign y = _z_output;\t// foo.mlir:3:10, :5:5\r\n  assign z = _z_output;\t// foo.mlir:3:10, :5:5\r\nendmodule\r\n```\r\n\r\nIdeally we don't have to create temporary wires for output ports, e.g:\r\n```verilog\r\nmodule Foo(\t// foo.mlir:1:1\r\n  input  [7:0] x,\r\n  output [7:0] y,\r\n               z);\r\n\r\n  assign z = x;\t// foo.mlir:4:5\r\n  assign y = x;\t// foo.mlir:3:10, :5:5\r\nendmodule","labels":[],"number":3133,"state":"OPEN","title":"[ExportVerilog] Reuse output ports if possible","url":"https://github.com/llvm/circt/issues/3133"}
{"body":"```mlir\r\nhw.module @Foo(%clock:i1, %a:i8, %b:i8) {\r\n  %reg = sv.reg : !hw.inout<i8> \r\n  %fd = hw.constant 0x80000002 : i32\r\n  sv.always posedge %clock {\r\n    sv.bpassign %reg, %a : i8\r\n    %x = sv.read_inout %reg : !hw.inout<i8>\r\n    sv.bpassign %reg, %b : i8\r\n    sv.fwrite %fd, \"%d\"(%x) : i8\r\n  }\r\n}\r\n```\r\n\r\nCurrent output:\r\n```verilog\r\nmodule Foo(\r\n  input       clock,\r\n  input [7:0] a,\r\n              b);\r\n\r\n  reg [7:0] reg_0;\r\n\r\n  always @(posedge clock) begin\r\n    reg_0 = a;\r\n    reg_0 = b;\r\n    $fwrite(32'h80000002, \"%d\", reg_0);\r\n  end // always @(posedge)\r\nendmodule\r\n```\r\n\r\nThis is incorrect because the value of `a` should be printed. I guess we have to create a temporary register if we can't use `automatic`. ","labels":[],"number":3028,"state":"OPEN","title":"[SV] Miss-complication by reordering side-effect ops","url":"https://github.com/llvm/circt/issues/3028"}
{"body":"Follow on to #8450.\n\nChisel version: 7.0.0-RC4\nfirtool version: 1.130.0\n\nI noticed an error cropping up when using `--preserve-aggregate=all` on a Rocket Chip design, specifically at [this line](https://github.com/chipsalliance/rocket-chip/blob/c357a0f32ecec9ee046ca1d6378c21ec7fec179b/src/main/scala/rocket/RocketCore.scala#L1218). I've brought it down to this reproduction:\n\n```firrtl\nFIRRTL version 6.0.0\ncircuit Foo :\n  layer Verification, bind, \"verification\" :\n    layer Assert, bind, \"verification/assert\" :\n    layer Assume, bind, \"verification/assume\" :\n    layer Cover, bind, \"verification/cover\" :\n\n  public module Foo :\n    input clock : Clock\n    input reset : UInt<1>\n    input a : UInt<1>\n    output b : UInt<1>\n\n    wire bundle : { clock : Clock, x : UInt<1>}\n    connect b, a\n    connect bundle.clock, clock\n    connect bundle.x, a\n    node _T = eq(reset, UInt<1>(0h0))\n    when _T :\n      skip\n      layerblock Verification :\n        printf(clock, UInt<1>(0h1), \"Bundle: %d\\n\", bundle.x) : printf\n```\n\nThe error shows up during `lower-firrtl-to-hw`:\n\n```\n$ firtool --version\nLLVM (http://llvm.org/):\n  LLVM version 22.0.0git\n  Optimized build.\nCIRCT firtool-1.130.0\n$ firtool --verbose-pass-executions --preserve-aggregate=all test.fir\n...\n[firtool] Running \"lower-firrtl-to-hw{verification-flavor=none warn-on-unprocessed-annotations=false}\"\ntest.fir:16:5: error: 'sv.read_inout' op result #0 must be a known primitive element, but got '!hw.struct<clock: !seq.clock, x: i1>'\n    connect bundle.clock, clock\n    ^\ntest.fir:16:5: note: see current operation: %8 = \"sv.read_inout\"(%7) : (!hw.inout<struct<clock: !seq.clock, x: i1>>) -> !hw.struct<clock: !seq.clock, x: i1>\ntest.fir:17:5: note: additional location here\n    connect bundle.x, a\n```\n\nSeems like having a `Clock` field in the bundle causes this error. It works fine if you remove the `Clock` field from the bundle.","labels":[],"number":8931,"state":"OPEN","title":"[firtool] Error while preserving struct aggregates containing a clock","url":"https://github.com/llvm/circt/issues/8931"}
{"body":"```mlir\r\n; circt-opt -export-verilog\r\n  hw.module @Foo() {\r\n    %0 = sv.wire  : !hw.inout<i3>\r\n    %1 = sv.wire  : !hw.inout<i3>\r\n    hw.output\r\n  }\r\n```\r\nCurrently the output is:\r\n```sv\r\nmodule Foo();  \r\n  wire [2:0] _GEN;  \r\n  wire [2:0] _GEN_0;  \r\n\r\nendmodule\r\n``` \r\n\r\nMaybe it is better to reuse declaration of wires like port delcrations:\r\n```sv\r\nmodule Foo(); \r\n  wire [2:0] _GEN, _GEN_0;   \r\n\r\nendmodule\r\n``` \r\n","labels":[{"id":"MDU6TGFiZWwyNjM1MzI5MzE1","name":"ExportVerilog","description":"","color":"1d76db"},{"id":"LA_kwDODpuCgs7f5Csy","name":"Verilog Quality","description":"","color":"01371D"}],"number":2624,"state":"OPEN","title":"[ExportVerilog] Reuse wire/register declarations","url":"https://github.com/llvm/circt/issues/2624"}
{"body":"If a `BindOp` needs to be hooked up to a temporary, the name generation logic is going to generate something that doesn't exist in the circuit. The problematic area is in this logic: https://github.com/llvm/circt/blob/main/lib/Translation/ExportVerilog/ExportVerilog.cpp#L2802\r\n\r\nE.g, consider the following:\r\n\r\n```mlir\r\nmodule attributes {firrtl.mainModule = \"Foo\"}  {\r\n  hw.module @Bar(%a: i1) {\r\n    hw.output\r\n  }\r\n  sv.bind @__Bar__ {output_file = {directory = \"\", exclude_from_filelist = true, exclude_replicated_ops = true, name = \"bindings.sv\"}}\r\n  hw.module @Foo(%a: i1) -> (%b: i1) {\r\n    hw.instance \"Bar\" sym @__Bar__ @Bar(%0) {doNotPrint} : (i1) -> ()\r\n    %x = sv.wire  : !hw.inout<i1>\r\n    sv.connect %x, %a : i1\r\n    %0 = sv.read_inout %x : !hw.inout<i1>\r\n    %1 = sv.read_inout %x : !hw.inout<i1>\r\n    hw.output %1 : i1\r\n  }\r\n}\r\n\r\n```\r\n\r\nThis will produce Verilog that tries to bind to `Bar_Bar_a`.  I would expect to see the bind to `_T` or `x`:\r\n\r\n```verilog\r\nmodule Bar(\r\n  input a);\r\n\r\nendmodule\r\n\r\nmodule Foo(\r\n  input  a,\r\n  output b);\r\n\r\n  wire _T;      // Foo.mlir:10:10\r\n  wire x;       // Foo.mlir:8:10\r\n\r\n  // This instance is elsewhere emitted as a bind statement.\r\n  // Bar Bar (  // Foo.mlir:7:5\r\n  //   .a (_T)  // Foo.mlir:10:10\r\n  // );\r\n  assign x = a; // Foo.mlir:9:5\r\n  assign _T = x;        // Foo.mlir:10:10\r\n  assign b = x; // Foo.mlir:11:10, :12:5\r\nendmodule\r\n\r\n\r\n// ----- 8< ----- FILE \"bindings.sv\" ----- 8< -----\r\n\r\nbind Foo Bar Bar (\r\n  .a (Bar_Bar_a)\r\n);\r\n```","labels":[],"number":1429,"state":"OPEN","title":"[ExportVerilog] Binds of Temporaries are named strangely","url":"https://github.com/llvm/circt/issues/1429"}
{"body":"A while ago, we have switched the LLHD dialect from a custom `!llhd.sig` wrapper type to `!hw.inout` in order to represent a reference to a signal slot that can be probed and driven. To support Verilog's `time` values, we have to be able to store an `!llhd.time` value in a variable and read and write that variable. Variables are effectively signals, and Verilog variables get mapped to `llhd.sig` allocation operations. These return a reference type. This prevents us from creating `time` variables today, since `!hw.inout` forces `isHWValueType` on the inner type, which `llhd::TimeType` is not.\n\nIdeally, we'd create something like an `!llhd.ref<T>` type to represent a reference to a signal. In the future, we might want to add additional types for multi-driver nets.","labels":[{"id":"MDU6TGFiZWwyMTY1NDc5NTk1","name":"LLHD","description":"","color":"e07b00"}],"number":8825,"state":"OPEN","title":"[LLHD] Switch from hw.inout to a custom signal reference type","url":"https://github.com/llvm/circt/issues/8825"}
{"body":"Currently, FSMs explicitly annotate entry states. However, a prerequisite of various optimizations and analysis (one example could be flattening instantiations of nested sub-FSMs) is to be aware of when control _exits_ an FSM.\r\n\r\nExample implementations could be:\r\n\r\n#### 1: `fsm.exit` operation inside transition region, with optional guard and action fields:\r\n```mlir\r\nfsm.machine @foo() -> () attributes {initialState = \"IDLE\", stateType = i1} {\r\n  fsm.state \"IDLE\" output  {\r\n    ...\r\n  } transitions  {\r\n    fsm.transition @BUSY guard  { ... }\r\n\r\n    fsm.exit guard { ...\r\n    } action {\r\n      ...\r\n    }\r\n  }\r\n\r\n  fsm.state \"BUSY\" {... }\r\n}\r\n```\r\n#### 2: special \"exit\" token for `fsm.transition`\r\nEssentially the same as above, but avoids introducing a new operation in favor of complicating the `fsm.transition` operation slightly (target state can be either a symbol or the \"exit\" token).\r\n```mlir\r\nfsm.machine @foo() -> () attributes {initialState = \"IDLE\", stateType = i1} {\r\n  fsm.state \"IDLE\" output  {\r\n    ...\r\n  } transitions  {\r\n    fsm.transition @BUSY guard  { ... }\r\n\r\n    fsm.transition exit guard { ...\r\n    } action {\r\n      ...\r\n    }\r\n  }\r\n\r\n  fsm.state \"BUSY\" {... }\r\n}\r\n```\r\n","labels":[{"id":"LA_kwDODpuCgs710LVx","name":"FSM","description":"the FSM dialect","color":"E9BD94"}],"number":3114,"state":"OPEN","title":"[FSM] Formalizing control exit","url":"https://github.com/llvm/circt/issues/3114"}
{"body":"In https://github.com/llvm/circt/pull/1506#pullrequestreview-720563236 I mentioned that it might be useful to use the proposed FSM dialect during Calyx's CompileControl pass. That pass is generating an FSM with Comb logic right now, but my hypothesis is targetting the FSM dialect would provide a more straightforward way to capture the notion of an FSM. Steve was mentioning it would be good for us to do some homework on the FSM proposal and bring our use-cases, so I'll experiment with this a bit.\r\n\r\nCC @cgyurgyik ","labels":[{"id":"MDU6TGFiZWwyOTc3OTYzNzA4","name":"Tracking Issue","description":"A tracking issue for a set of features or large code changes","color":"1D76DB"},{"id":"MDU6TGFiZWwzMDk2MTk4MzEw","name":"Calyx","description":"The Calyx dialect","color":"94BD78"},{"id":"LA_kwDODpuCgs710LVx","name":"FSM","description":"the FSM dialect","color":"E9BD94"}],"number":1522,"state":"OPEN","title":"Experimentation with FSM dialect during Calyx lowering","url":"https://github.com/llvm/circt/issues/1522"}
{"body":"Currently, any `index`-typed values will be emitted with a fixed width, currently set to 64 bits. Unsurprisingly, testing shows that this can have a **huge** overhead in circuits. Eventually we want to have a proper (path- and flow sensitive) width-infererence pass to take care of this. Until then, it would be nice to have an option to the `HandshakeToFIRRTL` pass to specify what width these signals should be emitted with.","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIx","name":"good first issue","description":"Good for newcomers","color":"7057ff"},{"id":"MDU6TGFiZWwyMTUyNzUzODY1","name":"Handshake","description":"","color":"d0a6fc"}],"number":2458,"state":"OPEN","title":"[HandshakeToFIRRTL] Add option for Index bit width","url":"https://github.com/llvm/circt/issues/2458"}
{"body":"ExportVerilog emits a concat that bitswaps like this:\r\n\r\n```\r\nthing = {io_in1[0], io_in1[1], io_in1[2], io_in1[3], io_in1[4]...}\r\n```\r\n\r\nbut there are better idioms for this.  We could generate them directly, and we may want to introduce a comb op for bitswapping.\r\n","labels":[{"id":"MDU6TGFiZWwyNjM1MzI5MzE1","name":"ExportVerilog","description":"","color":"1d76db"}],"number":2249,"state":"OPEN","title":"[ExportVerilog] Add support for bit swapping idiom","url":"https://github.com/llvm/circt/issues/2249"}
{"body":"It is generally a good idea to support constant folding / canonicalization for all the combinational logic ops.  One extremely minor thing don't support yet is folding to/from zero bit values.  This is because the `firrtl.constant` operation hold an APInt which can't represent a zero bit value.\r\n\r\nAchieving this would be straight-forward, following how we fold invalid values.  We'd need an analog of `InvalidValueAttr` named `ZeroWidthValueAttr` which doesn't hold anything.  We'd need an analog of `InvalidValueOp` that represents a zero bit value operation.  We'd need Lower2HW to support `InvalidValueOp` and then all the primitive folders to return `ZeroWidthValueAttr` when the result size is zero bits (the folders for other ops could be updated to handle an `ZeroWidthValueAttr` as well).\r\n\r\nNote: I have no idea if this matters, it certainly isn't high priority.","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIx","name":"good first issue","description":"Good for newcomers","color":"7057ff"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":1501,"state":"OPEN","title":"[FIRRTL] Support constant folding to zero bit values","url":"https://github.com/llvm/circt/issues/1501"}
{"body":"Cache whether a array or struct contains an inout type, rather than computing it.\r\nProbably want to also cache whether it contains a non-RTL type.","labels":[],"number":391,"state":"OPEN","title":"Cache non-inout bits in composite RTL types","url":"https://github.com/llvm/circt/issues/391"}
{"body":"Revisit \"port\" and \"direction\" nomenclature used in the intrinsic documentation, which are holdovers from intrinsic modules.","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE4","name":"documentation","description":"Improvements or additions to documentation","color":"0075ca"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":8111,"state":"OPEN","title":"[FIRRTL] Intrinsic documentation: Ports and Direction tables are bit confusing","url":"https://github.com/llvm/circt/issues/8111"}
{"body":"```mlir\r\n  firrtl.circuit \"top\" {\r\n  firrtl.module @top(in %in: !firrtl.bundle<foo: uint<0>, t: uint<8>>, out %out: !firrtl.bundle<foo: uint<0>, t: uint<8>>) {\r\n    %c0_ui0 = firrtl.constant 0 : !firrtl.uint<0>\r\n    %0 = firrtl.subfield %in[t] : !firrtl.bundle<foo: uint<0>, t: uint<8>>\r\n    %1 = firrtl.bundlecreate %c0_ui0, %0 : (!firrtl.uint<0>, !firrtl.uint<8>) -> !firrtl.bundle<foo: uint<0>, t: uint<8>>\r\n    firrtl.matchingconnect %out, %1 : !firrtl.bundle<foo: uint<0>, t: uint<8>>\r\n  }\r\n  }\r\n```\r\n\r\n\r\n```\r\nbar.fir:16:13: error: 'firrtl.bundlecreate' op LowerToHW couldn't handle this operation\r\n    out.foo <= UInt<1>(0)\r\n            ^\r\nbar.fir:16:13: note: see current operation: %4 = \"firrtl.bundlecreate\"(%1, %3) : (!firrtl.uint<0>, !firrtl.uint<8>) -> !firrtl.bundle<foo: uint<0>, t: uint<8>>\r\nbar.fir:15:11: note: additional location here\r\n    out.t <= in.t\r\n```","labels":[],"number":7721,"state":"OPEN","title":"[LowerToHW] Failure when lowering bundle_create which contains zero bit","url":"https://github.com/llvm/circt/issues/7721"}
{"body":"I ran `circt-verilog` on this file from OpenTitan:\nhttps://github.com/lowRISC/opentitan/blob/d8b5efd1427152b8387d6e03d9db413167e58475/hw/ip/lc_ctrl/rtl/lc_ctrl_fsm.sv\n\nI got this error:\n\n```bash\nak2518@autobot:/local/scratch/ak2518/opentitan$ /local/scratch/ak2518/circt/build/bin/circt-verilog --debug --parse-only /local/scratch/ak2518/opentitan/hw/ip/lc_ctrl/rtl/lc_ctrl_fsm.sv -yhw/ip/prim_generic/rtl -yhw/ip/prim/rtl -yhw/ip/lc_ctrl/rtl -yhw/ip/rom_ctrl/rtl -Ihw/ip/prim/rtl -yhw/ip/prim_generic/rtl -DYOSYS -DSYNTHESIS  --mlir-print-ir-after-failure --verbose-pass-executions --mlir-pass-statistics\nArgs: /local/scratch/ak2518/circt/build/bin/circt-verilog --debug --parse-only /local/scratch/ak2518/opentitan/hw/ip/lc_ctrl/rtl/lc_ctrl_fsm.sv -yhw/ip/prim_generic/rtl -yhw/ip/prim/rtl -yhw/ip/lc_ctrl/rtl -yhw/ip/rom_ctrl/rtl -Ihw/ip/prim/rtl -yhw/ip/prim_generic/rtl -DYOSYS -DSYNTHESIS --mlir-print-ir-after-failure --verbose-pass-executions --mlir-pass-statistics\nLoad new dialect in Context builtin\nLoad new dialect in Context moore\nLoad new dialect in Context hw\nLoad new dialect in Context cf\nLoad new dialect in Context arith\nLoad new dialect in Context func\nLoad new dialect in Context verif\nLoad new dialect in Context seq\nLoad new dialect in Context ltl\nLoad new dialect in Context comb\nLoad new dialect in Context dbg\n-:148:13: error: 'moore.case_eq' op operand #0 must be simple bit vector type, but got '!moore.array<6 x l5>'\n-:148:13: note: see current operation: %243 = \"moore.case_eq\"(%239, %242) : (!moore.array<6 x l5>, !moore.l30) -> !moore.i1\nak2518@autobot:/local/scratch/ak2518/opentitan$\n```\n\n\nI'm not sure what this error means. I don't know how to debug/inspect the intermediate representation before the error happens. It would be useful if I could see what construct in the original SystemVerilog caused this line in the MLIR.\n\n\nversion:\n\n```bash\nak2518@autobot:/local/scratch/ak2518/opentitan$  /local/scratch/ak2518/circt/build/bin/circt-verilog --version\nLLVM (http://llvm.org/):\n  LLVM version 22.0.0git\n  DEBUG build with assertions.\nCIRCT 55f12edd1\nslang version 9.0.0+54385bb\n```\n\nThrough trial-and-error, I've realised that this is caused by lines 148-203 in `lc_ctrl_state_transition.sv`\nhttps://github.com/lowRISC/opentitan/blob/d8b5efd1427152b8387d6e03d9db413167e58475/hw/ip/lc_ctrl/rtl/lc_ctrl_state_transition.sv#L148-L203","labels":[{"id":"LA_kwDODpuCgs8AAAABp1j0gg","name":"ImportVerilog","description":"","color":"e99695"}],"number":8844,"state":"OPEN","title":"[circt-verilog]  'moore.case_eq' operand must be simple bit vector type, but got array","url":"https://github.com/llvm/circt/issues/8844"}
{"body":"Hi all, \n\nwhen building with the latest [slang](https://github.com/MikePopoloski/slang) master branch, there seems to be an issue with tests on `basic.sv`.\n\nSpecifically, I'm getting the following unexpected output\n```\n$ circt-translate --import-verilog test/Conversion/ImportVerilog/basic.sv | FileCheck test/Conversion/ImportVerilog/basic.sv\n\n../test/Conversion/ImportVerilog/basic.sv:1740:12: error: CHECK: expected string not found in input\n // CHECK: [[V0:%.+]] = moore.extract_ref %z3 from 2\n           ^\n<stdin>:1431:36: note: scanning from here\n %11 = moore.extract_ref %z3 from 1 : <l3> -> <l1>\n                                   ^\n<stdin>:1435:2: note: possible intended match here\n %15 = moore.extract_ref %w3 from 0 : <l2> -> <l1>\n ^\n\nInput file: <stdin>\nCheck file: ../test/Conversion/ImportVerilog/basic.sv\n\n-dump-input=help explains the following input dump.\n\nInput was:\n<<<<<<\n              .\n              .\n              .\n           1426:  %z3 = moore.net wire : <l3> \n           1427:  %w3 = moore.net wire : <l2> \n           1428:  %8 = moore.read %x3 : <l1> \n           1429:  %9 = moore.read %y3 : <l1> \n           1430:  %10 = moore.extract_ref %z3 from 0 : <l3> -> <l1> \n           1431:  %11 = moore.extract_ref %z3 from 1 : <l3> -> <l1> \ncheck:1740'0                                        X~~~~~~~~~~~~~~~ error: no match found\n           1432:  %12 = moore.read %z3 : <l3> \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1433:  %13 = moore.constant 2 : i32 \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1434:  %14 = moore.dyn_extract %12 from %13 : l3, i32 -> l1 \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1435:  %15 = moore.extract_ref %w3 from 0 : <l2> -> <l1> \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ncheck:1740'1      ?                                                  possible intended match\n           1436:  %16 = moore.read %w3 : <l2> \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1437:  %17 = moore.constant 1 : i32 \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1438:  %18 = moore.dyn_extract %16 from %17 : l2, i32 -> l1 \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1439:  %p3.v1, %p3.c1 = moore.instance \"p3\" @MultiPorts(a0: %8: !moore.l1, a1: %9: !moore.l1, v0: %14: !moore.l1, v2: %10: !moore.ref<l1>, c0: %18: !moore.l1) -> (v1: !moore.l1, c1: !moore.l1) \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1440:  moore.assign %11, %p3.v1 : l1 \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n              .\n              .\n              .\n>>>>>>\n\n```\n\nIt looks like `moore.extract_ref %z3 from 2` is missing but therefore we have this:\n```\n%12 = moore.read %z3 : <l3>\n%13 = moore.constant 2 : i32\n%14 = moore.dyn_extract %12 from %13 : l3, i32 -> l1 \n```\n\nDo you have any advice on how to proceed with this?\n\nThanks!","labels":[],"number":9489,"state":"OPEN","title":"[slang] Testing error when switching to slang master branch","url":"https://github.com/llvm/circt/issues/9489"}
{"body":"I'm seeing a bunch of variants of this pattern:\r\n\r\n// x is 6 bits, y is 2 bits.\r\n`wire [9:0] _tmp_122 = {3'h0, x} | {y, 7'h0};`\r\n\r\nwhich could be simplified to:\r\n\r\n`wire [9:0] _tmp_122 = {y, 1'h0, x};`\r\n\r\n\r\nA similar one is:\r\n\r\n`{ 5'0, bit}|{4'0, cond?2:0}` ==> `{4'h0, cond ? 1 : 0, bit}` ==> `{4'h0, cond, bit}`\r\n","labels":[],"number":1624,"state":"OPEN","title":"[Comb] `or` of exclusive concats can be merged","url":"https://github.com/llvm/circt/issues/1624"}
{"body":"When i run `arcilator` with `$ ./arcilator a.mlir --state-file=a.json` i get the following error:\r\n```\r\na.mlir:9:23: error: 'arc.tap' op operand #0 must be signless integer, but got '!hw.struct<valid: i1, bits: i1>'\r\n    %_registers_0_T = hw.wire %2 sym @sym_0  : !hw.struct<valid: i1, bits: i1>\r\n                      ^\r\na.mlir:9:23: note: see current operation: \"arc.tap\"(%5) {name = \"_registers_0_T\"} : (!hw.struct<valid: i1, bits: i1>) -> ()\r\n```\r\n\r\n`a.mlir`:\r\n```\r\nmodule {\r\n  hw.module @Barrier(in %clock : !seq.clock, in %reset : i1, in %io_input : !hw.array<1xstruct<valid: i1, bits: i1>>, out io_output : !hw.array<1xstruct<valid: i1, bits: i1>>) {\r\n    %false = hw.constant false\r\n    %0 = hw.array_get %io_input[%false] : !hw.array<1xstruct<valid: i1, bits: i1>>, i1\r\n    %valid = hw.struct_extract %0[\"valid\"] : !hw.struct<valid: i1, bits: i1>\r\n    %registers = seq.firreg %3 clock %clock sym @sym {firrtl.random_init_start = 0 : ui64} : !hw.array<1xstruct<valid: i1, bits: i1>>\r\n    %1 = hw.array_get %registers[%false] : !hw.array<1xstruct<valid: i1, bits: i1>>, i1\r\n    %2 = comb.mux bin %valid, %0, %1 : !hw.struct<valid: i1, bits: i1>\r\n    %_registers_0_T = hw.wire %2 sym @sym_0  : !hw.struct<valid: i1, bits: i1>\r\n    %3 = hw.array_create %_registers_0_T : !hw.struct<valid: i1, bits: i1>\r\n    hw.output %registers : !hw.array<1xstruct<valid: i1, bits: i1>>\r\n  }\r\n}\r\n```\r\n\r\n","labels":[{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":6373,"state":"OPEN","title":"[Arc] Support hw.wires of aggregate types","url":"https://github.com/llvm/circt/issues/6373"}
{"body":"The following bit of FIRRTL:\r\n\r\n```\r\nnode _choice_T_78 = lt(_choice_T_52, UInt<3>(\"h4\"))                      \r\nnode _choice_T_79 = add(UInt<3>(\"h4\"), _choice_T_52)                 \r\nnode _choice_T_80 = tail(_choice_T_79, 1)                                \r\nnode _choice_T_81 = sub(_choice_T_52, UInt<3>(\"h4\"))                    \r\nnode _choice_T_82 = tail(_choice_T_81, 1)                                \r\nnode _choice_T_83 = mux(_choice_T_78, _choice_WIRE_2[_choice_T_80], _choice_WIRE_2[_choice_T_82])\r\n```\r\n\r\nIs lowered to SystemVerilog as follows:\r\n\r\n```\r\n  assign _GEN_31 = _GEN_22[_choice_T_1 - 3'h4] \r\n  assign _GEN_32 = _GEN_22[_choice_T_1 - 3'h4] \r\n  ... = _choice_T_1[2] ? _GEN_32 : _GEN_31)\r\n```\r\n\r\nOn 4 bits, the addition is folded into a subtraction. However, in both VCS and Verilator, the result of the indexing expressions is not truncated to 4 bits and the resulting borrow bit results in an invalid index. Enabling explicit bit casts works around this issue.\r\n","labels":[],"number":4170,"state":"OPEN","title":"SV Array indexing out-of-bounds due to implicit extension","url":"https://github.com/llvm/circt/issues/4170"}
{"body":"```mlir\r\nhw.module @Foo(%array: !hw.array<4xi6>, %c: i1, %d: i2) -> (b: i6) {\r\n    %c0_i2 = hw.constant 0 : i2\r\n    %0 = comb.mux %c, %c0_i2, %d : i2\r\n    %1 = hw.array_get %array[%0] : !hw.array<4xi6>\r\n    hw.output %1 : i6\r\n  }\r\n```\r\nwill be lowered into \r\n```verilog\r\nmodule Foo(\t// foo.mlir:1:1\r\n  input  [3:0][5:0] array,\r\n  input             c,\r\n  input  [1:0]      d,\r\n  output [5:0]      b);\r\n\r\n  assign b = array[c ? 2'h0 : d];\t// foo.mlir:2:13, :3:14, :4:12, :5:5\r\nendmodule\r\n```\r\n\r\nVerilator produces the following warnings\r\n```\r\n%Warning-WIDTH: a.sv:7:22: Operator COND expects 32 or 3 bits on the Conditional True, but Conditional True's CONST '2'h0' generates 2 bits.\r\n                         : ... In instance Foo\r\n    7 |   assign b = array[c ? 2'h0 : d];  \r\n      |                      ^\r\n                ... Use \"/* verilator lint_off WIDTH */\" and lint_on around source to disable this message.\r\n%Warning-WIDTH: a.sv:7:22: Operator COND expects 32 or 3 bits on the Conditional False, but Conditional False's VARREF 'd' generates 2 bits.\r\n                         : ... In instance Foo\r\n    7 |   assign b = array[c ? 2'h0 : d];  \r\n      |                      ^\r\n``` ","labels":[{"id":"MDU6TGFiZWwyNjM1MzI5MzE1","name":"ExportVerilog","description":"","color":"1d76db"}],"number":2087,"state":"OPEN","title":"[ExportVerilog] Verilator width warning about array_get ","url":"https://github.com/llvm/circt/issues/2087"}
{"body":"`firtool` bit extends each operand to the destination type. This seems to differ from `firrtl` output.\r\nThe output is semantically correct, but this might be a verilog output quality issue.\r\nSo, if a multiplication produces 3 bit result, then the input operands are extended to 3 bits.\r\nThis is the standard assumption for `HW` dialect, https://github.com/llvm/circt/blob/main/lib/Conversion/FIRRTLToHW/LowerToHW.cpp#L3005\r\n\r\nInput `fir` \r\n```python \r\ncircuit MyModule :\r\n\r\n  module MyModule :\r\n    input in1: UInt<1>\r\n    input in2: UInt<2>\r\n    output out: UInt<3>\r\n\r\n    out <= mul(in1, in2)\r\n```\r\n`firtool` output\r\n``` verilog\r\nmodule MyModule( \r\n  input        in1,\r\n  input  [1:0] in2,\r\n  output [2:0] out);                                                                                                                                                                                                                        \r\n  assign out = {2'h0, in1} * {1'h0, in2}; \r\nendmodule\r\n```\r\n`firrtl` output\r\n```verilog\r\nmodule MyModule(\r\n  input        in1,\r\n  input  [1:0] in2,\r\n  output [2:0] out\r\n);                                 \r\nassign out = in1 * in2;\r\nendmodule\r\n```\r\n","labels":[],"number":2669,"state":"OPEN","title":"[FIRRTL] Bitwidth conventions for artihmetic ops","url":"https://github.com/llvm/circt/issues/2669"}
{"body":"Since we don't support 0 width wires (https://github.com/llvm/circt/issues/2219), there are a lot of situations where we take the size of something (usually a type), and if it is 1, return 1, else return Log2_64_Ceil. This is common in situations like \"How many bits do I need to index into this array?\". Because we can't say zero bits for a 1 element array (yet), we use 1 bit. This logic gets sprinkled throughout the codebase (sometimes with alternate styles), to the point that I think it's worth having a helper, potentially in lib/Support, to do this so we have a consistent way of doing it. Good first issue, since it's simple to implement, and hunting down instances of Log2_64_Ceil is a good tour of CIRCT.","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIw","name":"enhancement","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwxODg4ODczNzIx","name":"good first issue","description":"Good for newcomers","color":"7057ff"}],"number":2909,"state":"OPEN","title":"Helper for llvm::Log2_64_Ceil or 1","url":"https://github.com/llvm/circt/issues/2909"}
{"body":"Dear All,\n\nI am writing to report a bug (or maybe my mis-use) of the FIFO code generated by `seq.FIFO`.\n\n````\n# simple.py\n\nfrom pycde import Input, Output, Module, System, Clock, Reset\nfrom pycde.types import SInt\nfrom pycde import generator\nfrom pycde.constructs import Reg\nfrom pycde.types import Bits, SInt\nfrom pycde.seq import FIFO\n\nclass Stage1(Module):\n    clk = Clock()\n    rst = Reset()\n    data = Output(Bits(32))\n\n    @generator\n    def construct(self):\n        reg = Reg(Bits(32), clk=self.clk, rst=self.rst, name='counter')\n        one = SInt(32)(1) \n        new_value_expr = reg.as_sint() + one\n        reg.assign(new_value_expr.as_bits()[0:32])\n        self.data = reg\n\nclass Stage2(Module):\n    clk = Clock()\n    rst = Reset()\n    push_in = Input(Bits(32))\n    pop_out = Output(Bits(32))\n    pushed = Output(Bits(32))\n\n    @generator\n    def construct(self):\n        one = Bits(1)(1)\n\n        fifo = FIFO(type=Bits(32),\n                     depth=2,\n                     clk=self.clk,\n                     rst=self.rst,\n                     rd_latency=0)\n\n        fifo.push(self.push_in, one)\n        self.pop_out = fifo.pop(one)\n\n        self.pushed = self.push_in\n\nclass Top(Module):\n    clk = Clock()\n    rst = Reset()\n    out = Output(Bits(32))\n    pushed = Output(Bits(32))\n\n    @generator\n    def construct(self):\n        stage1 = Stage1(clk=self.clk, rst=self.rst)\n        stage2 = Stage2(clk=self.clk, rst=self.rst, push_in=stage1.data)\n        self.out = stage2.pop_out\n        self.pushed = stage2.pushed\n\nsystem = System([Top], name=\"ExampleSystem\", output_directory=\"exsys\")\nsystem.compile()\n````\n\n````\n# tb.py\nimport os\nfrom pathlib import Path\n\nimport cocotb\nfrom cocotb.triggers import Timer\nfrom cocotb.runner import get_runner\n\n\n@cocotb.test()\nasync def test_tb(dut):\n\n    dut.clk.value = 1\n    dut.rst.value = 1\n    await Timer(500, units=\"ns\")\n    dut.clk.value = 0\n    dut.rst.value = 0\n\n    for cycle in range(100):\n        await Timer(500, units=\"ns\")\n        dut.clk.value = 1\n        await Timer(500, units=\"ns\")\n        dut.clk.value = 0\n        dut._log.info('popout={}, pushed={}'.format(int(dut.out.value), int(dut.pushed.value)))\n\n\ndef runner():\n\n    sim = 'verilator'\n\n    path = Path('./exsys/hw')\n\n    with open(path / 'filelist.f', 'r') as f:\n        srcs = [path / i.strip() for i in f.readlines()]\n\n    runner = get_runner(sim)\n    runner.build(sources=srcs, hdl_toplevel='Top', always=True)\n    runner.test(hdl_toplevel='Top', test_module='tb')\n\nif __name__ == \"__main__\":\n    runner()\n````\n\nIf we do the following to run:\n````\npython simle.py # generates the SV\npython tb.py\n````\n\nYou will see something like this:\n````\n     0.00ns INFO     cocotb.regression                  Found test tb.test_tb\n     0.00ns INFO     cocotb.regression                  running test_tb (1/1)\n  1500.00ns INFO     cocotb.Top                         popout=0, pushed=1\n  2500.00ns INFO     cocotb.Top                         popout=0, pushed=2\n  3500.00ns INFO     cocotb.Top                         popout=2, pushed=3\n  4500.00ns INFO     cocotb.Top                         popout=2, pushed=4\n  5500.00ns INFO     cocotb.Top                         popout=4, pushed=5\n  6500.00ns INFO     cocotb.Top                         popout=4, pushed=6\n  7500.00ns INFO     cocotb.Top                         popout=6, pushed=7\n  8500.00ns INFO     cocotb.Top                         popout=6, pushed=8\n  9500.00ns INFO     cocotb.Top                         popout=8, pushed=9\n 10500.00ns INFO     cocotb.Top                         popout=8, pushed=10\n````\n\nWhich indicates I pushed 1, 2, 3, 4, 5, but only 2, 4, 6, 8 where popped.\nI kinda looked at the generated code:\n\n````\n// Generated by CIRCT unknown git version\nmodule Stage2(\t// fifo-example/main.py:21\n  input         clk,\n                rst,\n  input  [31:0] push_in,\n  output [31:0] pop_out,\n                pushed\n);\n\n  wire        _GEN;\t// fifo-example/main.py:28\n  wire        _GEN_0;\t// fifo-example/main.py:28\n  reg  [1:0]  fifo_count;\t// fifo-example/main.py:28\n  reg  [31:0] fifo_mem[0:1];\t// fifo-example/main.py:28\n  reg         fifo_rd_addr;\t// fifo-example/main.py:28\n  reg         fifo_wr_addr;\t// fifo-example/main.py:28\n  always_ff @(posedge clk) begin\t// fifo-example/main.py:28\n    if (rst) begin\t// fifo-example/main.py:28\n      fifo_count <= 2'h0;\t// fifo-example/main.py:28\n      fifo_rd_addr <= 1'h0;\t// fifo-example/main.py:28\n      fifo_wr_addr <= 1'h0;\t// fifo-example/main.py:28\n    end\n    else begin\t// fifo-example/main.py:28\n      fifo_count <= fifo_count;\t// fifo-example/main.py:28\n      fifo_mem[fifo_wr_addr] <= push_in;\t// fifo-example/main.py:28\n      fifo_rd_addr <= _GEN ? fifo_rd_addr - 1'h1 : fifo_rd_addr;\t// fifo-example/main.py:28\n      fifo_wr_addr <= _GEN_0 ? fifo_wr_addr - 1'h1 : fifo_wr_addr;\t// fifo-example/main.py:28\n    end\n  end // always_ff @(posedge)\n  assign _GEN_0 = fifo_count != 2'h2;\t// fifo-example/main.py:28\n  assign _GEN = |fifo_count;\t// fifo-example/main.py:28\n  FIFO_empty_when_read_enabled: assert property (@(posedge clk) _GEN);\t// fifo-example/main.py:28\n  FIFO_full_when_write_enabled: assert property (@(posedge clk) _GEN_0);\t// fifo-example/main.py:28\n  assign pop_out = fifo_mem[fifo_rd_addr];\t// fifo-example/main.py:28\n  assign pushed = push_in;\t// fifo-example/main.py:28\nendmodule\n````\n\nI think the problem is at the `fifo_wr_addr` and `fifo_rd_addr`. It seems when both push and popped, `fifo_wr_addr` still moves its pointer forward while, `fifo_rd_addr` stays still at 0.","labels":[{"id":"MDU6TGFiZWwzMzQyNzE0MjY4","name":"Seq","description":"Involving the `seq` dialect","color":"7ED2BA"}],"number":8490,"state":"OPEN","title":"[Seq.FIFO] Incorrect FIFO state machine?","url":"https://github.com/llvm/circt/issues/8490"}
{"body":"Consider the following example, directly adapted from an existing `lower-domains.mlir` test:\n\n``` mlir\n firrtl.circuit \"Foo\" {\n  firrtl.domain @ClockDomain\n  firrtl.module private @ZeroWidthPort(\n    in %A: !firrtl.domain of @ClockDomain,\n    in %a: !firrtl.uint<0> domains [%A]\n  ) {\n  }\n  firrtl.module @Foo() {}\n}\n```\n\nCurrently, this will lower the `ZeroWidthPort` module to the following. This keeps the domain information, but it is intentionally empty because `LowerToHW` will strip zero-width ports.\n\n``` mlir\nfirrtl.module private @ZeroWidthPort(\n  in %A: !firrtl.class<@ClockDomain()>, \n  out %A_out: !firrtl.class<@ClockDomain_out(\n    in domainInfo_in: !firrtl.class<@ClockDomain()>, \n    out domainInfo_out: !firrtl.class<@ClockDomain()>, \n    in associations_in: !firrtl.list<path>, \n    out associations_out: !firrtl.list<path>\n  )>, \n  in %a: !firrtl.uint<0>\n) {\n      %A_object = firrtl.object @ClockDomain_out(in domainInfo_in: !firrtl.class<@ClockDomain()>, out domainInfo_out: !firrtl.class<@ClockDomain()>, in associations_in: !firrtl.list<path>, out associations_out: !firrtl.list<path>)\n      %0 = firrtl.object.subfield %A_object[domainInfo_in] : !firrtl.class<@ClockDomain_out(in domainInfo_in: !firrtl.class<@ClockDomain()>, out domainInfo_out: !firrtl.class<@ClockDomain()>, in associations_in: !firrtl.list<path>, out associations_out: !firrtl.list<path>)>\n      firrtl.propassign %0, %A : !firrtl.class<@ClockDomain()>\n      %1 = firrtl.object.subfield %A_object[associations_in] : !firrtl.class<@ClockDomain_out(in domainInfo_in: !firrtl.class<@ClockDomain()>, out domainInfo_out: !firrtl.class<@ClockDomain()>, in associations_in: !firrtl.list<path>, out associations_out: !firrtl.list<path>)>\n      %2 = firrtl.list.create  : !firrtl.list<path>\n      firrtl.propassign %1, %2 : !firrtl.list<path>\n      firrtl.propassign %A_out, %A_object : !firrtl.class<@ClockDomain_out(in domainInfo_in: !firrtl.class<@ClockDomain()>, out domainInfo_out: !firrtl.class<@ClockDomain()>, in associations_in: !firrtl.list<path>, out associations_out: !firrtl.list<path>)>\n    }\n```\n\nI've observed a handful of situations where there are private modules with lots of this going on, e.g., O(10) unused, inferred domains show up because there are lots of zero-width ports.\n\nIt would be better if truly unused domains could be stripped when they have no association information. This may motivate breaking the zero-width removal part of `LowerToHW` out to a pass that runs earlier in the FIRRTL to HW conversion pipeline.","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIw","name":"enhancement","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":9516,"state":"OPEN","title":"[FIRRTL] Elide domains of zero-width ports in LowerDomains","url":"https://github.com/llvm/circt/issues/9516"}
{"body":"The current `InferWidths` pass in firtool(1.109.0) exhibits two critical flaws:\n\n1. **Incorrect handling of circular dependencies**:  \n\nThe pass erroneously throws uninferrable exceptions for solvable constraints with circular dependencies, despite the existence of a least solution.\n**Demonstrative Example**:\n\n```firrtl\nFIRRTL version 3.0.0\ncircuit A:\n  module A:\n    input in : UInt<4>\n    input clock : Clock\n    output out : UInt\n    reg x : UInt, clock\n    connect x, add(tail(x,1), in)  // Constraint: wâ‚“ â‰¥ max(wâ‚“-1, 4) + 1\n    connect out, x\n```\n\n**Expected Solution**: wâ‚“ = 5\n**Observed Failure**:\n\n```Terminal\nerror: 'firrtl.reg' op is constrained to be wider than itself\n    reg x : UInt, clock\n    ^\n7:5: note: see current operation: %0 = \"firrtl.reg\"(%arg1) <{annotations = [], name = \"x\", nameKind = #firrtl<name_kind droppable_name>}> : (!firrtl.clock) -> !firrtl.uint\n8:14: note: constrained width W >= W+1 here:\n    x <= add(tail(x,1), in)\n             ^\n8:7: note: constrained width W >= W+1 here:\n    x <= add(tail(x,1), in)\n      ^\n```\n\n2. **Completeness Deficiencies in Constraint Resolution**: \n\nSource code analysis reveals fundamental incompleteness. The implementation fails to identify valid least solutions for constraint systems where such solutions provably exist and even throws unexpected reports.\n\n**Demonstrative Example**:\n\n```firrtl\nFIRRTL version 3.0.0\ncircuit Foo:\n  module Foo:\n    input in : UInt<4>\n    input clock : Clock\n    output out : UInt\n\n    reg x1 : UInt, clock\n    wire x2 : UInt\n    wire x3 : UInt\n\n    connect x1, mul(mul(x2, in), x2)  // Constraint: wâ‚“â‚ â‰¥ 2wâ‚“â‚‚ + 4\n    connect x3, shr(x1,2)             // Constraint: wâ‚“â‚ƒ â‰¥ max(wâ‚“â‚ - 2, 0)\n    connect x2, tail(x3,2)            // Constraint: wâ‚“â‚‚ â‰¥ wâ‚“â‚ƒ - 2\n    connect out, x1\n```\n\n**Expected Solution**: wâ‚“â‚ = 4, wâ‚“â‚‚ = 0, wâ‚“â‚ƒ = 2\n**Observed Failure** (seems nonsense):\n\n```\nerror: 'firrtl.reg' op is constrained to be wider than itself\n    reg x1 : UInt, clock\n    ^\n...\n12:21: note: constrained width W >= 2W+4 here:\n    connect x1, mul(mul(x2, in), x2)\n                ^\n14:17: note: constrained width W >= 2W here:\n    connect x2, tail(x3,2)\n                ^\n```\n\nThe erroneous \"constrained to be wider than itself\" diagnostic indicates failure to recognize satisfiable constraint chains. This exemplifies the algorithm's inability to systematically explore the solution space.\n\n### Request Rationale \n\nWe seek commit access to integrate a formally verified alternative implementation that:\n\n1. Resolves circular dependencies through topological sorting and scc decomposion.\n\n2. Guarantees completeness via branch-and-bound solution search.\n\nOur solution has been validated in the Rocq theorem prover (6.9k LOC proof).","labels":[],"number":9140,"state":"OPEN","title":"InferWidths Pass Fails on Solvable Width Constraints with Circular Dependencies.","url":"https://github.com/llvm/circt/issues/9140"}
{"body":"Except the signedness mentioned in https://github.com/llvm/circt/issues/4152, seems the bit cast also doesn't work. I tried both Version 1.48.0 and 1.44.0.\r\n\r\nHere we use the example in https://github.com/llvm/circt/pull/2825:\r\n\r\n```firrtl\r\ncircuit Foo:\r\n  module Foo:\r\n    input a: UInt<4>\r\n    input b: UInt<4>\r\n    output d: UInt<8>\r\n\r\n    node c = mul(a, b)\r\n    d <= c\r\n```\r\n\r\nRuning `firtool Foo.fir` got:\r\n```verilog\r\n// Generated by CIRCT firtool-1.48.0\r\nmodule Foo(\r\n  input  [3:0] a,\r\n               b,\r\n  output [7:0] d\r\n);\r\n\r\n  assign d = {4'h0, a} * {4'h0, b};\r\nendmodule\r\n\r\n```\r\n\r\nRuning `firtool --lowering-options=explicitBitcast Foo.fir` got:\r\n```verilog\r\n// Generated by CIRCT firtool-1.48.0\r\nmodule Foo(\r\n  input  [3:0] a,\r\n               b,\r\n  output [7:0] d\r\n);\r\n\r\n  assign d = 8'({4'h0, a} * {4'h0, b});\r\nendmodule\r\n```\r\n\r\nFrom [the document](https://circt.llvm.org/docs/VerilogGeneration/) and https://github.com/llvm/circt/pull/2825, what we want here might be:\r\n```verilog\r\n// default\r\nassign d = a * b;\r\n// with --lowering-options=explicitBitcast\r\nassign d = 8'(a * b);\r\n```\r\n\r\nPlease kindly suggest whether I missed any option that may help with this.","labels":[],"number":5698,"state":"OPEN","title":"[FIRRTL][ExportVerilog] Mult/Add Width Cast","url":"https://github.com/llvm/circt/issues/5698"}
{"body":"Currently constants are cached during parsing. However, the width/const casts of them are not. This creates a lot of unnecessary IR expansion that CSE will remove later. Fix this to avoid the blow-up.\r\n\r\nConsider:\r\n\r\n```\r\nFIRRTL version 2.0.0\r\ncircuit Foo:\r\n  module Foo:\r\n    output bu: UInt<8>\r\n    output ou: UInt<8>\r\n\r\n    bu <= UInt(\"b101010\")\r\n    ou <= UInt(\"o052\")\r\n```\r\n\r\nThis is parsed as:\r\n\r\n```mlir\r\nmodule {\r\n  firrtl.circuit \"Foo\" {\r\n    firrtl.module @Foo(out %bu: !firrtl.uint<8>, out %ou: !firrtl.uint<8>) attributes {convention = #firrtl<convention scalarized>} {\r\n      %c42_ui = firrtl.constant 42 : !firrtl.const.uint\r\n      %0 = firrtl.widthCast %c42_ui : (!firrtl.const.uint) -> !firrtl.const.uint<8>\r\n      %1 = firrtl.constCast %0 : (!firrtl.const.uint<8>) -> !firrtl.uint<8>\r\n      firrtl.strictconnect %bu, %1 : !firrtl.uint<8>\r\n      %2 = firrtl.widthCast %c42_ui : (!firrtl.const.uint) -> !firrtl.const.uint<8>\r\n      %3 = firrtl.constCast %2 : (!firrtl.const.uint<8>) -> !firrtl.uint<8>\r\n      firrtl.strictconnect %ou, %3 : !firrtl.uint<8>\r\n    }\r\n  }\r\n}\r\n```","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIx","name":"good first issue","description":"Good for newcomers","color":"7057ff"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":5379,"state":"OPEN","title":"[FIRRTL] Cache Parsed Width/Const Casts ","url":"https://github.com/llvm/circt/issues/5379"}
{"body":"When I write a FIRRTL program like this:\r\n```\r\ncircuit FormalSimple :\r\n  module FormalSimple :\r\n    input clock : Clock\r\n    input reset1 : UInt<1>\r\n    output io : UInt<10>\r\n\r\n    wire a1 : UInt\r\n    wire a2 : UInt\r\n\r\n    a1 <= shr(mul(a2, a2), 3)\r\n    a2 <= shr(mul(a1, a1), 3)\r\n\r\n    io <= a1\r\n```\r\nwidths constraints for implicit widths in the circuit should be:\r\n```\r\nx1 >= 2x2 -3\r\nx2 >= 2x1 -3\r\n```\r\nand the solution can be (2,1) or (1,2), which is confused to find out which solution should be assigned to a1,a2.\r\n\r\nIn fact for this case, firtool gives an error like this:\r\n```\r\nFormalSimple.fir:7:5: error: 'firrtl.wire' op is constrained to be wider than itself\r\n    wire a1 : UInt\r\n    ^\r\nFormalSimple.fir:7:5: note: see current operation: %0 = \"firrtl.wire\"() {annotations = [], name = \"a1\", nameKind = #firrtl<name_kind droppable_name>} : () -> !firrtl.uint\r\nFormalSimple.fir:11:15: note: constrained width W >= 2W here:\r\n    a2 <= shr(mul(a1, a1), 3)\r\n              ^\r\nFormalSimple.fir:11:11: note: constrained width W >= 2W-3 here:\r\n    a2 <= shr(mul(a1, a1), 3)\r\n          ^\r\nFormalSimple.fir:11:11: note: constrained width W >= 2W here:\r\nFormalSimple.fir:11:8: note: constrained width W >= 2W here:\r\n    a2 <= shr(mul(a1, a1), 3)\r\n       ^\r\nFormalSimple.fir:11:8: note: constrained width W >= 2W here:\r\nFormalSimple.fir:11:8: note: constrained width W >= 2W here:\r\nFormalSimple.fir:11:8: note: constrained width W >= 2W here:\r\nFormalSimple.fir:8:5: note: constrained width W >= 2W here:\r\n    wire a2 : UInt\r\n    ^\r\nFormalSimple.fir:11:15: note: constrained width W >= 2W here:\r\n    a2 <= shr(mul(a1, a1), 3)\r\n              ^\r\nFormalSimple.fir:11:11: note: constrained width W >= 2W-3 here:\r\n    a2 <= shr(mul(a1, a1), 3)\r\n          ^\r\nFormalSimple.fir:11:11: note: constrained width W >= 2W here:\r\nFormalSimple.fir:11:8: note: constrained width W >= 2W here:\r\n    a2 <= shr(mul(a1, a1), 3)\r\n       ^\r\nFormalSimple.fir:11:8: note: constrained width W >= 2W here:\r\nFormalSimple.fir:11:8: note: constrained width W >= 2W here:\r\nFormalSimple.fir:11:8: note: constrained width W >= 2W here:\r\nFormalSimple.fir:8:5: note: constrained width W >= 2W here:\r\n    wire a2 : UInt\r\n    ^\r\nFormalSimple.fir:10:15: note: constrained width W >= 4W here:\r\n    a1 <= shr(mul(a2, a2), 3)\r\n              ^\r\nFormalSimple.fir:10:11: note: constrained width W >= 4W-3 here:\r\n    a1 <= shr(mul(a2, a2), 3)\r\n          ^\r\nFormalSimple.fir:10:11: note: constrained width W >= 4W here:\r\nFormalSimple.fir:10:8: note: constrained width W >= 4W here:\r\n    a1 <= shr(mul(a2, a2), 3)\r\n       ^\r\nFormalSimple.fir:10:8: note: constrained width W >= 4W here:\r\nFormalSimple.fir:10:8: note: constrained width W >= 4W here:\r\nFormalSimple.fir:10:8: note: constrained width W >= 4W here:\r\n\r\n```\r\n\r\nThe error means this program is illegal For FIRRTL or there is some problem in CIRCT compiler? What should be the solution and the widths?","labels":[],"number":6924,"state":"OPEN","title":"[FIRRTL][InferWidths] When there is no unique minimal solution for width constraints, what should be the width?","url":"https://github.com/llvm/circt/issues/6924"}
{"body":"Currently, any `index`-typed values will be emitted with a fixed width, currently set to 64 bits. Unsurprisingly, testing shows that this can have a **huge** overhead in circuits. Eventually we want to have a proper (path- and flow sensitive) width-infererence pass to take care of this. Until then, it would be nice to have an option to the `HandshakeToFIRRTL` pass to specify what width these signals should be emitted with.","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIx","name":"good first issue","description":"Good for newcomers","color":"7057ff"},{"id":"MDU6TGFiZWwyMTUyNzUzODY1","name":"Handshake","description":"","color":"d0a6fc"}],"number":2458,"state":"OPEN","title":"[HandshakeToFIRRTL] Add option for Index bit width","url":"https://github.com/llvm/circt/issues/2458"}
{"body":"```mlir\r\nhw.module @Foo(%array: !hw.array<4xi6>, %c: i1, %d: i2) -> (b: i6) {\r\n    %c0_i2 = hw.constant 0 : i2\r\n    %0 = comb.mux %c, %c0_i2, %d : i2\r\n    %1 = hw.array_get %array[%0] : !hw.array<4xi6>\r\n    hw.output %1 : i6\r\n  }\r\n```\r\nwill be lowered into \r\n```verilog\r\nmodule Foo(\t// foo.mlir:1:1\r\n  input  [3:0][5:0] array,\r\n  input             c,\r\n  input  [1:0]      d,\r\n  output [5:0]      b);\r\n\r\n  assign b = array[c ? 2'h0 : d];\t// foo.mlir:2:13, :3:14, :4:12, :5:5\r\nendmodule\r\n```\r\n\r\nVerilator produces the following warnings\r\n```\r\n%Warning-WIDTH: a.sv:7:22: Operator COND expects 32 or 3 bits on the Conditional True, but Conditional True's CONST '2'h0' generates 2 bits.\r\n                         : ... In instance Foo\r\n    7 |   assign b = array[c ? 2'h0 : d];  \r\n      |                      ^\r\n                ... Use \"/* verilator lint_off WIDTH */\" and lint_on around source to disable this message.\r\n%Warning-WIDTH: a.sv:7:22: Operator COND expects 32 or 3 bits on the Conditional False, but Conditional False's VARREF 'd' generates 2 bits.\r\n                         : ... In instance Foo\r\n    7 |   assign b = array[c ? 2'h0 : d];  \r\n      |                      ^\r\n``` ","labels":[{"id":"MDU6TGFiZWwyNjM1MzI5MzE1","name":"ExportVerilog","description":"","color":"1d76db"}],"number":2087,"state":"OPEN","title":"[ExportVerilog] Verilator width warning about array_get ","url":"https://github.com/llvm/circt/issues/2087"}
{"body":"The following FIRRTL program\r\n\r\nProduces different width for the output port `_tmp40`\r\n\r\n```python\r\n; seed: 1144\r\ncircuit top_mod :\r\n  module top_mod :\r\n    output _tmp40: UInt\r\n    wire tmp19: UInt\r\n    tmp19 <= mul(UInt(\"o20575\"), UInt<1>(0))\r\n    _tmp40 <= dshl(UInt(\"b10011010000001011101\"), tail(tmp19, 15))\r\n```\r\n\r\nCompiled with `firtool` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output [19:0] _tmp40);\r\n\r\n  assign _tmp40 = 20'h9A05D;\t// a_top_mod.fir:3:3, :7:20\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.5-SNAPSHOT` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output [18:0] _tmp40\r\n);\r\n  assign _tmp40 = 19'h1a05d;\r\nendmodule\r\n```\r\n\r\n`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:\r\n\r\n```\r\nERROR: Can't match gold port `_tmp40_gold' to a gate port.\r\n```","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":1289,"state":"OPEN","title":"[FIRRTL] (dshl, tail, mul) width inference mismatch","url":"https://github.com/llvm/circt/issues/1289"}
{"body":"As reported on Matrix [[1]], there seems to be a performance bug in InferWidths. The code below hits a wall and can't get through width inference. Specifically, the performance issue is in the code that is checking for cycles in the constraints. If this code is turned off, then there is no problem getting this through InferWidths.\r\n\r\n``` mlir\r\nfirrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo(in %data: !firrtl.uint<2>, out %out: !firrtl.uint<2>) attributes {convention = #firrtl<convention scalarized>} {\r\n    %_out_WIRE = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_1 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_2 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_3 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_4 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_5 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_6 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_7 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_8 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_9 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_10 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_11 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_12 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_13 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_14 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_15 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_16 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_17 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_18 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_19 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_20 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_21 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_22 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_23 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_24 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_25 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_26 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_27 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_28 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_29 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_30 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_31 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_32 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_33 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_34 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_35 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_36 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_37 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_38 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_39 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_40 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_41 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_42 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_43 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_44 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_45 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_46 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_47 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_48 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_49 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_50 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_51 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_52 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_53 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_54 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_55 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_56 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_57 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_58 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_59 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_60 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_61 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_62 = firrtl.wire : !firrtl.uint\r\n    %_out_WIRE_63 = firrtl.wire : !firrtl.uint\r\n    %0 = firrtl.shl %data, 1 : (!firrtl.uint<2>) -> !firrtl.uint<3>\r\n    %_out_T = firrtl.node %0 : !firrtl.uint<3>\r\n    %1 = firrtl.xor %data, %_out_T : (!firrtl.uint<2>, !firrtl.uint<3>) -> !firrtl.uint<3>\r\n    %_out_T_1 = firrtl.node %1 : !firrtl.uint<3>\r\n    firrtl.connect %_out_WIRE, %_out_T_1 : !firrtl.uint, !firrtl.uint<3>\r\n    %2 = firrtl.shl %_out_WIRE, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_2 = firrtl.node %2 : !firrtl.uint\r\n    %3 = firrtl.xor %_out_WIRE, %_out_T_2 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_3 = firrtl.node %3 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_1, %_out_T_3 : !firrtl.uint, !firrtl.uint\r\n    %4 = firrtl.shl %_out_WIRE_1, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_4 = firrtl.node %4 : !firrtl.uint\r\n    %5 = firrtl.xor %_out_WIRE_1, %_out_T_4 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_5 = firrtl.node %5 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_2, %_out_T_5 : !firrtl.uint, !firrtl.uint\r\n    %6 = firrtl.shl %_out_WIRE_2, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_6 = firrtl.node %6 : !firrtl.uint\r\n    %7 = firrtl.xor %_out_WIRE_2, %_out_T_6 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_7 = firrtl.node %7 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_3, %_out_T_7 : !firrtl.uint, !firrtl.uint\r\n    %8 = firrtl.shl %_out_WIRE_3, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_8 = firrtl.node %8 : !firrtl.uint\r\n    %9 = firrtl.xor %_out_WIRE_3, %_out_T_8 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_9 = firrtl.node %9 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_4, %_out_T_9 : !firrtl.uint, !firrtl.uint\r\n    %10 = firrtl.shl %_out_WIRE_4, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_10 = firrtl.node %10 : !firrtl.uint\r\n    %11 = firrtl.xor %_out_WIRE_4, %_out_T_10 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_11 = firrtl.node %11 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_5, %_out_T_11 : !firrtl.uint, !firrtl.uint\r\n    %12 = firrtl.shl %_out_WIRE_5, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_12 = firrtl.node %12 : !firrtl.uint\r\n    %13 = firrtl.xor %_out_WIRE_5, %_out_T_12 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_13 = firrtl.node %13 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_6, %_out_T_13 : !firrtl.uint, !firrtl.uint\r\n    %14 = firrtl.shl %_out_WIRE_6, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_14 = firrtl.node %14 : !firrtl.uint\r\n    %15 = firrtl.xor %_out_WIRE_6, %_out_T_14 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_15 = firrtl.node %15 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_7, %_out_T_15 : !firrtl.uint, !firrtl.uint\r\n    %16 = firrtl.shl %_out_WIRE_7, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_16 = firrtl.node %16 : !firrtl.uint\r\n    %17 = firrtl.xor %_out_WIRE_7, %_out_T_16 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_17 = firrtl.node %17 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_8, %_out_T_17 : !firrtl.uint, !firrtl.uint\r\n    %18 = firrtl.shl %_out_WIRE_8, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_18 = firrtl.node %18 : !firrtl.uint\r\n    %19 = firrtl.xor %_out_WIRE_8, %_out_T_18 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_19 = firrtl.node %19 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_9, %_out_T_19 : !firrtl.uint, !firrtl.uint\r\n    %20 = firrtl.shl %_out_WIRE_9, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_20 = firrtl.node %20 : !firrtl.uint\r\n    %21 = firrtl.xor %_out_WIRE_9, %_out_T_20 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_21 = firrtl.node %21 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_10, %_out_T_21 : !firrtl.uint, !firrtl.uint\r\n    %22 = firrtl.shl %_out_WIRE_10, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_22 = firrtl.node %22 : !firrtl.uint\r\n    %23 = firrtl.xor %_out_WIRE_10, %_out_T_22 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_23 = firrtl.node %23 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_11, %_out_T_23 : !firrtl.uint, !firrtl.uint\r\n    %24 = firrtl.shl %_out_WIRE_11, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_24 = firrtl.node %24 : !firrtl.uint\r\n    %25 = firrtl.xor %_out_WIRE_11, %_out_T_24 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_25 = firrtl.node %25 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_12, %_out_T_25 : !firrtl.uint, !firrtl.uint\r\n    %26 = firrtl.shl %_out_WIRE_12, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_26 = firrtl.node %26 : !firrtl.uint\r\n    %27 = firrtl.xor %_out_WIRE_12, %_out_T_26 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_27 = firrtl.node %27 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_13, %_out_T_27 : !firrtl.uint, !firrtl.uint\r\n    %28 = firrtl.shl %_out_WIRE_13, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_28 = firrtl.node %28 : !firrtl.uint\r\n    %29 = firrtl.xor %_out_WIRE_13, %_out_T_28 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_29 = firrtl.node %29 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_14, %_out_T_29 : !firrtl.uint, !firrtl.uint\r\n    %30 = firrtl.shl %_out_WIRE_14, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_30 = firrtl.node %30 : !firrtl.uint\r\n    %31 = firrtl.xor %_out_WIRE_14, %_out_T_30 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_31 = firrtl.node %31 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_15, %_out_T_31 : !firrtl.uint, !firrtl.uint\r\n    %32 = firrtl.shl %_out_WIRE_15, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_32 = firrtl.node %32 : !firrtl.uint\r\n    %33 = firrtl.xor %_out_WIRE_15, %_out_T_32 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_33 = firrtl.node %33 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_16, %_out_T_33 : !firrtl.uint, !firrtl.uint\r\n    %34 = firrtl.shl %_out_WIRE_16, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_34 = firrtl.node %34 : !firrtl.uint\r\n    %35 = firrtl.xor %_out_WIRE_16, %_out_T_34 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_35 = firrtl.node %35 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_17, %_out_T_35 : !firrtl.uint, !firrtl.uint\r\n    %36 = firrtl.shl %_out_WIRE_17, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_36 = firrtl.node %36 : !firrtl.uint\r\n    %37 = firrtl.xor %_out_WIRE_17, %_out_T_36 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_37 = firrtl.node %37 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_18, %_out_T_37 : !firrtl.uint, !firrtl.uint\r\n    %38 = firrtl.shl %_out_WIRE_18, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_38 = firrtl.node %38 : !firrtl.uint\r\n    %39 = firrtl.xor %_out_WIRE_18, %_out_T_38 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_39 = firrtl.node %39 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_19, %_out_T_39 : !firrtl.uint, !firrtl.uint\r\n    %40 = firrtl.shl %_out_WIRE_19, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_40 = firrtl.node %40 : !firrtl.uint\r\n    %41 = firrtl.xor %_out_WIRE_19, %_out_T_40 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_41 = firrtl.node %41 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_20, %_out_T_41 : !firrtl.uint, !firrtl.uint\r\n    %42 = firrtl.shl %_out_WIRE_20, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_42 = firrtl.node %42 : !firrtl.uint\r\n    %43 = firrtl.xor %_out_WIRE_20, %_out_T_42 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_43 = firrtl.node %43 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_21, %_out_T_43 : !firrtl.uint, !firrtl.uint\r\n    %44 = firrtl.shl %_out_WIRE_21, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_44 = firrtl.node %44 : !firrtl.uint\r\n    %45 = firrtl.xor %_out_WIRE_21, %_out_T_44 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_45 = firrtl.node %45 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_22, %_out_T_45 : !firrtl.uint, !firrtl.uint\r\n    %46 = firrtl.shl %_out_WIRE_22, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_46 = firrtl.node %46 : !firrtl.uint\r\n    %47 = firrtl.xor %_out_WIRE_22, %_out_T_46 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_47 = firrtl.node %47 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_23, %_out_T_47 : !firrtl.uint, !firrtl.uint\r\n    %48 = firrtl.shl %_out_WIRE_23, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_48 = firrtl.node %48 : !firrtl.uint\r\n    %49 = firrtl.xor %_out_WIRE_23, %_out_T_48 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_49 = firrtl.node %49 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_24, %_out_T_49 : !firrtl.uint, !firrtl.uint\r\n    %50 = firrtl.shl %_out_WIRE_24, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_50 = firrtl.node %50 : !firrtl.uint\r\n    %51 = firrtl.xor %_out_WIRE_24, %_out_T_50 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_51 = firrtl.node %51 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_25, %_out_T_51 : !firrtl.uint, !firrtl.uint\r\n    %52 = firrtl.shl %_out_WIRE_25, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_52 = firrtl.node %52 : !firrtl.uint\r\n    %53 = firrtl.xor %_out_WIRE_25, %_out_T_52 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_53 = firrtl.node %53 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_26, %_out_T_53 : !firrtl.uint, !firrtl.uint\r\n    %54 = firrtl.shl %_out_WIRE_26, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_54 = firrtl.node %54 : !firrtl.uint\r\n    %55 = firrtl.xor %_out_WIRE_26, %_out_T_54 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_55 = firrtl.node %55 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_27, %_out_T_55 : !firrtl.uint, !firrtl.uint\r\n    %56 = firrtl.shl %_out_WIRE_27, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_56 = firrtl.node %56 : !firrtl.uint\r\n    %57 = firrtl.xor %_out_WIRE_27, %_out_T_56 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_57 = firrtl.node %57 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_28, %_out_T_57 : !firrtl.uint, !firrtl.uint\r\n    %58 = firrtl.shl %_out_WIRE_28, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_58 = firrtl.node %58 : !firrtl.uint\r\n    %59 = firrtl.xor %_out_WIRE_28, %_out_T_58 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_59 = firrtl.node %59 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_29, %_out_T_59 : !firrtl.uint, !firrtl.uint\r\n    %60 = firrtl.shl %_out_WIRE_29, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_60 = firrtl.node %60 : !firrtl.uint\r\n    %61 = firrtl.xor %_out_WIRE_29, %_out_T_60 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_61 = firrtl.node %61 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_30, %_out_T_61 : !firrtl.uint, !firrtl.uint\r\n    %62 = firrtl.shl %_out_WIRE_30, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_62 = firrtl.node %62 : !firrtl.uint\r\n    %63 = firrtl.xor %_out_WIRE_30, %_out_T_62 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_63 = firrtl.node %63 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_31, %_out_T_63 : !firrtl.uint, !firrtl.uint\r\n    %64 = firrtl.shl %_out_WIRE_31, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_64 = firrtl.node %64 : !firrtl.uint\r\n    %65 = firrtl.xor %_out_WIRE_31, %_out_T_64 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_65 = firrtl.node %65 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_32, %_out_T_65 : !firrtl.uint, !firrtl.uint\r\n    %66 = firrtl.shl %_out_WIRE_32, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_66 = firrtl.node %66 : !firrtl.uint\r\n    %67 = firrtl.xor %_out_WIRE_32, %_out_T_66 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_67 = firrtl.node %67 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_33, %_out_T_67 : !firrtl.uint, !firrtl.uint\r\n    %68 = firrtl.shl %_out_WIRE_33, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_68 = firrtl.node %68 : !firrtl.uint\r\n    %69 = firrtl.xor %_out_WIRE_33, %_out_T_68 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_69 = firrtl.node %69 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_34, %_out_T_69 : !firrtl.uint, !firrtl.uint\r\n    %70 = firrtl.shl %_out_WIRE_34, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_70 = firrtl.node %70 : !firrtl.uint\r\n    %71 = firrtl.xor %_out_WIRE_34, %_out_T_70 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_71 = firrtl.node %71 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_35, %_out_T_71 : !firrtl.uint, !firrtl.uint\r\n    %72 = firrtl.shl %_out_WIRE_35, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_72 = firrtl.node %72 : !firrtl.uint\r\n    %73 = firrtl.xor %_out_WIRE_35, %_out_T_72 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_73 = firrtl.node %73 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_36, %_out_T_73 : !firrtl.uint, !firrtl.uint\r\n    %74 = firrtl.shl %_out_WIRE_36, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_74 = firrtl.node %74 : !firrtl.uint\r\n    %75 = firrtl.xor %_out_WIRE_36, %_out_T_74 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_75 = firrtl.node %75 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_37, %_out_T_75 : !firrtl.uint, !firrtl.uint\r\n    %76 = firrtl.shl %_out_WIRE_37, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_76 = firrtl.node %76 : !firrtl.uint\r\n    %77 = firrtl.xor %_out_WIRE_37, %_out_T_76 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_77 = firrtl.node %77 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_38, %_out_T_77 : !firrtl.uint, !firrtl.uint\r\n    %78 = firrtl.shl %_out_WIRE_38, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_78 = firrtl.node %78 : !firrtl.uint\r\n    %79 = firrtl.xor %_out_WIRE_38, %_out_T_78 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_79 = firrtl.node %79 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_39, %_out_T_79 : !firrtl.uint, !firrtl.uint\r\n    %80 = firrtl.shl %_out_WIRE_39, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_80 = firrtl.node %80 : !firrtl.uint\r\n    %81 = firrtl.xor %_out_WIRE_39, %_out_T_80 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_81 = firrtl.node %81 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_40, %_out_T_81 : !firrtl.uint, !firrtl.uint\r\n    %82 = firrtl.shl %_out_WIRE_40, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_82 = firrtl.node %82 : !firrtl.uint\r\n    %83 = firrtl.xor %_out_WIRE_40, %_out_T_82 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_83 = firrtl.node %83 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_41, %_out_T_83 : !firrtl.uint, !firrtl.uint\r\n    %84 = firrtl.shl %_out_WIRE_41, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_84 = firrtl.node %84 : !firrtl.uint\r\n    %85 = firrtl.xor %_out_WIRE_41, %_out_T_84 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_85 = firrtl.node %85 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_42, %_out_T_85 : !firrtl.uint, !firrtl.uint\r\n    %86 = firrtl.shl %_out_WIRE_42, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_86 = firrtl.node %86 : !firrtl.uint\r\n    %87 = firrtl.xor %_out_WIRE_42, %_out_T_86 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_87 = firrtl.node %87 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_43, %_out_T_87 : !firrtl.uint, !firrtl.uint\r\n    %88 = firrtl.shl %_out_WIRE_43, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_88 = firrtl.node %88 : !firrtl.uint\r\n    %89 = firrtl.xor %_out_WIRE_43, %_out_T_88 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_89 = firrtl.node %89 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_44, %_out_T_89 : !firrtl.uint, !firrtl.uint\r\n    %90 = firrtl.shl %_out_WIRE_44, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_90 = firrtl.node %90 : !firrtl.uint\r\n    %91 = firrtl.xor %_out_WIRE_44, %_out_T_90 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_91 = firrtl.node %91 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_45, %_out_T_91 : !firrtl.uint, !firrtl.uint\r\n    %92 = firrtl.shl %_out_WIRE_45, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_92 = firrtl.node %92 : !firrtl.uint\r\n    %93 = firrtl.xor %_out_WIRE_45, %_out_T_92 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_93 = firrtl.node %93 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_46, %_out_T_93 : !firrtl.uint, !firrtl.uint\r\n    %94 = firrtl.shl %_out_WIRE_46, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_94 = firrtl.node %94 : !firrtl.uint\r\n    %95 = firrtl.xor %_out_WIRE_46, %_out_T_94 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_95 = firrtl.node %95 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_47, %_out_T_95 : !firrtl.uint, !firrtl.uint\r\n    %96 = firrtl.shl %_out_WIRE_47, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_96 = firrtl.node %96 : !firrtl.uint\r\n    %97 = firrtl.xor %_out_WIRE_47, %_out_T_96 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_97 = firrtl.node %97 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_48, %_out_T_97 : !firrtl.uint, !firrtl.uint\r\n    %98 = firrtl.shl %_out_WIRE_48, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_98 = firrtl.node %98 : !firrtl.uint\r\n    %99 = firrtl.xor %_out_WIRE_48, %_out_T_98 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_99 = firrtl.node %99 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_49, %_out_T_99 : !firrtl.uint, !firrtl.uint\r\n    %100 = firrtl.shl %_out_WIRE_49, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_100 = firrtl.node %100 : !firrtl.uint\r\n    %101 = firrtl.xor %_out_WIRE_49, %_out_T_100 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_101 = firrtl.node %101 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_50, %_out_T_101 : !firrtl.uint, !firrtl.uint\r\n    %102 = firrtl.shl %_out_WIRE_50, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_102 = firrtl.node %102 : !firrtl.uint\r\n    %103 = firrtl.xor %_out_WIRE_50, %_out_T_102 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_103 = firrtl.node %103 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_51, %_out_T_103 : !firrtl.uint, !firrtl.uint\r\n    %104 = firrtl.shl %_out_WIRE_51, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_104 = firrtl.node %104 : !firrtl.uint\r\n    %105 = firrtl.xor %_out_WIRE_51, %_out_T_104 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_105 = firrtl.node %105 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_52, %_out_T_105 : !firrtl.uint, !firrtl.uint\r\n    %106 = firrtl.shl %_out_WIRE_52, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_106 = firrtl.node %106 : !firrtl.uint\r\n    %107 = firrtl.xor %_out_WIRE_52, %_out_T_106 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_107 = firrtl.node %107 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_53, %_out_T_107 : !firrtl.uint, !firrtl.uint\r\n    %108 = firrtl.shl %_out_WIRE_53, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_108 = firrtl.node %108 : !firrtl.uint\r\n    %109 = firrtl.xor %_out_WIRE_53, %_out_T_108 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_109 = firrtl.node %109 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_54, %_out_T_109 : !firrtl.uint, !firrtl.uint\r\n    %110 = firrtl.shl %_out_WIRE_54, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_110 = firrtl.node %110 : !firrtl.uint\r\n    %111 = firrtl.xor %_out_WIRE_54, %_out_T_110 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_111 = firrtl.node %111 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_55, %_out_T_111 : !firrtl.uint, !firrtl.uint\r\n    %112 = firrtl.shl %_out_WIRE_55, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_112 = firrtl.node %112 : !firrtl.uint\r\n    %113 = firrtl.xor %_out_WIRE_55, %_out_T_112 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_113 = firrtl.node %113 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_56, %_out_T_113 : !firrtl.uint, !firrtl.uint\r\n    %114 = firrtl.shl %_out_WIRE_56, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_114 = firrtl.node %114 : !firrtl.uint\r\n    %115 = firrtl.xor %_out_WIRE_56, %_out_T_114 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_115 = firrtl.node %115 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_57, %_out_T_115 : !firrtl.uint, !firrtl.uint\r\n    %116 = firrtl.shl %_out_WIRE_57, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_116 = firrtl.node %116 : !firrtl.uint\r\n    %117 = firrtl.xor %_out_WIRE_57, %_out_T_116 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_117 = firrtl.node %117 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_58, %_out_T_117 : !firrtl.uint, !firrtl.uint\r\n    %118 = firrtl.shl %_out_WIRE_58, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_118 = firrtl.node %118 : !firrtl.uint\r\n    %119 = firrtl.xor %_out_WIRE_58, %_out_T_118 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_119 = firrtl.node %119 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_59, %_out_T_119 : !firrtl.uint, !firrtl.uint\r\n    %120 = firrtl.shl %_out_WIRE_59, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_120 = firrtl.node %120 : !firrtl.uint\r\n    %121 = firrtl.xor %_out_WIRE_59, %_out_T_120 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_121 = firrtl.node %121 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_60, %_out_T_121 : !firrtl.uint, !firrtl.uint\r\n    %122 = firrtl.shl %_out_WIRE_60, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_122 = firrtl.node %122 : !firrtl.uint\r\n    %123 = firrtl.xor %_out_WIRE_60, %_out_T_122 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_123 = firrtl.node %123 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_61, %_out_T_123 : !firrtl.uint, !firrtl.uint\r\n    %124 = firrtl.shl %_out_WIRE_61, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_124 = firrtl.node %124 : !firrtl.uint\r\n    %125 = firrtl.xor %_out_WIRE_61, %_out_T_124 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_125 = firrtl.node %125 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_62, %_out_T_125 : !firrtl.uint, !firrtl.uint\r\n    %126 = firrtl.shl %_out_WIRE_62, 1 : (!firrtl.uint) -> !firrtl.uint\r\n    %_out_T_126 = firrtl.node %126 : !firrtl.uint\r\n    %127 = firrtl.xor %_out_WIRE_62, %_out_T_126 : (!firrtl.uint, !firrtl.uint) -> !firrtl.uint\r\n    %_out_T_127 = firrtl.node %127 : !firrtl.uint\r\n    firrtl.connect %_out_WIRE_63, %_out_T_127 : !firrtl.uint, !firrtl.uint\r\n    firrtl.connect %out, %_out_WIRE_63 : !firrtl.uint<2>, !firrtl.uint\r\n  }\r\n}\r\n```\r\n\r\nThis was generated using the following Chisel:\r\n\r\n``` scala\r\n//> using scala \"2.13.12\"\r\n//> using repository sonatype-s01:snapshots\r\n//> using lib \"org.chipsalliance::chisel::6.0.0+74-0a437d8f-SNAPSHOT\"\r\n//> using plugin \"org.chipsalliance:::chisel-plugin::6.0.0+74-0a437d8f-SNAPSHOT\"\r\n//> using options \"-unchecked\", \"-deprecation\", \"-language:reflectiveCalls\", \"-feature\", \"-Xcheckinit\", \"-Xfatal-warnings\", \"-Ywarn-dead-code\", \"-Ywarn-unused\", \"-Ymacro-annotations\"\r\n\r\nimport chisel3._\r\nimport circt.stage.ChiselStage\r\nimport scala.collection._\r\n\r\nclass Foo extends RawModule {\r\n  val data = IO(Input(UInt(2.W)))\r\n  val out = IO(Output(UInt(2.W)))\r\n\r\n  out := Seq.fill(64)(Wire(UInt())).foldLeft(data) { case (acc, x) =>\r\n    x := acc ^ (acc << 1)\r\n    x\r\n  }\r\n\r\n}\r\n\r\nobject Main extends App {\r\n  println(ChiselStage.emitCHIRRTL(new Foo))\r\n}\r\n\r\n```\r\n\r\n[1]: https://matrix.to/#/!jSbgpvvpsPbLpsLZOC:matrix.org/$41W74c99PoatTg2NR_16i-NI8cwRljRf80pQs_jvjg0?via=matrix.org&via=gitter.im&via=austin-harris.com","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":6742,"state":"OPEN","title":"[FIRRTL] Infer Widths Unbreakable Loop Checking Performance Issues","url":"https://github.com/llvm/circt/issues/6742"}
{"body":"Test case, produced while working on #4395 :\r\n\r\n```mlir\r\nfirrtl.circuit \"zeroWidthOperand\" {\r\nfirrtl.module @zeroWidthOperand(\r\n  in %in0 : !firrtl.uint<0>,\r\n  in %in1 : !firrtl.uint<1>,\r\n  out %o_add1: !firrtl.uint<2>,\r\n  out %o_add2: !firrtl.uint<2>,\r\n  out %o_sub1: !firrtl.uint<2>,\r\n  out %o_sub2: !firrtl.uint<2>,\r\n  out %o_mul1: !firrtl.uint<1>,\r\n  out %o_mul2: !firrtl.uint<1>,\r\n  out %o_div1: !firrtl.uint<0>,\r\n  out %o_div2: !firrtl.uint<1>,\r\n  out %o_rem1: !firrtl.uint<0>,\r\n  out %o_rem2: !firrtl.uint<0>,\r\n  out %o_dshl1: !firrtl.uint<1>,\r\n  out %o_dshl2: !firrtl.uint<1>,\r\n  out %o_dshlw1: !firrtl.uint<0>,\r\n  out %o_dshlw2: !firrtl.uint<1>,\r\n  out %o_dshr1: !firrtl.uint<0>,\r\n  out %o_dshr2: !firrtl.uint<1>,\r\n  out %o_and1: !firrtl.uint<1>,\r\n  out %o_and2: !firrtl.uint<1>,\r\n  out %o_or1: !firrtl.uint<1>,\r\n  out %o_or2: !firrtl.uint<1>,\r\n  out %o_xor1: !firrtl.uint<1>,\r\n  out %o_xor2: !firrtl.uint<1>\r\n) {\r\n  %add1 = firrtl.add %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<2>\r\n  %add2 = firrtl.add %in1, %in0 : (!firrtl.uint<1>, !firrtl.uint<0>) -> !firrtl.uint<2>\r\n  %sub1 = firrtl.sub %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<2>\r\n  %sub2 = firrtl.sub %in1, %in0 : (!firrtl.uint<1>, !firrtl.uint<0>) -> !firrtl.uint<2>\r\n  %mul1 = firrtl.mul %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<1>\r\n  %mul2 = firrtl.mul %in1, %in0 : (!firrtl.uint<1>, !firrtl.uint<0>) -> !firrtl.uint<1>\r\n  %div1 = firrtl.div %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<0>\r\n  %div2 = firrtl.div %in1, %in0 : (!firrtl.uint<1>, !firrtl.uint<0>) -> !firrtl.uint<1>\r\n  %rem1 = firrtl.rem %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<0>\r\n  %rem2 = firrtl.rem %in1, %in0 : (!firrtl.uint<1>, !firrtl.uint<0>) -> !firrtl.uint<0>\r\n  %dshl1 = firrtl.dshl %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<1>\r\n  %dshl2 = firrtl.dshl %in1, %in0 : (!firrtl.uint<1>, !firrtl.uint<0>) -> !firrtl.uint<1>\r\n  %dshlw1 = firrtl.dshlw %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<0>\r\n  %dshlw2 = firrtl.dshlw %in1, %in0 : (!firrtl.uint<1>, !firrtl.uint<0>) -> !firrtl.uint<1>\r\n  %dshr1 = firrtl.dshr %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<0>\r\n  %dshr2 = firrtl.dshr %in1, %in0 : (!firrtl.uint<1>, !firrtl.uint<0>) -> !firrtl.uint<1>\r\n  %and1 = firrtl.and %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<1>\r\n  %and2 = firrtl.and %in1, %in0 : (!firrtl.uint<1>, !firrtl.uint<0>) -> !firrtl.uint<1>\r\n  %or1 = firrtl.or %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<1>\r\n  %or2 = firrtl.or %in1, %in0 : (!firrtl.uint<1>, !firrtl.uint<0>) -> !firrtl.uint<1>\r\n  %xor1 = firrtl.xor %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<1>\r\n  %xor2 = firrtl.xor %in1, %in0 : (!firrtl.uint<1>, !firrtl.uint<0>) -> !firrtl.uint<1>\r\n\r\n  firrtl.strictconnect %o_add1, %add1 : !firrtl.uint<2>\r\n  firrtl.strictconnect %o_add2, %add2 : !firrtl.uint<2>\r\n  firrtl.strictconnect %o_sub1, %sub1: !firrtl.uint<2>\r\n  firrtl.strictconnect %o_sub2, %sub2: !firrtl.uint<2>\r\n  firrtl.strictconnect %o_mul1, %mul1: !firrtl.uint<1>\r\n  firrtl.strictconnect %o_mul2, %mul2: !firrtl.uint<1>\r\n  firrtl.strictconnect %o_div1, %div1 : !firrtl.uint<0>\r\n  firrtl.strictconnect %o_div2, %div2 : !firrtl.uint<1>\r\n  firrtl.strictconnect %o_rem1, %rem1 : !firrtl.uint<0>\r\n  firrtl.strictconnect %o_rem2, %rem2 : !firrtl.uint<0>\r\n  firrtl.strictconnect %o_dshl1, %dshl1 : !firrtl.uint<1>\r\n  firrtl.strictconnect %o_dshl2, %dshl2 : !firrtl.uint<1>\r\n  firrtl.strictconnect %o_dshlw1, %dshlw1 : !firrtl.uint<0>\r\n  firrtl.strictconnect %o_dshlw2, %dshlw2 : !firrtl.uint<1>\r\n  firrtl.strictconnect %o_dshr1, %dshr1 : !firrtl.uint<0>\r\n  firrtl.strictconnect %o_dshr2, %dshr2 : !firrtl.uint<1>\r\n  firrtl.strictconnect %o_and1, %and1 : !firrtl.uint<1>\r\n  firrtl.strictconnect %o_and2, %and2 : !firrtl.uint<1>\r\n  firrtl.strictconnect %o_or1, %or1 : !firrtl.uint<1>\r\n  firrtl.strictconnect %o_or2, %or2 : !firrtl.uint<1>\r\n  firrtl.strictconnect %o_xor1, %xor1 : !firrtl.uint<1>\r\n  firrtl.strictconnect %o_xor2, %xor2 : !firrtl.uint<1>\r\n}\r\n}\r\n```\r\n\r\nWith that PR, the operations with zero-width return are replaced with zero but the others are not folded/canonicalized (and at least most of them can be).\r\n\r\nHere's the current `firtool -ir-fir` output on the above:\r\n\r\n```mlir\r\nmodule {\r\n  firrtl.circuit \"zeroWidthOperand\"  {\r\n    firrtl.module @zeroWidthOperand(in %in0: !firrtl.uint<0>, in %in1: !firrtl.uint<1>, out %o_add1: !firrtl.uint<2>, out %o_add2: !firrtl.uint<2>, out %o_sub1: !firrtl.uint<2>, out %o_sub2: !firrtl.uint<2>, out %o_mul1: !firrtl.uint<1>, out %o_mul2: !firrtl.uint<1>, out %o_div1: !firrtl.uint<0>, out %o_div2: !firrtl.uint<1>, out %o_rem1: !firrtl.uint<0>, out %o_rem2: !firrtl.uint<0>, out %o_dshl1: !firrtl.uint<1>, out %o_dshl2: !firrtl.uint<1>, out %o_dshlw1: !firrtl.uint<0>, out %o_dshlw2: !firrtl.uint<1>, out %o_dshr1: !firrtl.uint<0>, out %o_dshr2: !firrtl.uint<1>, out %o_and1: !firrtl.uint<1>, out %o_and2: !firrtl.uint<1>, out %o_or1: !firrtl.uint<1>, out %o_or2: !firrtl.uint<1>, out %o_xor1: !firrtl.uint<1>, out %o_xor2: !firrtl.uint<1>) {\r\n      %0 = firrtl.add %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<2>\r\n      %1 = firrtl.sub %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<2>\r\n      %2 = firrtl.sub %in1, %in0 : (!firrtl.uint<1>, !firrtl.uint<0>) -> !firrtl.uint<2>\r\n      %3 = firrtl.mul %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<1>\r\n      %4 = firrtl.div %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<0>\r\n      %5 = firrtl.div %in1, %in0 : (!firrtl.uint<1>, !firrtl.uint<0>) -> !firrtl.uint<1>\r\n      %6 = firrtl.rem %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<0>\r\n      %7 = firrtl.rem %in1, %in0 : (!firrtl.uint<1>, !firrtl.uint<0>) -> !firrtl.uint<0>\r\n      %8 = firrtl.dshl %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<1>\r\n      %9 = firrtl.dshl %in1, %in0 : (!firrtl.uint<1>, !firrtl.uint<0>) -> !firrtl.uint<1>\r\n      %10 = firrtl.dshlw %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<0>\r\n      %11 = firrtl.dshlw %in1, %in0 : (!firrtl.uint<1>, !firrtl.uint<0>) -> !firrtl.uint<1>\r\n      %12 = firrtl.dshr %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<0>\r\n      %13 = firrtl.dshr %in1, %in0 : (!firrtl.uint<1>, !firrtl.uint<0>) -> !firrtl.uint<1>\r\n      %14 = firrtl.and %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<1>\r\n      %15 = firrtl.or %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<1>\r\n      %16 = firrtl.xor %in0, %in1 : (!firrtl.uint<0>, !firrtl.uint<1>) -> !firrtl.uint<1>\r\n      firrtl.strictconnect %o_add1, %0 : !firrtl.uint<2>\r\n      firrtl.strictconnect %o_add2, %0 : !firrtl.uint<2>\r\n      firrtl.strictconnect %o_sub1, %1 : !firrtl.uint<2>\r\n      firrtl.strictconnect %o_sub2, %2 : !firrtl.uint<2>\r\n      firrtl.strictconnect %o_mul1, %3 : !firrtl.uint<1>\r\n      firrtl.strictconnect %o_mul2, %3 : !firrtl.uint<1>\r\n      firrtl.strictconnect %o_div1, %4 : !firrtl.uint<0>\r\n      firrtl.strictconnect %o_div2, %5 : !firrtl.uint<1>\r\n      firrtl.strictconnect %o_rem1, %6 : !firrtl.uint<0>\r\n      firrtl.strictconnect %o_rem2, %7 : !firrtl.uint<0>\r\n      firrtl.strictconnect %o_dshl1, %8 : !firrtl.uint<1>\r\n      firrtl.strictconnect %o_dshl2, %9 : !firrtl.uint<1>\r\n      firrtl.strictconnect %o_dshlw1, %10 : !firrtl.uint<0>\r\n      firrtl.strictconnect %o_dshlw2, %11 : !firrtl.uint<1>\r\n      firrtl.strictconnect %o_dshr1, %12 : !firrtl.uint<0>\r\n      firrtl.strictconnect %o_dshr2, %13 : !firrtl.uint<1>\r\n      firrtl.strictconnect %o_and1, %14 : !firrtl.uint<1>\r\n      firrtl.strictconnect %o_and2, %14 : !firrtl.uint<1>\r\n      firrtl.strictconnect %o_or1, %15 : !firrtl.uint<1>\r\n      firrtl.strictconnect %o_or2, %15 : !firrtl.uint<1>\r\n      firrtl.strictconnect %o_xor1, %16 : !firrtl.uint<1>\r\n      firrtl.strictconnect %o_xor2, %16 : !firrtl.uint<1>\r\n    }\r\n  }\r\n}\r\n```\r\n","labels":[],"number":4396,"state":"OPEN","title":"[FIRRTLFolds] Fold binary operators with one zero-width operand","url":"https://github.com/llvm/circt/issues/4396"}
{"body":"Currently, all shift operations require their operands to all be the same type. This is logically wrong. If anything, the `rhs` should be `clog2(lhs)`. Am I right? Is there a particular reason we do things this way?","labels":[{"id":"MDU6TGFiZWwzMjYzNzQ4NjY5","name":"Comb","description":"Involving the `comb` dialect","color":"d4c5f9"}],"number":3285,"state":"OPEN","title":"[Comb] Shift operands need not be the same width","url":"https://github.com/llvm/circt/issues/3285"}
{"body":"The testcase checked in for this Issue #1104 was incorrectly - it was not zero width and not getting eliminated.  We need an updated one.","labels":[],"number":1125,"state":"OPEN","title":"Need a test case for zero width memory elimination","url":"https://github.com/llvm/circt/issues/1125"}
{"body":"We are emitting zero bit width array/struct as one bit element. This is problem when we use bitcast for them.\r\n\r\n```mlir\r\nhw.module @top(%source: i1) -> (b: !hw.struct<zero: !hw.array<1xi0>, c: i1>) {\r\n    %cast = hw.bitcast %source: (i1) -> !hw.struct<zero: !hw.array<1xi0>, c: i1>\r\n    hw.output %cast : !hw.struct<zero: !hw.array<1xi0>, c: i1>\r\n }\r\n```\r\n\r\n```sv\r\nmodule top(\t// out.mlir:2:3\r\n  input                                                            source,\r\n  output struct packed {logic [0:0]/*Zero Width*/ zero; logic c; } b);\r\n \r\n  assign b = source;\t// out.mlir:3:12, :4:5\r\nendmodule\r\n```\r\n","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwyNjM1MzI5MzE1","name":"ExportVerilog","description":"","color":"1d76db"}],"number":2504,"state":"OPEN","title":"[ExportVerilog] Incorrect verilog output for bitcast + zero width aggregate types","url":"https://github.com/llvm/circt/issues/2504"}
{"body":"Consider this MLIR example:\r\n\r\n```\r\nmodule {\r\n  firrtl.circuit \"OMIRField\" {\r\n    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0>, out %y_b: !firrtl.uint<0>) {\r\n      %n_b = firrtl.node sym @omir_sym %x_b : !firrtl.uint<0>\r\n      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>\r\n    }\r\n  }\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n}\r\n```\r\n\r\nFeeding through LowerToHW: `circt-opt --lower-firrtl-to-hw` produces:\r\n\r\n```\r\nmodule {\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n  hw.module @OMIRField() {\r\n    hw.output\r\n  }\r\n}\r\n```\r\n\r\nAnd if run through `firtool` directly, produces:\r\n```\r\nomir_zw_field_issue.mlir:8:3: error: cannot get name for symbol #hw.innerNameRef<@OMIRField::@omir_sym>\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n  ^\r\nomir_zw_field_issue.mlir:8:3: note: see current operation: \"sv.verbatim\"() {format_string = \"Testing {{0}}\", symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]} : () -> ()\r\n// Generated by CIRCT 1.46.0g20230714_98d0bf5\r\nTesting <INVALID>\t// omir_zw_field_issue.mlir:8:3\r\nmodule OMIRField();\t// omir_zw_field_issue.mlir:3:5\r\nendmodule\r\n```\r\n\r\nThe non-failing error isn't great and should be fixed (cc #4770 for similar in adjacent code).\r\nAlso, this should be caught by the verifier in HW but that support isn't in place yet (cc #3526).\r\n\r\n---\r\n\r\nMoving the symbol to a port produces an error, modified input:\r\n\r\n```\r\nmodule {\r\n  firrtl.circuit \"OMIRField\" {\r\n    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {\r\n      %n_b = firrtl.node %x_b : !firrtl.uint<0>\r\n      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>\r\n    }\r\n  }\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n}\r\n```\r\n\r\nError:\r\n```\r\nomir_zw_field_issue.mlir:3:33: error: zero width port \"x_b\" is referenced by name [#hw<innerSym@omir_sym>] (e.g. in an XMR) but must be removed\r\n    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {\r\n                                ^\r\n```","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":5590,"state":"OPEN","title":"[FIRRTL][LowerToHW] Zero-width signals with inner symbol are silently deleted, breaking users","url":"https://github.com/llvm/circt/issues/5590"}
{"body":"I observe that, the current `firrtl.connect` only checks the src width not larger than the dst width, but not vice versa. since in the firrtl parser logic we already define some the padding and truncate logic, we can make firrtl.connect be more strict, e.g. checking width exactly same to find width bug in the early phase.","labels":[],"number":8069,"state":"OPEN","title":"[FIRRTL] more strict connect semantic","url":"https://github.com/llvm/circt/issues/8069"}
{"body":"I've been messing around with FIRRTL attach operations nested in `WhenOp` regions fully expecting them to be illegal. After all Chisel refuses to produce them. But, after careful reading of the spec, it appears to me that they should simply be unaffected by the condition and, in fact, this is what both SFC and firtool do:\r\n\r\nfoo.fir:\r\n```\r\ncircuit Example :\r\n  module Example :\r\n    output a : Analog<1>\r\n    output b : Analog<1>\r\n    output c : Analog<1>\r\n    output d : Analog<1>\r\n\r\n    when UInt<1>(\"h1\") :\r\n      attach (a, b) \r\n    else :\r\n      attach (c, d)\r\n```\r\n\r\n```\r\n> firtool --verilog /tmp/foo.fir\r\n\r\n// Generated by CIRCT unknown git version\r\nmodule Example(\r\n  inout a,\r\n        b,\r\n        c,\r\n        d\r\n);\r\n\r\n  `ifdef SYNTHESIS\r\n    assign a = b;\r\n    assign b = a;\r\n    assign c = d;\r\n    assign d = c;\r\n  `else  // SYNTHESIS\r\n    `ifdef verilator\r\n      `error \"Verilator does not support alias and thus cannot arbitrarily connect bidirectional wires and ports\"\r\n      `error \"Verilator does not support alias and thus cannot arbitrarily connect bidirectional wires and ports\"\r\n    `else  // verilator\r\n      alias a = b;\r\n      alias c = d;\r\n    `endif // verilator\r\n  `endif // SYNTHESIS\r\nendmodule\r\n\r\n```\r\n\r\nBut if we run the canonicalizer added in #6236 before the `WhenOp` is removed by ExpandWhens, the 'unreachable' attach is dropped too:\r\n```\r\n> .firtool --parse-only /tmp/foo.fir | circt-opt --canonicalize | firtool -format=mlir --verilog\r\n\r\n// Generated by CIRCT unknown git version\r\nmodule Example( // <stdin>:3:5\r\n  inout a,      // <stdin>:3:32\r\n        b,      // <stdin>:3:59\r\n        c,      // <stdin>:3:86\r\n        d       // <stdin>:3:113\r\n);\r\n\r\n  `ifdef SYNTHESIS      // <stdin>:4:7\r\n    assign a = b;       // <stdin>:4:7\r\n    assign b = a;       // <stdin>:4:7\r\n  `else  // SYNTHESIS\r\n    `ifdef verilator    // <stdin>:4:7\r\n      `error \"Verilator does not support alias and thus cannot arbitrarily connect bidirectional wires and ports\"       // <stdin>:4:7\r\n    `else  // verilator\r\n      alias a = b;      // <stdin>:4:7\r\n    `endif // verilator\r\n  `endif // SYNTHESIS\r\nendmodule\r\n``` \r\n\r\nThis is obviously a highly constructed example, but it did cause me some confusion. I have no clue under what circumstances we expect canonicalization to be run before ExpandWhens. But since it was added there appears to be a use case and I guess this technically violates the spec?","labels":[],"number":6468,"state":"OPEN","title":"[FIRRTL] 'Conditional' Analog attach","url":"https://github.com/llvm/circt/issues/6468"}
{"body":"Consider:\r\n```firrtl\r\nFIRRTL version 4.0.0\r\n\r\ncircuit Foo :\r\n  layer L, bind :\r\n\r\n  extmodule Bar :\r\n    input a : Analog<1>\r\n  public module Foo :\r\n    input a : Analog<1>\r\n\r\n    layerblock L:\r\n      inst b of Bar\r\n      attach(b.a, a)\r\n```\r\n\r\nPresently this fails in the verifier after LowerLayers:\r\n\r\n```\r\n// -----// IR Dump Before LowerLayers (firrtl-lower-layers) //----- //\r\nfirrtl.circuit \"Foo\" {\r\n  firrtl.layer @L bind {\r\n  }\r\n  firrtl.extmodule private @Bar(in a: !firrtl.analog<1>) attributes {convention = #firrtl<convention scalarized>}\r\n  firrtl.module @Foo(in %a: !firrtl.analog<1>) attributes {convention = #firrtl<convention scalarized>} {\r\n    firrtl.layerblock @L {\r\n      %b_a = firrtl.instance b @Bar(in a: !firrtl.analog<1>)\r\n      firrtl.attach %b_a, %a : !firrtl.analog<1>, !firrtl.analog<1>\r\n    }\r\n  }\r\n}\r\n\r\nanalog-layer.fir:13:7: error: analog types may not be connected\r\n      attach(b.a, a)\r\n      ^\r\nanalog-layer.fir:13:7: note: see current operation: \"firrtl.matchingconnect\"(%0, %arg0) : (!firrtl.analog<1>, !firrtl.analog<1>) -> ()\r\n```\r\n\r\nLowerLayers should diagnose this if unsupported, or learn to emit an appropriate connect operation (attach).\r\n\r\nSince `attach` is bidirectional, it seems like it should not be allowed across layer boundaries for consistency with `connect` in that direction.","labels":[{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":7649,"state":"OPEN","title":"[FIRRTL] Layers and Analog","url":"https://github.com/llvm/circt/issues/7649"}
{"body":"## Title\n[circt-verilog][arcilator] `arcilator` fails to lower `llhd.constant_time` generated from simple SV delay (`#1`)\n\n## Summary\nI ran into a failure in the arcilator flow with a minimal SystemVerilog module using a single `#1` delay. The same design runs under Verilator, but arcilator reports `llhd.constant_time` as illegal during conversion to `arcs` and stops. I did a preliminary source-level analysis (below) and would like to discuss with maintainers whether this behavior is expected or should be treated as a bug.\n\n## Details\n\nThe SV design is intentionally minimal and only uses an `initial` block with a\nsingle `#1` delay. There are no clocks, resets, or inputs. The only signals are\ntwo outputs (`q` and `ok`) to indicate observable state and a success message.\n\nBehavior:\n- At time 0, both `q` and `ok` are set to `0`.\n- After `#1`, `q` is set to `1`, `ok` is set to `1`, and a `$display` message is\n  printed.\n\nObserved issue:\n- `circt-verilog --ir-hw` converts the `#1` delay into `llhd.constant_time`.\n- The arcilator pipeline then fails when lowering to `arcs`, reporting that\n  `llhd.constant_time` is illegal and the conversion fails.\n- The same SV code runs successfully under Verilator, so the issue appears\n  specific to the arcilator lowering path.\n\n\n## Reproduction\n### arcilator\nCreate `top.sv`:\n```systemverilog\nmodule top(output logic q, output logic ok);\n  initial begin\n    q = 1'b0;\n    ok = 1'b0;\n    #1 q = 1'b1;\n    ok = 1'b1;\n    $display(\"OK: arcilator run completed\");\n  end\nendmodule\n```\n\nRun:\n```bash\ncirct-verilog --ir-hw top.sv -o top.mlir\narcilator top.mlir --state-file=top.json | opt -O3 --strip-debug -S | llc -O3 --filetype=obj -o top.o\ncc top.o -o top\n./top\n```\n\n### verilator\nUse the same `top.sv` content as above.\n\nRun:\n```bash\nverilator -Wall --cc top.sv --exe sim_main.cpp\nmake -C obj_dir -f Vtop.mk Vtop\n./obj_dir/Vtop\n```\n\n## Actual Result (arcilator)\n```\ntop.mlir:4:10: error: failed to legalize operation 'llhd.constant_time' that was explicitly marked illegal\n    %0 = llhd.constant_time <1000000fs, 0d, 0e>\n         ^\ntop.mlir:1:1: error: conversion to arcs failed\nmodule {\n^\n```\n\n## Expected Result\nThe minimal delay should either:\n- be supported by arcilator, or\n- be lowered to something legal for `arcs` without failing.\n\n### Question:\nHow to solve this problem and simulate this sv problem?\n\n## Analysis of Failure Cause\nBased on the current sources, my preliminary analysis is that the failure stems from a missing legalization pattern in the `ConvertToArcs` pass:\n- `llhd.constant_time` is a valid LLHD op produced by `circt-verilog --ir-hw` for `#1` delays.\n- The arcilator pipeline runs `ConvertToArcs`, which marks the entire LLHD dialect illegal and only provides conversions for `llhd.combinational` and `llhd.yield`.\n\nhttps://github.com/llvm/circt/blob/3c58046f1d8fc6f5355a7f2c2b73b43ffb37ba4d/lib/Conversion/ConvertToArcs/ConvertToArcs.cpp#L567-L585\n\n- As a result, `llhd.constant_time` remains illegal with no rewrite available, and the dialect conversion reports a legalization failure.\n\n\n## Environment\n- OS: Linux 5.15.0-164-generic\n- CIRCT: firtool-1.139.0\n- LLVM: 22.0.0git\n- Verilator: 5.022 2024-02-24 (rev v5.020-157-g2b4852048)\n- Git commit: 2e2f4775452d1e0bb2c8075d845808f781268049\n\n## Notes\nThe failure appears at the `llhd.constant_time` op introduced during `circt-verilog --ir-hw`, before `arcilator` lowers to `arcs`.\n\n## Relevant Source References\n- `llhd.constant_time` is a core LLHD op that materializes a time constant. It is defined as `llhd.constant_time` in the LLHD value ops definition file. See `include/circt/Dialect/LLHD/IR/LLHDValueOps.td`.\n- The `ConvertToArcs` pass marks the entire LLHD dialect as illegal and only provides conversion patterns for `llhd.combinational` and `llhd.yield`. This means any other LLHD ops (including `llhd.constant_time`) remain illegal and will trigger a legalization failure. See `lib/Conversion/ConvertToArcs/ConvertToArcs.cpp`.\n- The arcilator pipeline explicitly runs `ConvertToArcs` as part of its arc conversion pipeline. See `lib/Tools/arcilator/pipelines.cpp`.\n","labels":[{"id":"MDU6TGFiZWwyMTY1NDc5NTk1","name":"LLHD","description":"","color":"e07b00"},{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":9467,"state":"OPEN","title":"[circt-verilog][arcilator] `arcilator` fails to lower `llhd.constant_time` generated from simple SV delay (`#1`)","url":"https://github.com/llvm/circt/issues/9467"}
{"body":"Should we call the passthrough after all arc.clock_tree calling? Take an output connected with a register for example, the output should be the latest value of the register after a clock trigger.","labels":[{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":9337,"state":"OPEN","title":"[arcilator] The position of the passthrough calling","url":"https://github.com/llvm/circt/issues/9337"}
{"body":"It looks like there are two configs of the Upload Release Artifacts CI job where check-circt fails on three arcilator tests:\n\nhttps://github.com/llvm/circt/actions/runs/19579832326/job/56099287786\n\nNot sure what changed since the last run of this CI action that causes the crash. @jpienaar could this be related to the additional arguments that are now getting passed to the simulation if run in JIT mode?","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":9260,"state":"OPEN","title":"Arcilator crashes in Upload Release Artifacts CI","url":"https://github.com/llvm/circt/issues/9260"}
{"body":"There are a bunch of features we might want to support for arcilator simulations that are a pain to implement in MLIR / LLVM IR directly and should preferably made available by a runtime library. Off the top of my head, this could include:\n- Advanced formatted printing (arbitrary width integers, binary formatting, padding, X/Z values)\n- Everything involving the file system\n- Parsing memory initialization files\n- Managing dynamic buffers and containers\n- PRNG algorithms and seeding for reproducible random initialization\n- Multi-threading (enqueue a series of simulation runs and dispatch them to a thread pool)\n\nWe also want these features to be available in JITed runs, so we need to make sure the compiled functions are visible to the execution engine. Depending on the host platform [this can get a little messy](https://github.com/llvm/llvm-project/blob/c6c2e21028cadef854cf22f6ecaa5eb9d224b76d/llvm/cmake/modules/AddLLVM.cmake#L1344). The `arc-jit-env` library (#8483) was an attempt to compile the current header-only implementation in `arcilator-runtime.h` to a shared library. \n\nI've also experimented with a Rust implementation of a runtime library. Admittedly, more out of personal curiosity rather than for technical reasons. Having the Rust Standard Library and cargo available to pull in crates like `num_bigint` certainly is nice to get things done quickly. On the other hand we inevitably have to do a fair amount of unsafe pointer ping-pong between the IR model and the runtime, potentially defeating the whole memory safety aspect of Rust. _If_ we were to go for a Rust implementation we'd also have to figure out to what extent we want to isolate it from the rest. Should we keep the sources in-tree or in a separate project? Should it be integrated in the CMake build process?\n\nBut first of all, we need a lowering pipeline that can make use of such a library. ðŸ˜…","labels":[{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":8484,"state":"OPEN","title":"[arcilator] Add functionality to the arcilator runtime library","url":"https://github.com/llvm/circt/issues/8484"}
{"body":"Arcilator is currently very easy to break if a public module is instantiated anywhere. In that case the module hierarchy does not get flattened completely, but the public module remains as an instance instead. This makes the instance behave like an external module. Fix the module flattening to also fully inline public modules (but instead also keep the public module itself around as a top-level entry point).","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":8232,"state":"OPEN","title":"[Arc] Flatten public modules","url":"https://github.com/llvm/circt/issues/8232"}
{"body":"The arcilator-runtime.h and python script are not installed and thus not included in pre-built releases.\n\nFor more information:\nhttps://discourse.llvm.org/t/proper-way-to-obtain-arcilator-runtime-h-for-c-integration/84553","labels":[{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":8212,"state":"OPEN","title":"[arcilator] Install configuration missing for arcilator-runtime.h","url":"https://github.com/llvm/circt/issues/8212"}
{"body":"The `arc.vectorize` op currently doesn't allow its body region to produce more than one result. This is a limitation in MLIR, which does not support VariadicOfVariadic results yet. VariadicOfVariadic operands _do_ work however, which is why the vectorize op can have multiple operands. The vectorize op should definitely allow for multiple results, in order to allow for larger vectors to be formed.\r\n\r\nEither add VariadicOfVariadic result support upstream in MLIR, or manually add the necessary result segment size attribute and result accessors to `VectorizeOp` here in CIRCT.","labels":[{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":7071,"state":"OPEN","title":"[Arc] Allow VectorizeOp body to have multiple results","url":"https://github.com/llvm/circt/issues/7071"}
{"body":"The `arc.vectorize` op currently has no way of capturing if some of the vector lanes all have the exact same input operand. This is important for vectorizing `arc.state` ops which have a clock, enable, and reset that all must be identical in order to be able to vectorize the op.\r\n\r\nFor example,\r\n```mlir\r\narc.vectorize (%0, %1), (%2, %3), (%clk, %clk) {\r\n^bb0(%arg0, %arg1, %arg2):\r\n  arc.state @Foo(%arg0, %arg1) clock %arg2\r\n}\r\n```\r\nwould vectorize into (psuedo-ops)\r\n```mlir\r\n%v0 = vector_create %0, %1\r\n%v1 = vector_create %2, %3\r\narc.state @FooVec(%v0, %v1) clock %clk\r\n```\r\nwhere the inputs to the arc `@Foo` can be vectorized, because we can vectorize the entire arc definition as `@FooVec`, but the clock `%clk` has to remain a scalar. This is only possible if all vector lanes used the same clock `%clk`.\r\n\r\nIt might be useful to capture the uniformity of `%clk` as part of the vectorize op itself:\r\n```mlir\r\narc.vectorize (%0, %1), (%2, %3) uniform %clk {\r\n^bb0(%arg0, %arg1, %arg2):\r\n  arc.state @Foo(%arg0, %arg1) clock %arg2\r\n}\r\n```\r\nThis makes lowering easier, since the vectorize op allows for its operands to be vectorized at a different point in time than its body. Without the uniform operands, the block arguments of the body would vectorize into something like `%arg0: vector<2 x i42>, %arg2: vector<2 x i42>, %arg3: vector<2 x !seq.clock>`. However, the `arc.state` op requires a scalar clock `%arg2`, so the lowering would not be possible. However, with the uniform operands, it would be clear that `%arg2` is a single uniform `!seq.clock`, which would allow the vectorization of the body to occur.\r\n\r\nTo implement this, @maerhart had suggested that we could have an additional group of variadic operands that contains all the uniform operands. For example:\r\n```\r\narc.vectorize (a, b), (c, d), (e, f) {\r\n^bb0(%vAB, %vCD, %e, %f):\r\n  ...\r\n}\r\n```\r\nThe last operand group `(e, f)` is understood to be the uniform operands. It can be empty if there are no uniform operands. The body block would have one block argument for the first group `(a, b)`, one block argument for the second group `(c, d)`, and then block arguments for each operand in the final group `(e, f)`.","labels":[{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":7070,"state":"OPEN","title":"[Arc] Allow uniform operands to the VectorizeOp","url":"https://github.com/llvm/circt/issues/7070"}
{"body":"While the [documentation](https://mlir.llvm.org/getting_started/Debugging/#detecting-invalid-api-usage) states that there might be false positives, I think it might be worth a look into the individual test cases and patterns.\r\nIf there are no false positives, adding `-DMLIR_ENABLE_EXPENSIVE_PATTERN_API_CHECKS=ON` to the CI could be beneficial.\r\n```\r\nFailed Tests (32):\r\n  CIRCT :: Conversion/LoopScheduleToCalyx/convert_pipeline.mlir\r\n  CIRCT :: Conversion/SCFToCalyx/cider_source_location.mlir\r\n  CIRCT :: Conversion/SCFToCalyx/convert_controlflow.mlir\r\n  CIRCT :: Conversion/SCFToCalyx/convert_func.mlir\r\n  CIRCT :: Conversion/SCFToCalyx/convert_memory.mlir\r\n  CIRCT :: Conversion/SCFToCalyx/convert_simple.mlir\r\n  CIRCT :: Conversion/SCFToCalyx/errors.mlir\r\n  CIRCT :: Dialect/Arc/arc-canonicalizer.mlir\r\n  CIRCT :: Dialect/Arc/canonicalizers.mlir\r\n  CIRCT :: Dialect/Calyx/canonicalization.mlir\r\n  CIRCT :: Dialect/Comb/canonicalization.mlir\r\n  CIRCT :: Dialect/FIRRTL/SFCTests/GrandCentralInterfaces/Wire.fir\r\n  CIRCT :: Dialect/FIRRTL/SFCTests/data-taps.fir\r\n  CIRCT :: Dialect/FIRRTL/SFCTests/invalid-interpretations.fir\r\n  CIRCT :: Dialect/FIRRTL/SFCTests/invalid-reg-pass.fir\r\n  CIRCT :: Dialect/FIRRTL/SFCTests/mem-taps.fir\r\n  CIRCT :: Dialect/FIRRTL/canonicalization.mlir\r\n  CIRCT :: Dialect/FIRRTL/ref.mlir\r\n  CIRCT :: Dialect/FIRRTL/simplify-mems.mlir\r\n  CIRCT :: Dialect/HW/canonicalization.mlir\r\n  CIRCT :: Dialect/HW/inline.mlir\r\n  CIRCT :: Dialect/Handshake/canonicalization.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/extract.mlir\r\n  CIRCT :: firtool/async-reset.fir\r\n  CIRCT :: firtool/chirrtl.fir\r\n  CIRCT :: firtool/firtool.fir\r\n  CIRCT :: firtool/import-ref.fir\r\n  CIRCT :: firtool/lower-memories.fir\r\n  CIRCT :: firtool/prefixMemory.fir\r\n  CIRCT :: firtool/spec/refs/define.fir\r\n  CIRCT :: firtool/spec/refs/nested_refproducer.fir\r\n  CIRCT :: firtool/sv-attr.fir\r\n\r\n\r\nTesting Time: 2.55s\r\n\r\nTotal Discovered Tests: 812\r\n  Unsupported      :  12 (1.48%)\r\n  Passed           : 762 (93.84%)\r\n  Expectedly Failed:   6 (0.74%)\r\n  Failed           :  32 (3.94%)\r\n```\r\n\r\nThe observed errors are:\r\n- `LLVM ERROR: operation finger print changed`\r\n- `LLVM ERROR: pattern returned success but IR did not change`\r\n- `LLVM ERROR: IR failed to verify after pattern application`","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIy","name":"help wanted","description":"Extra attention is needed","color":"008672"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"},{"id":"MDU6TGFiZWwyMTUyNzUzODY1","name":"Handshake","description":"","color":"d0a6fc"},{"id":"MDU6TGFiZWwyMTUyNzU0NzU0","name":"HW","description":"Involving the `hw` dialect","color":"081f7a"},{"id":"MDU6TGFiZWwyMTY1NDc5NTk1","name":"LLHD","description":"","color":"e07b00"},{"id":"MDU6TGFiZWwzMDk2MTk4MzEw","name":"Calyx","description":"The Calyx dialect","color":"94BD78"},{"id":"MDU6TGFiZWwzMjYzNzQ4NjY5","name":"Comb","description":"Involving the `comb` dialect","color":"d4c5f9"},{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"},{"id":"LA_kwDODpuCgs8AAAABSm-vrw","name":"LoopSchedule","description":"","color":"e99695"}],"number":7047,"state":"OPEN","title":"`-DMLIR_ENABLE_EXPENSIVE_PATTERN_API_CHECKS=ON` might have found some invalid API usages","url":"https://github.com/llvm/circt/issues/7047"}
{"body":"Add support for `verif.assert` and `sv.assert.concurrent` operations to the Arc dialect and passes. When lowering towards LLVM, the asserts should lower to an `scf.if` operation that checks whether their condition holds, and if it does not, calls a callback function (or aborts with a message for starters).\r\n\r\nThis is likely to uncover a lot of details about how clocked and unclocked asserts need to be handled, and where they have to be scheduled and checked in the simulation model.","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIx","name":"good first issue","description":"Good for newcomers","color":"7057ff"},{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":6810,"state":"OPEN","title":"[Arc] Add basic assertion support","url":"https://github.com/llvm/circt/issues/6810"}
{"body":"When i run `arcilator` with `$ ./arcilator a.mlir --state-file=a.json` i get the following error:\r\n```\r\na.mlir:9:23: error: 'arc.tap' op operand #0 must be signless integer, but got '!hw.struct<valid: i1, bits: i1>'\r\n    %_registers_0_T = hw.wire %2 sym @sym_0  : !hw.struct<valid: i1, bits: i1>\r\n                      ^\r\na.mlir:9:23: note: see current operation: \"arc.tap\"(%5) {name = \"_registers_0_T\"} : (!hw.struct<valid: i1, bits: i1>) -> ()\r\n```\r\n\r\n`a.mlir`:\r\n```\r\nmodule {\r\n  hw.module @Barrier(in %clock : !seq.clock, in %reset : i1, in %io_input : !hw.array<1xstruct<valid: i1, bits: i1>>, out io_output : !hw.array<1xstruct<valid: i1, bits: i1>>) {\r\n    %false = hw.constant false\r\n    %0 = hw.array_get %io_input[%false] : !hw.array<1xstruct<valid: i1, bits: i1>>, i1\r\n    %valid = hw.struct_extract %0[\"valid\"] : !hw.struct<valid: i1, bits: i1>\r\n    %registers = seq.firreg %3 clock %clock sym @sym {firrtl.random_init_start = 0 : ui64} : !hw.array<1xstruct<valid: i1, bits: i1>>\r\n    %1 = hw.array_get %registers[%false] : !hw.array<1xstruct<valid: i1, bits: i1>>, i1\r\n    %2 = comb.mux bin %valid, %0, %1 : !hw.struct<valid: i1, bits: i1>\r\n    %_registers_0_T = hw.wire %2 sym @sym_0  : !hw.struct<valid: i1, bits: i1>\r\n    %3 = hw.array_create %_registers_0_T : !hw.struct<valid: i1, bits: i1>\r\n    hw.output %registers : !hw.array<1xstruct<valid: i1, bits: i1>>\r\n  }\r\n}\r\n```\r\n\r\n","labels":[{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":6373,"state":"OPEN","title":"[Arc] Support hw.wires of aggregate types","url":"https://github.com/llvm/circt/issues/6373"}
{"body":"Input:\r\n```\r\ncircuit ResetEnum:\r\n  module ResetEnum:\r\n    input in : {| Some: UInt<1> |}\r\n    output out: {| Some: Reset |}\r\n    out <= in\r\n```\r\n\r\nCrashes during parsing, related: #5322 .","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"},{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":5886,"state":"OPEN","title":"[FIRRTL] Enum with uninferred reset","url":"https://github.com/llvm/circt/issues/5886"}
{"body":"In the following, somewhat artificial, example, the `arc.state` with `clock %clk1` is pulled into the clock tree of `%clk0`. As a result, it is also not lowered to a latency 0 arc with associated read and write operations. Even if that happened, it would be triggered by the wrong clock. In practice, this cannot occur right now, but it would still be great if the pass complains about such inputs.\r\n\r\n```mlir\r\nhw.module @MaterializeOpsWithRegions(%clk0: i1, %clk1: i1) -> (z: i42) {\r\n  %true = hw.constant true\r\n  %0 = scf.if %true -> (i42) {\r\n    %c19_i42 = hw.constant 19 : i42\r\n    %1 = arc.state @DummyArc(%c19_i42) clock %clk1 lat 1 : (i42) -> i42\r\n    scf.yield %1 : i42\r\n  } else {\r\n    %c42_i42 = hw.constant 42 : i42\r\n    scf.yield %c42_i42 : i42\r\n  }\r\n  %1 = arc.state @DummyArc(%0) clock %clk0 lat 1 : (i42) -> i42\r\n  hw.output %1 : i42\r\n}\r\n```","labels":[{"id":"LA_kwDODpuCgs8AAAABNapjiA","name":"Arc","description":"Involving the `arc` dialect","color":"bfd4f2"}],"number":4916,"state":"OPEN","title":"[Arc] LowerState: nested arc.state get pulled in wrong clock tree","url":"https://github.com/llvm/circt/issues/4916"}
{"body":"Consider the following:\n\n``` mlir\nfirrtl.circuit \"Foo\" {\n  firrtl.class @Bar() {\n  }\n  firrtl.module @Foo() {\n    %CabooseTileParams = firrtl.object @Bar()\n  }\n}\n```\n\nThis crashes if run with:\n\n``` console\n# circt-reduce -skip-initial -test='exit 0' module-name-sanitizer.0.mlir -include module-name-sanitizer -o /dev/null\nReading input\nTesting input with `exit 0`\nInitial module has size 153\nTrying reduction `module-name-sanitizer`\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: circt-reduce -skip-initial \"-test=exit 0\" module-name-sanitizer.0.mlir -include module-name-sanitizer -o /dev/null\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\n0  circt-reduce             0x000000010421fc34 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 56\n1  circt-reduce             0x000000010421db1c llvm::sys::RunSignalHandlers() + 172\n2  circt-reduce             0x00000001042206dc SignalHandler(int, __siginfo*, void*) + 300\n3  libsystem_platform.dylib 0x000000018fd516a4 _sigtramp + 56\n4  circt-reduce             0x000000010460aa4c circt::firrtl::InstanceOp::setModuleName(llvm::StringRef) + 40\n5  circt-reduce             0x000000010515f050 (anonymous namespace)::ModuleNameSanitizer::rewrite(circt::firrtl::CircuitOp) + 1320\n6  circt-reduce             0x00000001041ab0dc execute(mlir::MLIRContext&) + 3988\n7  circt-reduce             0x00000001041a9ebc main + 300\n8  dyld                     0x000000018f976b98 start + 6076\nzsh: segmentation fault  circt-reduce -skip-initial -test='exit 0' module-name-sanitizer.0.mlir   -o \n```","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"},{"id":"LA_kwDODpuCgs8AAAABAHHhZQ","name":"Reducer","description":"Related to `circt-reduce`","color":"C5DEF5"}],"number":9565,"state":"OPEN","title":"[FIRRTL][circt-reduce] module-name-sanitizer can't handle FIRRTL classes","url":"https://github.com/llvm/circt/issues/9565"}
{"body":"Consider the following:\n\n``` mlir\nfirrtl.circuit \"Foo\" {\n  firrtl.module private @Bar(\n    out %ref: !firrtl.probe<clock>\n  ) {\n  }\n  firrtl.module @Foo() {\n    %Bar_ref = firrtl.instance Bar @Bar(\n      out ref: !firrtl.probe<clock>\n    )\n  }\n}\n```\n\nThis will crash if run with:\n\n``` console\n# circt-reduce -skip-initial -test='exit 0' firrtl-remove-unused-ports.1.mlir -include firrtl-remove-unused-ports -o /dev/null\nReading input\nTesting input with `exit 0`\nInitial module has size 221\nTrying reduction `firrtl-remove-unused-ports`\nAssertion failed: (isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"), function cast, file Casting.h, line 560.\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: circt-reduce -skip-initial \"-test=exit 0\" firrtl-remove-unused-ports.1.mlir -include firrtl-remove-unused-ports -o /dev/null\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\n0  circt-reduce             0x0000000102367c34 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 56\n1  circt-reduce             0x0000000102365b1c llvm::sys::RunSignalHandlers() + 172\n2  circt-reduce             0x00000001023686dc SignalHandler(int, __siginfo*, void*) + 300\n3  libsystem_platform.dylib 0x000000018fd516a4 _sigtramp + 56\n4  libsystem_pthread.dylib  0x000000018fd17848 pthread_kill + 296\n5  libsystem_c.dylib        0x000000018fc209e4 abort + 124\n6  libsystem_c.dylib        0x000000018fc1fc18 err + 0\n7  circt-reduce             0x00000001034bbc2c llvm::StdThreadPool::wait() (.cold.1) + 0\n8  circt-reduce             0x000000010269e0d8 circt::firrtl::patterns::AddOfPad::~AddOfPad() + 0\n9  circt-reduce             0x000000010282e020 (anonymous namespace)::RemoveUnusedPortsPass::runOnOperation() + 3056\n10 circt-reduce             0x0000000103475108 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 1340\n11 circt-reduce             0x0000000103475a04 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 620\n12 circt-reduce             0x0000000103477b68 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) + 5408\n13 circt-reduce             0x00000001034754f0 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 2340\n14 circt-reduce             0x0000000103475a04 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 620\n15 circt-reduce             0x000000010347b3ec mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) + 464\n16 circt-reduce             0x000000010347abf0 mlir::PassManager::run(mlir::Operation*) + 5292\n17 circt-reduce             0x00000001022f30dc execute(mlir::MLIRContext&) + 3988\n18 circt-reduce             0x00000001022f1ebc main + 300\n19 dyld                     0x000000018f976b98 start + 6076\nzsh: abort      circt-reduce -skip-initial -test='exit 0' firrtl-remove-unused-ports.1.mlir \n```","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"},{"id":"LA_kwDODpuCgs8AAAABAHHhZQ","name":"Reducer","description":"Related to `circt-reduce`","color":"C5DEF5"}],"number":9564,"state":"OPEN","title":"[FIRRTL][circt-reduce] firrtl-remove-unused-ports can't handle probes","url":"https://github.com/llvm/circt/issues/9564"}
{"body":"Consider the following:\n\n``` mlir\nfirrtl.circuit \"Foo\" {\n  firrtl.extmodule @Bar(out a: !firrtl.string)\n  firrtl.module @Baz() {\n    %a = firrtl.instance Bar @Bar(out a: !firrtl.string)\n    %wire = firrtl.wire : !firrtl.string\n    firrtl.propassign %wire, %a : !firrtl.string\n  }\n  firrtl.extmodule @Foo()\n}\n```\n\nThis will crash with the following command:\n\n``` console\n# circt-reduce -skip-initial -test='exit 0' extmodule-instance-remover.mlir -include extmodule-instance-remover -o /dev/null\nReading input\nTesting input with `exit 0`\nInitial module has size 311\nTrying reduction `extmodule-instance-remover`\nAssertion failed: (isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"), function cast, file Casting.h, line 560.\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: circt-reduce -skip-initial \"-test=exit 0\" extmodule-instance-remover.mlir -include extmodule-instance-remover -o /dev/null\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\n0  circt-reduce             0x0000000104563c34 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 56\n1  circt-reduce             0x0000000104561b1c llvm::sys::RunSignalHandlers() + 172\n2  circt-reduce             0x00000001045646dc SignalHandler(int, __siginfo*, void*) + 300\n3  libsystem_platform.dylib 0x000000018fd516a4 _sigtramp + 56\n4  libsystem_pthread.dylib  0x000000018fd17848 pthread_kill + 296\n5  libsystem_c.dylib        0x000000018fc209e4 abort + 124\n6  libsystem_c.dylib        0x000000018fc1fc18 err + 0\n7  circt-reduce             0x00000001056b7c2c llvm::StdThreadPool::wait() (.cold.1) + 0\n8  circt-reduce             0x000000010489a0d8 circt::firrtl::patterns::AddOfPad::~AddOfPad() + 0\n9  circt-reduce             0x00000001054a0f38 (anonymous namespace)::ExtmoduleInstanceRemover::rewrite(circt::firrtl::InstanceOp) + 680\n10 circt-reduce             0x00000001044ef0dc execute(mlir::MLIRContext&) + 3988\n11 circt-reduce             0x00000001044edebc main + 300\n12 dyld                     0x000000018f976b98 start + 6076\nzsh: abort      circt-reduce -skip-initial -test='exit 0' extmodule-instance-remover.mlir   -\n```","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"},{"id":"LA_kwDODpuCgs8AAAABAHHhZQ","name":"Reducer","description":"Related to `circt-reduce`","color":"C5DEF5"}],"number":9563,"state":"OPEN","title":"[FIRRTL][circt-reduce] extmodule-instance-remover crash w/ properties","url":"https://github.com/llvm/circt/issues/9563"}
{"body":"Consider the following:\n\n``` mlir\nfirrtl.circuit \"Foo\" {\n  firrtl.layer @A bind {\n  }\n  firrtl.module private @Bar() {\n    %c0_ui1 = firrtl.constant 0 : !firrtl.uint<1>\n    %wire = firrtl.wire : !firrtl.probe<uint<1>, @A>\n    firrtl.layerblock @A {\n      %wire_0 = firrtl.wire {name = \"wire\"} : !firrtl.uint<1>\n      firrtl.matchingconnect %wire_0, %c0_ui1 : !firrtl.uint<1>\n      %0 = firrtl.ref.send %wire_0 : !firrtl.uint<1>\n      %1 = firrtl.ref.cast %0 : (!firrtl.probe<uint<1>>) -> !firrtl.probe<uint<1>, @A>\n      firrtl.ref.define %wire, %1 : !firrtl.probe<uint<1>, @A>\n    }\n  }\n  firrtl.extmodule @Foo()\n}\n```\n\nRunning the connect forwarder on this will crash:\n\n``` console\n# circt-reduce -skip-initial -test='exit 0' connect-forwarder.0.mlir -include connect-forwarder -o /dev/null \nReading input\nTesting input with `exit 0`\nInitial module has size 625\nTrying reduction `connect-forwarder`\nAssertion failed: (other && other->block == block && \"Expected other operation to have the same parent block.\"), function isBeforeInBlock, file Operation.cpp, line 386.\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: circt-reduce -skip-initial \"-test=exit 0\" connect-forwarder.0.mlir -include connect-forwarder -o /dev/null\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\n0  circt-reduce             0x0000000102f9bc34 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 56\n1  circt-reduce             0x0000000102f99b1c llvm::sys::RunSignalHandlers() + 172\n2  circt-reduce             0x0000000102f9c6dc SignalHandler(int, __siginfo*, void*) + 300\n3  libsystem_platform.dylib 0x000000018fd516a4 _sigtramp + 56\n4  libsystem_pthread.dylib  0x000000018fd17848 pthread_kill + 296\n5  libsystem_c.dylib        0x000000018fc209e4 abort + 124\n6  libsystem_c.dylib        0x000000018fc1fc18 err + 0\n7  circt-reduce             0x00000001041794dc mlir::Operation::isBeforeInBlock(mlir::Operation*) (.cold.2) + 0\n8  circt-reduce             0x0000000103f65048 mlir::Operation::isBeforeInBlock(mlir::Operation*) + 112\n9  circt-reduce             0x0000000103ed464c (anonymous namespace)::ConnectForwarder::match(mlir::Operation*) + 252\n10 circt-reduce             0x0000000103ebdd44 circt::Reduction::matches(mlir::Operation*, llvm::function_ref<void (unsigned long long, unsigned long long)>) + 36\n11 circt-reduce             0x0000000102f2c580 void llvm::function_ref<void (mlir::Operation*)>::callback_fn<execute(mlir::MLIRContext&)::$_2>(long, mlir::Operation*) + 64\n12 circt-reduce             0x0000000102f2c4dc void mlir::detail::walk<mlir::ForwardIterator>(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) + 180\n13 circt-reduce             0x0000000102f2c4dc void mlir::detail::walk<mlir::ForwardIterator>(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) + 180\n14 circt-reduce             0x0000000102f2c4dc void mlir::detail::walk<mlir::ForwardIterator>(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) + 180\n15 circt-reduce             0x0000000102f2c4dc void mlir::detail::walk<mlir::ForwardIterator>(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) + 180\n16 circt-reduce             0x0000000102f26d48 execute(mlir::MLIRContext&) + 3072\n17 circt-reduce             0x0000000102f25ebc main + 300\n18 dyld                     0x000000018f976b98 start + 6076\nzsh: abort      circt-reduce -skip-initial -test='exit 0' connect-forwarder.0.mlir -include  \n```","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"},{"id":"LA_kwDODpuCgs8AAAABAHHhZQ","name":"Reducer","description":"Related to `circt-reduce`","color":"C5DEF5"}],"number":9562,"state":"OPEN","title":"[FIRRTL][circt-reduce] Connect Forwarder Crashes w/ Layers","url":"https://github.com/llvm/circt/issues/9562"}
{"body":"FIRRTL `instance-stubber` reduction crashes if it is given refs. Consider:\n\n``` mlir\nfirrtl.circuit \"Foo\" {\n  firrtl.module private @Bar(\n    out %ref: !firrtl.rwprobe<uint<32>>\n  ) {\n  }\n  firrtl.module private @Baz(\n    in %v_3: !firrtl.anyref\n  ) {\n    %Bar_ref = firrtl.instance Bar @Bar(\n      out ref: !firrtl.rwprobe<uint<32>>\n    )\n  }\n  firrtl.extmodule @Foo()\n}\n```\n\nRunning this will crash the instance-stubber:\n\n``` console\n# circt-reduce -skip-initial -test='exit 0' instance-stubber.0.mlir -include instance-stubber -o /dev/null 2>&1\nReading input\nTesting input with `exit 0`\nInitial module has size 286\nTrying reduction `instance-stubber`\nAssertion failed: (isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"), function cast, file Casting.h, line 560.\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: circt-reduce -skip-initial \"-test=exit 0\" instance-stubber.0.mlir -include instance-stubber -o /dev/null\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\n0  circt-reduce             0x000000010429fc34 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 56\n1  circt-reduce             0x000000010429db1c llvm::sys::RunSignalHandlers() + 172\n2  circt-reduce             0x00000001042a06dc SignalHandler(int, __siginfo*, void*) + 300\n3  libsystem_platform.dylib 0x000000018fd516a4 _sigtramp + 56\n4  libsystem_pthread.dylib  0x000000018fd17848 pthread_kill + 296\n5  libsystem_c.dylib        0x000000018fc209e4 abort + 124\n6  libsystem_c.dylib        0x000000018fc1fc18 err + 0\n7  circt-reduce             0x00000001053f4068 llvm::StdThreadPool::wait() (.cold.1) + 0\n8  circt-reduce             0x00000001045d60d8 circt::firrtl::patterns::AddOfPad::~AddOfPad() + 0\n9  circt-reduce             0x00000001051d44ac (anonymous namespace)::invalidateOutputs(mlir::ImplicitLocOpBuilder&, mlir::Value, llvm::SmallDenseMap<mlir::Type, mlir::Value, 8u, llvm::DenseMapInfo<mlir::Type, void>, llvm::detail::DenseMapPair<mlir::Type, mlir::Value>>&, bool) + 640\n10 circt-reduce             0x00000001051d3ab8 (anonymous namespace)::InstanceStubber::rewrite(circt::firrtl::InstanceOp) + 808\n11 circt-reduce             0x000000010422b0dc execute(mlir::MLIRContext&) + 3988\n12 circt-reduce             0x0000000104229ebc main + 300\n13 dyld                     0x000000018f976b98 start + 6076\nzsh: abort      circt-reduce -skip-initial -test='exit 0' instance-stubber.0.mlir -include  -\n```","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"LA_kwDODpuCgs8AAAABAHHhZQ","name":"Reducer","description":"Related to `circt-reduce`","color":"C5DEF5"}],"number":9561,"state":"OPEN","title":"[FIRRTL][circt-reduce] Instance Stubber Crash w/ Refs","url":"https://github.com/llvm/circt/issues/9561"}
{"body":"The following will loop indefinitely if canonicalized. Run with `circt-opt -canonicalize Foo.mlir`:\n\n``` mlir\nfirrtl.circuit \"Foo\" {\n  firrtl.module private @Bar(\n    in %clk: !firrtl.clock,\n    in %rst: !firrtl.asyncreset\n  ) {\n    %c0_ui1 = firrtl.constant 0 : !firrtl.const.uint<1>\n    %c0_ui4 = firrtl.constant 0 : !firrtl.const.uint<4>\n    %reg = firrtl.regreset %clk, %rst, %c0_ui4 : !firrtl.clock, !firrtl.asyncreset, !firrtl.const.uint<4>, !firrtl.uint<4>\n    %0 = firrtl.bits %reg 0 to 0 : (!firrtl.uint<4>) -> !firrtl.uint<1>\n    %1 = firrtl.eq %c0_ui1, %c0_ui1 : (!firrtl.const.uint<1>, !firrtl.const.uint<1>) -> !firrtl.const.uint<1>\n    %2 = firrtl.and %1, %0 : (!firrtl.const.uint<1>, !firrtl.uint<1>) -> !firrtl.uint<1>\n    firrtl.when %2 : !firrtl.uint<1> {\n    }\n  }\n  firrtl.extmodule @Foo()\n}\n```\n\nFor background, I've been seeing issues with `circt-reduce` for some time where canonicalization will get stuck and I need to exclude it to make forward progress. Eventually, I will reenable it once the reduction has proceeded far enough.","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzE3","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":9560,"state":"OPEN","title":"[FIRRTL] Canonicalize infinite loop","url":"https://github.com/llvm/circt/issues/9560"}
{"body":"Making this issue for tracking as I gradually replace all the uses of to_builtin_bool with to_builtin_int (not totally trivial since we now have to explicitly cast to int type), as I'll split it across PRs to keep the diffs small and make sure I'm not missing anything\n\nPlaces to change:\n- [x] Assertion builtin handling\n- [ ] AssertionExpr.cpp convertToI1 function\n- [ ] Statements.cpp conditions\n- [ ] MooreToCore","labels":[],"number":9542,"state":"OPEN","title":"[Moore] to_builtin_bool should be replaced with to_builtin_int","url":"https://github.com/llvm/circt/issues/9542"}
{"body":"Running\n```\nhlstool --dynamic-hw --buffering-strategy=all --verilog --lowering-options=disallowLocalVariables --verbose-pass-executions\n```\ncrashes on the following handshake function\n```\nhandshake.func @top(%v0: i32, %v1: i32, %mem.src.load0.data: i32, %mem.src.load0.done: none, %mem.dst.store0.done: none) -> (none, index, i32, index) attributes {argNames = [\"in0\", \"in1\", \"mem.src.load0.data\", \"mem.src.load0.done\", \"mem.dst.store0.done\"], resNames = [\"out0\", \"mem.src.load0.addr\", \"mem.dst.store0.data\", \"mem.dst.store0.addr\"]} {\n  %v4 = handshake.constant %v3 {value = 1 : i32} : i32\n  %v6 = handshake.constant %v5 {value = 1 : i32} : i32\n  %v8 = handshake.constant %v7 {value = 511 : i32} : i32\n  %v10 = handshake.constant %v9 {value = 256 : i32} : i32\n  %v12, %v13 = handshake.fork [2] %v11 : i32\n  %v15, %v16 = handshake.fork [2] %v14 : i32\n  %v18, %v19, %v20, %v21, %v22, %v23, %v24, %v25, %v26, %v27, %v28, %v29, %v30, %v31 = handshake.fork [14] %v17 : i1\n  %v32, %_0 = handshake.cond_br %v21, %v16 : i32\n  %v33, %v34 = handshake.fork [2] %v32 : i32\n  %v36, %v37 = handshake.fork [2] %v35 : i32\n  %v38, %_1 = handshake.cond_br %v20, %v37 : i32\n  %v39, %v40 = handshake.fork [2] %v38 : i32\n  %v42, %v43 = handshake.fork [2] %v41 : i32\n  %v45, %v46 = handshake.fork [2] %v44 : i32\n  %v48, %v49, %v50, %v51, %v52, %v53, %v54, %v55, %v56, %v57, %v58, %v59 = handshake.fork [12] %v47 : i1\n  %v60, %_2 = handshake.cond_br %v49, %v46 : i32\n  %v61, %v62 = handshake.fork [2] %v60 : i32\n  %v64, %v65, %v66, %v67, %v68, %v69, %v70, %v71, %v72, %v73 = handshake.fork [10] %v63 : i1\n  %v76 = handshake.join %v74, %v75 : none, none\n  %v77, %_3 = handshake.cond_br %v71, %v76 : none\n  %v79, %v75, %v80 = handshake.fork [3] %v78 : none\n  %_4, %v81 = handshake.cond_br %v73, %v80 : none\n  %v83, %v84, %v85, %v74, %v86 = handshake.fork [5] %v82 : none\n  %v88, %v89, %v90 = handshake.fork [3] %v87 : none\n  %_5, %v87 = handshake.cond_br %v72, %v86 : none\n  %v92 = handshake.join %v85, %v91 : none, none\n  %v93, %_6 = handshake.cond_br %v69, %v92 : none\n  %v95, %v91, %v96 = handshake.fork [3] %v94 : none\n  %_7, %v97 = handshake.cond_br %v70, %v96 : none\n  %v100 = arith.select %v67, %v98, %v99 : i32\n  %v105 = handshake.join %v101, %v102, %v103, %v104 : none, none, none, none\n  %v2 = handshake.br %v105 : none\n  %v107, %v108 = handshake.fork [2] %v106 : i32\n  %_8, %v110 = handshake.cond_br %v29, %v109 : none\n  %v112, %v113, %v99 = handshake.fork [3] %v111 : i32\n  %v114, %v115 = handshake.fork [2] %v8 : i32\n  %v116 = handshake.constant %v90 {value = 0 : i32} : i32\n  %v118 = handshake.constant %v117 {value = 0 : i32} : i32\n  %v120 = handshake.constant %v119 {value = 0 : i32} : i32\n  %v122, %v123 = handshake.fork [2] %v121 : i32\n  %v125 = handshake.constant %v124 {value = 0 : i32} : i32\n  %v127, %v128 = handshake.fork [2] %v126 : none\n  %v129, %_9 = handshake.cond_br %v58, %v127 : none\n  %_10, %v101 = handshake.cond_br %v59, %v128 : none\n  %v131, %v132 = handshake.fork [2] %v130 : none\n  %v133, %_11 = handshake.cond_br %v56, %v131 : none\n  %_12, %v103 = handshake.cond_br %v57, %v132 : none\n  %v135, %v136 = handshake.fork [2] %v134 : none\n  %v78, %_13 = handshake.cond_br %v30, %v135 : none\n  %_14, %v137 = handshake.cond_br %v31, %v136 : none\n  %v139, %v109 = handshake.fork [2] %v138 : none\n  %v140, %_15 = handshake.cond_br %v28, %v139 : none\n  %v119, %v117, %v141, %v3, %v142, %v143 = handshake.fork [6] %v129 : none\n  %_16 = arith.index_cast %v13 : i32 to index\n  %mem.dst.store0.addr = handshake.buffer [1] seq %_18 : index\n  %mem.dst.store0.data = handshake.buffer [1] seq %_19 : i32\n  %_20 = handshake.buffer [1] seq %mem.dst.store0.done : none\n  %_21, %_22 = handshake.fork [2] %_16 : index\n  %_23, %_24 = handshake.fork [2] %v144 : i32\n  %_17 = handshake.join %_21, %_23 : index, i32\n  %_19, %_18 = handshake.store [%_22] %_24, %_17 : index, i32\n  %v145 = handshake.br %mem.dst.store0.done : none\n  %v82 = handshake.join %v146, %v147 : none, i32\n  %v148, %v9, %v7, %v5, %v146 = handshake.fork [5] %v140 : none\n  %v150 = join %v149 : i32\n  %v124, %v152, %v102 = handshake.fork [3] %v151 : none\n  %v151 = join %v153 : i32\n  %v154, %v104 = handshake.fork [2] %v150 : none\n  %_25 = handshake.buffer [1] seq %v53 {initValues = [0]} : i1\n  %v155 = handshake.mux %_25 [%v1, %v123] : i1, i32\n  %v156, %v153, %v149 = handshake.fork [3] %v0 : i32\n  %v121, %_26 = handshake.cond_br %v48, %v155 : i32\n  %v157, %v158 = handshake.fork [2] %v133 : none\n  %v160, %_27 = handshake.cond_br %v19, %v159 : i32\n  %v106, %_28 = handshake.cond_br %v18, %v161 : i32\n  %v163, %v164 = handshake.fork [2] %v162 : i1\n  %v166 = handshake.mux %v66 [%v165, %v77] : i1, none\n  %v94 = handshake.join %v79, %v164 : none, i1\n  %v165 = handshake.join %v88, %v81 : none, none\n  %v167, %_29 = handshake.cond_br %v64, %v115 : i32\n  %v144, %_30, %_31 = handshake.sync %v168, %v163, %v83 : i32, i1, none\n  %v162 = handshake.constant %v166 {value = 0 : i1} : i1\n  %v170, %v171 = handshake.fork [2] %v169 : i1\n  %v98 = arith.subi %v113, %v114 : i32\n  %v173 = handshake.mux %v68 [%v172, %v93] : i1, none\n  %v174 = handshake.join %v84, %v171, %v145 : none, i1, none\n  %v172 = handshake.join %v89, %v97 : none, none\n  %v175, %_32 = handshake.sync %v100, %v170 : i32, i1\n  %v169 = handshake.constant %v173 {value = 0 : i1} : i1\n  %v177 = handshake.join %v95, %v176 : none, none\n  %v178 = handshake.join %v158, %v143, %v110, %v137 : none, none, none, none\n  %v179, %v176 = handshake.fork [2] %v174 : none\n  %v180 = arith.addi %v39, %v6 : i32\n  %v181, %_33 = handshake.cond_br %v50, %v43 : i32\n  %v182 = arith.addi %v61, %v4 : i32\n  %v168 = handshake.mux %v65 [%v116, %v167] : i1, i32\n  %_34 = handshake.buffer [1] seq %v22 {initValues = [0]} : i1\n  %v35 = handshake.mux %_34 [%v118, %v180] : i1, i32\n  %_35 = handshake.buffer [1] seq %v23 {initValues = [0]} : i1\n  %v161 = handshake.mux %_35 [%v62, %v108] : i1, i32\n  %_36 = handshake.buffer [1] seq %v24 {initValues = [0]} : i1\n  %v159 = handshake.mux %_36 [%v120, %v175] : i1, i32\n  %_37 = handshake.buffer [1] seq %v25 {initValues = [0]} : i1\n  %v14 = handshake.mux %_37 [%v122, %v34] : i1, i32\n  %_38 = handshake.buffer [1] seq %v26 {initValues = [0]} : i1\n  %v138 = handshake.mux %_38 [%v141, %v179] : i1, none\n  %_39 = handshake.buffer [1] seq %v27 {initValues = [0]} : i1\n  %v134 = handshake.mux %_39 [%v157, %v177] : i1, none\n  %_40 = handshake.buffer [1] seq %v51 {initValues = [0]} : i1\n  %v44 = handshake.mux %_40 [%v125, %v182] : i1, i32\n  %_41 = handshake.buffer [1] seq %v52 {initValues = [0]} : i1\n  %v41 = handshake.mux %_41 [%v156, %v181] : i1, i32\n  %_42 = handshake.buffer [1] seq %v54 {initValues = [0]} : i1\n  %v126 = handshake.mux %_42 [%v152, %v142] : i1, none\n  %_43 = handshake.buffer [1] seq %v55 {initValues = [0]} : i1\n  %v130 = handshake.mux %_43 [%v154, %v178] : i1, none\n  %v47 = arith.cmpi ult, %v45, %v42 : i32\n  %v17 = arith.cmpi ult, %v36, %v15 : i32\n  %v183 = arith.muli %v107, %v33 : i32\n  %v11 = arith.addi %v183, %v40 : i32\n  %v184, %_44 = handshake.sync %v12, %v148 : i32, none\n  %v186, %v147 = handshake.fork [2] %v185 : i32\n  %_45 = arith.index_cast %v184 : i32 to index\n  %mem.src.load0.addr = handshake.buffer [1] seq %_47 : index\n  %_48 = handshake.buffer [1] seq %mem.src.load0.data : i32\n  %_49, %_50 = handshake.fork [2] %_45 : index\n  %_46 = handshake.join %_49 : index\n  %v185, %_47 = handshake.load [%_50] %_48, %_46 : index, i32\n  %v111 = arith.addi %v186, %v160 : i32\n  %v63 = arith.cmpi slt, %v10, %v112 : i32\n  return %v2, %mem.src.load0.addr, %mem.dst.store0.data, %mem.dst.store0.addr : none, index, i32, index\n}\n```\n\nAssertion failure and stack trace:\n```\nAssertion failed: (op->getNumResults() == newValues.size() && \"incorrect # of replacement values\"), function replaceOp, file DialectConversion.cpp, line 2159.\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.      Program arguments: build/bin/hlstool tests/dither/test.handshake.mlir --dynamic-hw --buffering-strategy=cycles --verilog --lowering-options=disallowLocalVariables --verbose-pass-executions\n #0 0x0000000102a3e810 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100072810)\n #1 0x0000000102a3c904 llvm::sys::RunSignalHandlers() (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100070904)\n #2 0x0000000102a3f2a0 SignalHandler(int, __siginfo*, void*) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x1000732a0)\n #3 0x0000000183a996a4 (/usr/lib/system/libsystem_platform.dylib+0x1804ad6a4)\n #4 0x0000000183a5f848 (/usr/lib/system/libsystem_pthread.dylib+0x180473848)\n #5 0x00000001839689e4 (/usr/lib/system/libsystem_c.dylib+0x18037c9e4)\n #6 0x0000000183967c18 (/usr/lib/system/libsystem_c.dylib+0x18037bc18)\n #7 0x0000000103564eec mlir::ConversionPatternRewriter::applySignatureConversion(mlir::Block*, mlir::TypeConverter::SignatureConversion&, mlir::TypeConverter const*) (.cold.1) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100b98eec)\n #8 0x00000001035508d8 mlir::ConversionPatternRewriter::replaceOp(mlir::Operation*, mlir::ValueRange) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100b848d8)\n #9 0x00000001035506c4 mlir::ConversionPatternRewriter::replaceOp(mlir::Operation*, mlir::Operation*) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100b846c4)\n#10 0x0000000102c24d78 (anonymous namespace)::HandshakeConversionPattern<circt::handshake::SyncOp>::matchAndRewrite(circt::handshake::SyncOp, circt::handshake::SyncOpAdaptor, mlir::ConversionPatternRewriter&) const (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100258d78)\n#11 0x0000000102c0f8bc llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::handshake::SyncOp>, circt::handshake::SyncOp>(mlir::OpConversionPattern<circt::handshake::SyncOp> const&, circt::handshake::SyncOp, circt::handshake::SyncOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange> >, mlir::ConversionPatternRewriter&) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x1002438bc)\n#12 0x0000000102c0f7d8 mlir::OpConversionPattern<circt::handshake::SyncOp>::matchAndRewrite(circt::handshake::SyncOp, circt::handshake::SyncOpGenericAdaptor<llvm::ArrayRef<mlir::ValueRange> >, mlir::ConversionPatternRewriter&) const (/Users/zhengyao/work/stuff/build/bin/hlstool+0x1002437d8)\n#13 0x0000000102c0f43c mlir::OpConversionPattern<circt::handshake::SyncOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/Users/zhengyao/work/stuff/build/bin/hlstool+0x10024343c)\n#14 0x0000000103551d38 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100b85d38)\n#15 0x0000000103589218 void llvm::function_ref<void ()>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_0>(long) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100bbd218)\n#16 0x00000001035863bc mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100bba3bc)\n#17 0x000000010355282c (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100b8682c)\n#18 0x0000000103551e40 mlir::OperationConverter::convert(mlir::Operation*, bool) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100b85e40)\n#19 0x0000000103552bd8 mlir::OperationConverter::applyConversion(llvm::ArrayRef<mlir::Operation*>) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100b86bd8)\n#20 0x000000010355d050 void llvm::function_ref<void ()>::callback_fn<applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode)::$_0>(long) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100b91050)\n#21 0x0000000103555ce8 applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100b89ce8)\n#22 0x0000000103555da0 mlir::applyPartialConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100b89da0)\n#23 0x0000000102c18f50 (anonymous namespace)::HandshakeToHWPass::runOnOperation() (/Users/zhengyao/work/stuff/build/bin/hlstool+0x10024cf50)\n#24 0x00000001035e2448 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100c16448)\n#25 0x00000001035e2f5c mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100c16f5c)\n#26 0x00000001035e878c mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100c1c78c)\n#27 0x00000001035e7f24 mlir::PassManager::run(mlir::Operation*) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100c1bf24)\n#28 0x00000001029d1854 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::__1::optional<std::__1::unique_ptr<llvm::ToolOutputFile, std::__1::default_delete<llvm::ToolOutputFile> > >&) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100005854)\n#29 0x00000001029d0848 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::__1::unique_ptr<llvm::MemoryBuffer, std::__1::default_delete<llvm::MemoryBuffer> >, std::__1::optional<std::__1::unique_ptr<llvm::ToolOutputFile, std::__1::default_delete<llvm::ToolOutputFile> > >&) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100004848)\n#30 0x00000001029cea0c executeHlstool(mlir::MLIRContext&) (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100002a0c)\n#31 0x00000001029ce128 main (/Users/zhengyao/work/stuff/build/bin/hlstool+0x100002128)\n#32 0x00000001836beb98\n```\n\nI'm new to CIRCT and the handshake dialect, so please let me know if there's a good way to minimize the code above.","labels":[],"number":9538,"state":"OPEN","title":"`hlstool` crashes on handshake input","url":"https://github.com/llvm/circt/issues/9538"}
{"body":"## Description\n\n`lower-scf-to-calyx` pass crashes with a segmentation fault when processing a function containing `func.call` operations inside a loop body. The crash occurs in `BuildControl::buildCFGControl` when constructing `mlir::SuccessorRange` with an invalid Block pointer.\n\nWhen an `affine.for` loop containing `func.call` is lowered through `--lower-affine` and `--scf-for-to-while`, the resulting SCF while loop triggers a null pointer access during Calyx control flow construction.\n\n**Crash Type**: Segmentation Fault (SIGSEGV)  \n**Dialect**: Calyx  \n**Failing Pass**: `lower-scf-to-calyx` (SCFToCalyx)\n\n## Steps to Reproduce\n\n1. Save the test case below as `test.mlir`\n2. Run:\n   ```bash\n   mlir-opt --lower-affine --scf-for-to-while test.mlir | \\\n     circt-opt --pass-pipeline='builtin.module(lower-scf-to-calyx{top-level-function=f})'\n   ```\n\n## Test Case\n\n```mlir\n// Minimal test case: func.call inside affine.for triggers SCFToCalyx segfault\n\nfunc.func private @ext()\n\nfunc.func @f() {\n  affine.for %i = 0 to 1 {\n    func.call @ext() : () -> ()\n  }\n  return\n}\n```\n\n## Error Output\n\n```\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: /opt/firtool-1.139.0/bin/circt-opt --pass-pipeline=builtin.module(lower-scf-to-calyx{top-level-function=f})\n #0 0x00007fc013a018a8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x2008a8)\n #1 0x00007fc0139ff2f5 llvm::sys::RunSignalHandlers() (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x1fe2f5)\n #2 0x00007fc013a02631 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x00007fc01350f330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #4 0x00007fc013c4a4f3 mlir::SuccessorRange::SuccessorRange(mlir::Block*) (/opt/firtool-1.139.0/bin/../lib/libMLIRIR.so+0x8f4f3)\n #5 0x00007fc0199004f7 circt::scftocalyx::BuildControl::buildCFGControl(llvm::DenseSet<mlir::Block*, llvm::DenseMapInfo<mlir::Block*, void>>, mlir::PatternRewriter&, mlir::Block*, mlir::Block*, mlir::Block*) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTSCFToCalyx.so+0x644f7)\n #6 0x00007fc019900256 circt::scftocalyx::BuildControl::partiallyLowerFuncToComp(mlir::func::FuncOp, mlir::PatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTSCFToCalyx.so+0x64256)\n #7 0x00007fc0187e298d circt::calyx::FuncOpPartialLoweringPattern::partiallyLower(mlir::func::FuncOp, mlir::PatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTCalyxTransforms.so+0x1c98d)\n #8 0x00007fc0198f5047 circt::calyx::PartialLoweringPattern<mlir::func::FuncOp, mlir::OpRewritePattern>::matchAndRewrite(mlir::func::FuncOp, mlir::PatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTSCFToCalyx.so+0x59047)\n #9 0x00007fc015f6b8ed void llvm::function_ref<void ()>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_0>(long) PatternApplicator.cpp:0:0\n#10 0x00007fc015f68774 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/opt/firtool-1.139.0/bin/../lib/libMLIRRewrite.so+0x7774)\n#11 0x00007fc015fc04a7 (anonymous namespace)::GreedyPatternRewriteDriver::processWorklist() GreedyPatternRewriteDriver.cpp:0:0\n#12 0x00007fc015fbdfd9 mlir::applyPatternsGreedily(mlir::Region&, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig, bool*) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x46fd9)\n#13 0x00007fc0198ef341 circt::(anonymous namespace)::SCFToCalyxPass::runOnOperation() SCFToCalyx.cpp:0:0\n#14 0x00007fc015d5b2a5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x172a5)\n#15 0x00007fc015d5e7a9 mlir::PassManager::run(mlir::Operation*) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x1a7a9)\n#16 0x00007fc0196b906a performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) MlirOptMain.cpp:0:0\n#17 0x00007fc0196b81be llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::MemoryBufferRef const&, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::MemoryBufferRef const&, llvm::raw_ostream&) MlirOptMain.cpp:0:0\n#18 0x00007fc013b90257 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::MemoryBufferRef const&, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) (/opt/firtool-1.139.0/bin/../lib/libMLIRSupport.so+0x27257)\n#19 0x00007fc0196ae4e8 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) (/opt/firtool-1.139.0/bin/../lib/libMLIROptLib.so+0xa4e8)\n#20 0x00007fc0196ae7d6 mlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) (/opt/firtool-1.139.0/bin/../lib/libMLIROptLib.so+0xa7d6)\n#21 0x00007fc0196aea0d mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) (/opt/firtool-1.139.0/bin/../lib/libMLIROptLib.so+0xaa0d)\n#22 0x0000560f2bbc5e10 main (/opt/firtool-1.139.0/bin/circt-opt+0xde10)\n#23 0x00007fc0134f41ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#24 0x00007fc0134f428b call_init ./csu/../csu/libc-start.c:128:20\n#25 0x00007fc0134f428b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#26 0x0000560f2bbc56a5 _start (/opt/firtool-1.139.0/bin/circt-opt+0xd6a5)\n```\n\n## Root Cause Analysis\n\n**Cause**: SCFToCalyx does not support `func.call` operations inside loop bodies\n\n**Mechanism**: `buildCFGControl` encounters `func.call` which introduces unexpected CFG edges or Block successor structure, leading to null pointer access in `SuccessorRange` constructor.\n\n## Environment\n\n- **CIRCT Version**: firtool-1.139.0\n- **OS**: Linux\n- **Architecture**: x86_64\n","labels":[],"number":9529,"state":"OPEN","title":"[Calyx] Segfault in SCFToCalyx when func.call exists inside loop body","url":"https://github.com/llvm/circt/issues/9529"}
{"body":"Consider the following example, directly adapted from an existing `lower-domains.mlir` test:\n\n``` mlir\n firrtl.circuit \"Foo\" {\n  firrtl.domain @ClockDomain\n  firrtl.module private @ZeroWidthPort(\n    in %A: !firrtl.domain of @ClockDomain,\n    in %a: !firrtl.uint<0> domains [%A]\n  ) {\n  }\n  firrtl.module @Foo() {}\n}\n```\n\nCurrently, this will lower the `ZeroWidthPort` module to the following. This keeps the domain information, but it is intentionally empty because `LowerToHW` will strip zero-width ports.\n\n``` mlir\nfirrtl.module private @ZeroWidthPort(\n  in %A: !firrtl.class<@ClockDomain()>, \n  out %A_out: !firrtl.class<@ClockDomain_out(\n    in domainInfo_in: !firrtl.class<@ClockDomain()>, \n    out domainInfo_out: !firrtl.class<@ClockDomain()>, \n    in associations_in: !firrtl.list<path>, \n    out associations_out: !firrtl.list<path>\n  )>, \n  in %a: !firrtl.uint<0>\n) {\n      %A_object = firrtl.object @ClockDomain_out(in domainInfo_in: !firrtl.class<@ClockDomain()>, out domainInfo_out: !firrtl.class<@ClockDomain()>, in associations_in: !firrtl.list<path>, out associations_out: !firrtl.list<path>)\n      %0 = firrtl.object.subfield %A_object[domainInfo_in] : !firrtl.class<@ClockDomain_out(in domainInfo_in: !firrtl.class<@ClockDomain()>, out domainInfo_out: !firrtl.class<@ClockDomain()>, in associations_in: !firrtl.list<path>, out associations_out: !firrtl.list<path>)>\n      firrtl.propassign %0, %A : !firrtl.class<@ClockDomain()>\n      %1 = firrtl.object.subfield %A_object[associations_in] : !firrtl.class<@ClockDomain_out(in domainInfo_in: !firrtl.class<@ClockDomain()>, out domainInfo_out: !firrtl.class<@ClockDomain()>, in associations_in: !firrtl.list<path>, out associations_out: !firrtl.list<path>)>\n      %2 = firrtl.list.create  : !firrtl.list<path>\n      firrtl.propassign %1, %2 : !firrtl.list<path>\n      firrtl.propassign %A_out, %A_object : !firrtl.class<@ClockDomain_out(in domainInfo_in: !firrtl.class<@ClockDomain()>, out domainInfo_out: !firrtl.class<@ClockDomain()>, in associations_in: !firrtl.list<path>, out associations_out: !firrtl.list<path>)>\n    }\n```\n\nI've observed a handful of situations where there are private modules with lots of this going on, e.g., O(10) unused, inferred domains show up because there are lots of zero-width ports.\n\nIt would be better if truly unused domains could be stripped when they have no association information. This may motivate breaking the zero-width removal part of `LowerToHW` out to a pass that runs earlier in the FIRRTL to HW conversion pipeline.","labels":[{"id":"MDU6TGFiZWwxODg4ODczNzIw","name":"enhancement","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":9516,"state":"OPEN","title":"[FIRRTL] Elide domains of zero-width ports in LowerDomains","url":"https://github.com/llvm/circt/issues/9516"}
{"body":"Hello! I was wondering if any handshake expert can please help me on this question.\n\nIâ€™m working on a tool that targets `handshake` as its backend. Currently it generates memories using `handshake.extmemory` like this\n\n```\nhandshake.func @f(%v0: i32, %ctrl : none, %extmem : memref<11 x i32>) -> (none) {\n  ... handshake.extmemory ... (%extmem : memref<11 x i32>) ...\n}\n```\n\nIâ€™m trying to find a good way to test such output. One way Iâ€™ve attempted is to write a top-level handshake wrapper that calls the circuit above, and then hope that `hlstool` will \"link\" them correctly.\n\n```\nhandshake.func @top(%v0: i32, %ctrl : none) -> (none) attributes {argNames = [\"in0\", \"in1\"], resNames = [\"out0\"]} {\n  %extmem = memref.alloc() : memref<11 x i32>\n  %out = instance @f(%v0, %ctrl, %extmem) : (i32, none, memref<11 x i32>) -> (none)\n  return %out : none\n}\n```\n\nbut `hlstool` complains that\n```\nerror: 'handshake.instance' op incorrect number of operands for the referenced handshake function\n    %1 = instance @f(%v0, %ctrl, %extmem) : (i32, none, memref<11 x i32>) -> (none)\n```\nwhich I suspect is due to that `memref.alloc` doesnâ€™t work in handshake, and `%extmem` gets lowered into multiple load/store ports.\n\nI was wondering:\n- Is there a way to make the `@top` function above work (i.e., allowing it to create a memory and call `@f` with it)?\n- If that doesn't work, what's the recommended way to test circuits like `@f` above? Should I just lower it to Verilog and then simulate the memory in, e.g., cocotb?\n\nThank you so much!","labels":[],"number":9507,"state":"OPEN","title":"[Handshake] Calling `handshake.instance` with a `memref`.","url":"https://github.com/llvm/circt/issues/9507"}
{"body":"```mlir\nmodule {\n  firrtl.circuit \"Foo\" {\n    sv.verbatim \"{{0}}\" {symbols = [#hw.innerNameRef<@Foo::@sym>] }\n    firrtl.module private @Baz() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\n      %a = firrtl.wire interesting_name : !firrtl.uint<1>\n      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\n      firrtl.matchingconnect %a, %invalid_ui1 : !firrtl.uint<1>\n    }\n    firrtl.module @Foo() {\n      firrtl.instance baz sym @sym interesting_name @Baz()\n    }\n  }\n}\n\n$ circt-opt --firrtl-inliner\nmodule {\n  firrtl.circuit \"Foo\" {\n    sv.verbatim \"{{0}}\" {symbols = [#hw.innerNameRef<@Foo::@sym>]}\n    firrtl.module @Foo() {\n      %baz_a = firrtl.wire interesting_name : !firrtl.uint<1>\n      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\n      firrtl.matchingconnect %baz_a, %invalid_ui1 : !firrtl.uint<1>\n    }\n  }\n}\n\n```\n\n`@sym` doesn't exist anymore and raises an error in ExportVerilog. \nIt also passes a verifier because sv.verbatim doesn't implement InnerRefUserOpInterface","labels":[],"number":9491,"state":"OPEN","title":"[FIRRTL][SV] Inliner inlines an instance with an inner ref captured by sv.verbatim","url":"https://github.com/llvm/circt/issues/9491"}
{"body":"I've run into the following when starting to turn on domains for an internal design. The issue is I have _a lot_ of external modules, which map to external classes, but I don't have any internal domain information for them. However, I don't exactly _need_ any internal information for them.\n\nE.g.:\n\n``` firrtl\nFIRRTL version 6.0.0\ncircuit Foo:\n  domain ClockDomain:\n    name: String\n    period: Integer\n\n  extmodule Bar:\n    input A: Domain of ClockDomain\n    input a: UInt<1> domains [A]\n\n  public module Foo:\n    input A: Domain of ClockDomain\n    input a: UInt<1> domains [A]\n\n    inst bar of Bar\n    domain_define bar.A = A\n    connect bar.a, a\n```\n\nUsing `main` patched with https://github.com/llvm/circt/pull/9474, I run into the following:\n\n``` console\n# firtool Foo.fir -output-final-mlir - -o /dev/null | domaintool - --module Foo --domain ClockDomain,A,10 --assign 0\n<stdin>:1:1: error: unknown class name @Bar_Class\nmodule {\n^\n```\n\nThe final MLIR is:\n\n``` mlir\nmodule {\n  hw.hierpath private @nla [@Foo::@sym]\n  hw.hierpath private @nla_0 [@Foo::@sym_0]\n  hw.module.extern private @Bar(in %a : i1 {hw.exportPort = #hw<innerSym@sym>})\n  hw.module @Foo(in %a : i1 {hw.exportPort = #hw<innerSym@sym>}) {\n    hw.instance \"bar\" sym @sym_0 @Bar(a: %a: i1) -> () {hw.verilogName = \"bar\"}\n    hw.output\n  }\n  om.class.extern @Bar_Class(%basepath: !om.frozenbasepath, %A: !om.class.type<@ClockDomain>)  -> (A_out: !om.class.type<@ClockDomain_out>) {\n  }\n  om.class @Foo_Class(%basepath: !om.frozenbasepath, %A: !om.class.type<@ClockDomain>)  -> (A_out: !om.class.type<@ClockDomain_out>) {\n    %0 = om.object @ClockDomain_out(%basepath, %A, %2) : (!om.frozenbasepath, !om.class.type<@ClockDomain>, !om.list<!om.frozenpath>) -> !om.class.type<@ClockDomain_out>\n    %1 = om.frozenpath_create reference %basepath \"Foo>a\"\n    %2 = om.list_create %1 : !om.frozenpath\n    %3 = om.frozenbasepath_create %basepath \"Foo/bar\"\n    %4 = om.object @Bar_Class(%3, %A) : (!om.frozenbasepath, !om.class.type<@ClockDomain>) -> !om.class.type<@Bar_Class>\n    %5 = om.object.field %4, [@A_out] : (!om.class.type<@Bar_Class>) -> !om.class.type<@ClockDomain_out>\n    om.class.fields %0 : !om.class.type<@ClockDomain_out> \n  }\n  om.class @ClockDomain(%basepath: !om.frozenbasepath, %name_in: !om.string, %period_in: !om.integer)  -> (name_out: !om.string, period_out: !om.integer) {\n    om.class.fields %name_in, %period_in : !om.string, !om.integer \n  }\n  om.class @ClockDomain_out(%basepath: !om.frozenbasepath, %domainInfo_in: !om.class.type<@ClockDomain>, %associations_in: !om.list<!om.frozenpath>)  -> (domainInfo_out: !om.class.type<@ClockDomain>, associations_out: !om.list<!om.frozenpath>) {\n    om.class.fields %domainInfo_in, %associations_in : !om.class.type<@ClockDomain>, !om.list<!om.frozenpath> \n  }\n}\n```\n\ntl;dr: the evaluator tries to evaluate the class `Bar_Class`, but it can't because it's external.\n\nThere's two rough shapes of solutions here:\n\n1. The evaluator needs to be lazier. There's no actual _need_ to evaluate `Bar_Class` here as it can't affect the outputs of `Foo_Class`.\n2. `Bar_Class` needs to not be external and the domain information needs to be available for it. Or: this is illegal and the circuit needs to be linked before it can be evaluated.\n\nThis is a simpler example than what I was discussing with @dtzSiFive earlier today where `Bar` provided all domain information and `Foo` only had output domains. In that situation, there's nothing that you can do other than (2). Hence, this may be what is necessary here.","labels":[{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"},{"id":"LA_kwDODpuCgs8AAAABXqhYRQ","name":"OM","description":"Object Model","color":"7AC323"}],"number":9490,"state":"OPEN","title":"[OM][Evaluator][FIRRTL] Should we be able to evaluate ext classes if we don't use the outputs?","url":"https://github.com/llvm/circt/issues/9490"}
{"body":"Hi all, \n\nwhen building with the latest [slang](https://github.com/MikePopoloski/slang) master branch, there seems to be an issue with tests on `basic.sv`.\n\nSpecifically, I'm getting the following unexpected output\n```\n$ circt-translate --import-verilog test/Conversion/ImportVerilog/basic.sv | FileCheck test/Conversion/ImportVerilog/basic.sv\n\n../test/Conversion/ImportVerilog/basic.sv:1740:12: error: CHECK: expected string not found in input\n // CHECK: [[V0:%.+]] = moore.extract_ref %z3 from 2\n           ^\n<stdin>:1431:36: note: scanning from here\n %11 = moore.extract_ref %z3 from 1 : <l3> -> <l1>\n                                   ^\n<stdin>:1435:2: note: possible intended match here\n %15 = moore.extract_ref %w3 from 0 : <l2> -> <l1>\n ^\n\nInput file: <stdin>\nCheck file: ../test/Conversion/ImportVerilog/basic.sv\n\n-dump-input=help explains the following input dump.\n\nInput was:\n<<<<<<\n              .\n              .\n              .\n           1426:  %z3 = moore.net wire : <l3> \n           1427:  %w3 = moore.net wire : <l2> \n           1428:  %8 = moore.read %x3 : <l1> \n           1429:  %9 = moore.read %y3 : <l1> \n           1430:  %10 = moore.extract_ref %z3 from 0 : <l3> -> <l1> \n           1431:  %11 = moore.extract_ref %z3 from 1 : <l3> -> <l1> \ncheck:1740'0                                        X~~~~~~~~~~~~~~~ error: no match found\n           1432:  %12 = moore.read %z3 : <l3> \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1433:  %13 = moore.constant 2 : i32 \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1434:  %14 = moore.dyn_extract %12 from %13 : l3, i32 -> l1 \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1435:  %15 = moore.extract_ref %w3 from 0 : <l2> -> <l1> \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ncheck:1740'1      ?                                                  possible intended match\n           1436:  %16 = moore.read %w3 : <l2> \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1437:  %17 = moore.constant 1 : i32 \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1438:  %18 = moore.dyn_extract %16 from %17 : l2, i32 -> l1 \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1439:  %p3.v1, %p3.c1 = moore.instance \"p3\" @MultiPorts(a0: %8: !moore.l1, a1: %9: !moore.l1, v0: %14: !moore.l1, v2: %10: !moore.ref<l1>, c0: %18: !moore.l1) -> (v1: !moore.l1, c1: !moore.l1) \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           1440:  moore.assign %11, %p3.v1 : l1 \ncheck:1740'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n              .\n              .\n              .\n>>>>>>\n\n```\n\nIt looks like `moore.extract_ref %z3 from 2` is missing but therefore we have this:\n```\n%12 = moore.read %z3 : <l3>\n%13 = moore.constant 2 : i32\n%14 = moore.dyn_extract %12 from %13 : l3, i32 -> l1 \n```\n\nDo you have any advice on how to proceed with this?\n\nThanks!","labels":[],"number":9489,"state":"OPEN","title":"[slang] Testing error when switching to slang master branch","url":"https://github.com/llvm/circt/issues/9489"}
{"body":"Consider:\n\n``` firrtl\nFIRRTL version 6.0.0\n\ncircuit WhenDom:\n  domain ClockDomain:\n\n  public module WhenDom:\n    input A : Domain of ClockDomain\n    input B : Domain of ClockDomain\n    input c : UInt<1> domains [A]\n    input x : UInt<1> domains [B]\n    input y : UInt<1> domains [B]\n    output z : UInt<1> domains [B]\n\n    when c:\n      connect z, x\n    else:\n      connect z, y\n```\n\n`firtool -domain-mode=infer-all`\n\n-->\n\n``` systemverilog\n// Generated by CIRCT firtool-1.139.0-59-gd2c1575fe9-dirty\nmodule WhenDom(\n  input  c,\n         x,\n         y,\n  output z\n);\n\n  assign z = c ? x : y;\nendmodule\n```\n\nThis should error, as can be seen in the produce verilog `z` depends on `c` and needs to be on the same domain.\n\nTitle is for end-to-end behavior, running domain inference after ExpandWhens addresses this issue.","labels":[{"id":"MDU6TGFiZWwyMTUyNzUzNjMw","name":"FIRRTL","description":"Involving the `firrtl` dialect","color":"fbca04"}],"number":9488,"state":"OPEN","title":"[FIRRTL] Domain inference should consider control dependencies","url":"https://github.com/llvm/circt/issues/9488"}
{"body":"When I write a FIRRTL program like this:\r\n```\r\ncircuit FormalSimple :\r\n  module FormalSimple :\r\n    input clock : Clock\r\n    input reset1 : UInt<1>\r\n    output io : UInt<10>\r\n\r\n    wire a1 : UInt\r\n    wire a2 : UInt\r\n\r\n    a1 <= shr(mul(a2, a2), 3)\r\n    a2 <= shr(mul(a1, a1), 3)\r\n\r\n    io <= a1\r\n```\r\nwidths constraints for implicit widths in the circuit should be:\r\n```\r\nx1 >= 2x2 -3\r\nx2 >= 2x1 -3\r\n```\r\nand the solution can be (2,1) or (1,2), which is confused to find out which solution should be assigned to a1,a2.\r\n\r\nIn fact for this case, firtool gives an error like this:\r\n```\r\nFormalSimple.fir:7:5: error: 'firrtl.wire' op is constrained to be wider than itself\r\n    wire a1 : UInt\r\n    ^\r\nFormalSimple.fir:7:5: note: see current operation: %0 = \"firrtl.wire\"() {annotations = [], name = \"a1\", nameKind = #firrtl<name_kind droppable_name>} : () -> !firrtl.uint\r\nFormalSimple.fir:11:15: note: constrained width W >= 2W here:\r\n    a2 <= shr(mul(a1, a1), 3)\r\n              ^\r\nFormalSimple.fir:11:11: note: constrained width W >= 2W-3 here:\r\n    a2 <= shr(mul(a1, a1), 3)\r\n          ^\r\nFormalSimple.fir:11:11: note: constrained width W >= 2W here:\r\nFormalSimple.fir:11:8: note: constrained width W >= 2W here:\r\n    a2 <= shr(mul(a1, a1), 3)\r\n       ^\r\nFormalSimple.fir:11:8: note: constrained width W >= 2W here:\r\nFormalSimple.fir:11:8: note: constrained width W >= 2W here:\r\nFormalSimple.fir:11:8: note: constrained width W >= 2W here:\r\nFormalSimple.fir:8:5: note: constrained width W >= 2W here:\r\n    wire a2 : UInt\r\n    ^\r\nFormalSimple.fir:11:15: note: constrained width W >= 2W here:\r\n    a2 <= shr(mul(a1, a1), 3)\r\n              ^\r\nFormalSimple.fir:11:11: note: constrained width W >= 2W-3 here:\r\n    a2 <= shr(mul(a1, a1), 3)\r\n          ^\r\nFormalSimple.fir:11:11: note: constrained width W >= 2W here:\r\nFormalSimple.fir:11:8: note: constrained width W >= 2W here:\r\n    a2 <= shr(mul(a1, a1), 3)\r\n       ^\r\nFormalSimple.fir:11:8: note: constrained width W >= 2W here:\r\nFormalSimple.fir:11:8: note: constrained width W >= 2W here:\r\nFormalSimple.fir:11:8: note: constrained width W >= 2W here:\r\nFormalSimple.fir:8:5: note: constrained width W >= 2W here:\r\n    wire a2 : UInt\r\n    ^\r\nFormalSimple.fir:10:15: note: constrained width W >= 4W here:\r\n    a1 <= shr(mul(a2, a2), 3)\r\n              ^\r\nFormalSimple.fir:10:11: note: constrained width W >= 4W-3 here:\r\n    a1 <= shr(mul(a2, a2), 3)\r\n          ^\r\nFormalSimple.fir:10:11: note: constrained width W >= 4W here:\r\nFormalSimple.fir:10:8: note: constrained width W >= 4W here:\r\n    a1 <= shr(mul(a2, a2), 3)\r\n       ^\r\nFormalSimple.fir:10:8: note: constrained width W >= 4W here:\r\nFormalSimple.fir:10:8: note: constrained width W >= 4W here:\r\nFormalSimple.fir:10:8: note: constrained width W >= 4W here:\r\n\r\n```\r\n\r\nThe error means this program is illegal For FIRRTL or there is some problem in CIRCT compiler? What should be the solution and the widths?","labels":[],"number":6924,"state":"OPEN","title":"[FIRRTL][InferWidths] When there is no unique minimal solution for width constraints, what should be the width?","url":"https://github.com/llvm/circt/issues/6924"}
