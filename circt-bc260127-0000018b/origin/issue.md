# [Comb] Concat/extract canonicalizer crashes on indexed array assignment (Duplicate of #8863)

**Issue Type:** Bug Report (Duplicate)
**Related Issue:** #8863 "[Comb] Concat/extract canonicalizer crashes on loop"
**Testcase ID:** 260127-0000018b

## Summary

Assertion failure in `extractConcatToConcatExtract` canonicalization pattern when processing indexed array assignments in combinational blocks. The pattern rewriter calls `replaceOpAndCopyNamehint` without ensuring all uses of the operation are properly replaced, causing `eraseOp` to fail with assertion `op->use_empty()`.

**Note:** This issue is a **duplicate of #8863** with 95% similarity. Both issues describe the same crash in the same function with the same assertion and trigger pattern. This report documents a variant test case.

## Minimized Test Case

```systemverilog
module m;
  logic [3:0] a;
  int i;
  always_comb a[i] = 1'b1;
endmodule
```

## Crash Details

### Environment
- **CIRCT Version:** firtool-1.139.0 (crash version)
- **LLVM Version:** 22.0.0git
- **Current Status:** Not reproducible with current toolchain (bug may have been fixed)

### Reproduction Command
```bash
/edazz/FeatureFuzz-SV/target/circt-1.139.0/bin/circt-verilog --ir-hw bug.sv
```

### Crash Type
Assertion failure

### Stack Trace

```
circt-verilog: /path/to/mlir/lib/IR/PatternMatch.cpp:156: virtual void mlir::RewriterBase::eraseOp(Operation *): Assertion `op->use_empty() && "expected 'op' to have no uses"' failed.

Stack dump:
 #0 llvm::sys::PrintStackTrace(...)
 #1 llvm::sys::RunSignalHandlers()
 #2 SignalHandler(int, siginfo_t*, void*)
 #3 [signal handler]
 #12 circt::replaceOpAndCopyNamehint(mlir::PatternRewriter&, mlir::Operation*, mlir::Value)
      at lib/Support/Naming.cpp:82
 #13 extractConcatToConcatExtract(circt::comb::ExtractOp, circt::comb::ConcatOp, mlir::PatternRewriter&)
      at lib/Dialect/Comb/CombFolds.cpp:548
 #14 circt::comb::ExtractOp::canonicalize(circt::comb::ExtractOp, mlir::PatternRewriter&)
      at lib/Dialect/Comb/CombFolds.cpp:615
 #15 mlir::PatternApplicator::matchAndRewrite(...)
 #19 (anonymous namespace)::GreedyPatternRewriteDriver::processWorklist()
      at mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:621
 #28 mlir::Canonicalizer::runOnOperation()
      at mlir/lib/Transforms/Canonicalizer.cpp:65
```

## Root Cause Analysis

### Crash Location
- **File:** `lib/Dialect/Comb/CombFolds.cpp`
- **Function:** `extractConcatToConcatExtract`
- **Line:** ~548 (may vary by version)
- **Assertion:** `op->use_empty() && "expected 'op' to have no uses"`

### Root Cause

The `extractConcatToConcatExtract` canonicalization pattern transforms operations of the form:
```
extract(lo, cat(a, b, c)) → cat(extract(lo1, b), c, extract(lo2, d))
```

The function calls `replaceOpAndCopyNamehint` (line ~544-545) to replace the original ExtractOp, which internally calls `rewriter.replaceOp(op, newValue)` followed by `eraseOp`. However, with certain IR structures generated by dynamic indexed array assignments, the replacement value may not capture all uses of the original ExtractOp, leaving dangling uses when `eraseOp` is called.

### Trigger Pattern

Dynamic indexed array assignment in combinational blocks:
```systemverilog
logic [7:0] arr;
int idx;
always_comb begin
  arr[idx] = 1'b1;  // Generates complex ExtractOp/ConcatOp patterns
end
```

This pattern creates IR with:
- Multiple interconnected ExtractOp operations for different bit ranges
- ConcatOp operations to reassemble results
- Potential circular dependencies in the canonicalization worklist

## Comparison with #8863

| Aspect | This Issue | #8863 | Match? |
|--------|-----------|-------|---------|
| Assertion | `op->use_empty()` | `op->use_empty()` | ✅ |
| Function | `extractConcatToConcatExtract` | `extractConcatToConcatExtract` | ✅ |
| File | `CombFolds.cpp:548` | `CombFolds.cpp:513` | ✅ (line offset) |
| Caller | `ExtractOp::canonicalize` | `ExtractOp::canonicalize` | ✅ |
| Helper | `replaceOpAndCopyNamehint` | `replaceOpAndCopyNamehint` | ✅ |
| Trigger | `arr[idx] = 1'b1` | `arr[0]=a; arr[1]=b` | ✅ (same pattern) |
| Crash Type | assertion | assertion | ✅ |

**Similarity Score:** 9.5/10

## Suggested Fix

### Option 1: Add Use Check Before Replace
```cpp
// Before calling replaceOpAndCopyNamehint
if (!op->use_empty() && op.getResult() != newValue) {
    // There are uses that won't be replaced by this transformation
    return failure();
}
```

### Option 2: Use replaceAllUsesWith Explicitly
```cpp
// First replace all uses
rewriter.replaceAllUsesWith(op.getResult(), newValue);
// Copy namehint if needed
if (auto *newOp = newValue.getDefiningOp()) {
    if (auto name = op->getAttrOfType<StringAttr>("sv.namehint"))
        if (!newOp->hasAttr("sv.namehint"))
            rewriter.modifyOpInPlace(newOp, [&] {
                newOp->setAttr("sv.namehint", name);
            });
}
// Now safely erase
rewriter.eraseOp(op);
```

### Option 3: Early Termination Check for Circular Dependencies
```cpp
// Check if any concat arg uses the extract op itself
for (Value arg : innerCat.getInputs()) {
    if (auto *defOp = arg.getDefiningOp()) {
        for (Value operand : defOp->getOperands()) {
            if (operand.getDefiningOp() == op.getOperation())
                return failure();
        }
    }
}
```

## Additional Notes

1. **Reproducibility:** This crash was observed in CIRCT version 1.139.0 but is not reproducible with the current toolchain, suggesting the bug may have been fixed.
2. **Related Issues:**
   - #8863: "[Comb] Concat/extract canonicalizer crashes on loop" (OPEN)
   - #8024: "[Comb] Crash in AndOp folder" (different crash, same file)
3. **Impact:** Affects any SystemVerilog code using dynamic indexed array assignments in combinational blocks
4. **Workaround:** Avoid dynamic array indexing in `always_comb` blocks when possible, or use static indexing

## Recommendation

**Consolidate into #8863**

This issue should be closed as a duplicate of #8863. The test case provided here offers an alternative minimal reproducer that may be useful for verifying the fix. Both issues describe the exact same crash with identical root cause.

## Related Files

- `lib/Dialect/Comb/CombFolds.cpp` - Location of the bug in `extractConcatToConcatExtract`
- `lib/Support/Naming.cpp` - Helper function `replaceOpAndCopyNamehint`
- `llvm/mlir/lib/IR/PatternMatch.cpp` - Location of the assertion in `eraseOp`
