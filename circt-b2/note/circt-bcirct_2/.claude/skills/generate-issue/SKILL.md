---
name: generate-issue
description: 生成 CIRCT GitHub Issue 报告。整合所有分析结果，按照 CIRCT Issue 模板格式生成完整的 Bug 报告。
argument-hint: (无参数，在当前目录操作)
allowed-tools: Shell(cat:*), Shell(ls:*), Shell(jq:*), Read, Write, Grep
---

# Skill: 生成 Issue 报告

## 功能描述

整合所有前序步骤的输出，按照 CIRCT GitHub Issue 模板格式生成完整的 Bug 报告。输出可以直接复制粘贴到 GitHub Issue。

## 输入

当前目录必须包含：
- `bug.sv` (或 `.fir`/`.mlir`) - 最小化测例
- `error.log` - 错误日志
- `command.txt` - 复现命令
- `root_cause.md` - 根因分析报告
- `analysis.json` - 分析数据
- `validation.md` - 验证报告
- `duplicates.md` - 重复检查报告
- `metadata.json` - 工作流元数据

## 输出

- `issue.md` - 完整的 GitHub Issue 报告

## Issue 结构

CIRCT Issue 应该包含以下部分：

```markdown
## Description
[简要描述 Bug + 根因假设]

## Steps to Reproduce
1. Save test case as `test.sv`
2. Run: `<command>`

## Test Case
[最小化测例代码]

## Error Output
[错误日志]

## Root Cause Analysis
[来自根因分析的关键信息]

## Environment
[工具版本等]

## Stack Trace
[可折叠的 stack trace]

## Related Issues
[相关 Issue 链接]
```

## 执行步骤

### Step 1: 读取所有输入

```bash
# 检测测例文件
BUG_FILE=""
for ext in sv fir mlir; do
    if [ -f bug.$ext ]; then
        BUG_FILE="bug.$ext"
        BUG_EXT="$ext"
        break
    fi
done

if [ -z "$BUG_FILE" ]; then
    echo "Error: No bug file found"
    exit 1
fi

# 检查必需文件
for file in error.log command.txt analysis.json metadata.json; do
    if [ ! -f "$file" ]; then
        echo "Warning: $file not found"
    fi
done

# 读取分析数据
DIALECT=$(jq -r '.dialect // "unknown"' analysis.json 2>/dev/null)
FAILING_PASS=$(jq -r '.failing_pass // "unknown"' analysis.json 2>/dev/null)
CRASH_TYPE=$(jq -r '.crash_type // "unknown"' analysis.json 2>/dev/null)
ASSERTION_MSG=$(jq -r '.assertion_message // ""' analysis.json 2>/dev/null)

# 读取工具版本
TOOL_VERSION=$(jq -r '.tool.version // "unknown"' metadata.json 2>/dev/null)

# 读取复现命令
REPRO_CMD=$(cat command.txt 2>/dev/null)

# 读取关键词（用于标题）
KEYWORDS=$(jq -r '.keywords[0:3][]?' analysis.json 2>/dev/null | tr '\n' ' ')

echo "Dialect: $DIALECT"
echo "Failing pass: $FAILING_PASS"
echo "Tool version: $TOOL_VERSION"
```

### Step 2: 生成 Issue 标题

```bash
# 标题格式: [Dialect] Brief description of the crash
# 例如: [Moore] Assertion failure in MooreToCore when lowering array in sensitivity list

generate_title() {
    local dialect="$1"
    local crash_type="$2"
    local failing_pass="$3"
    local keywords="$4"
    
    # 基础标题
    local title="[$dialect]"
    
    # 添加崩溃类型
    case $crash_type in
        assertion) title="$title Assertion failure" ;;
        segfault) title="$title Crash (segfault)" ;;
        llvm_error) title="$title LLVM ERROR" ;;
        *) title="$title Crash" ;;
    esac
    
    # 添加位置
    if [ "$failing_pass" != "unknown" ]; then
        title="$title in $failing_pass"
    fi
    
    # 添加关键词描述
    if [ -n "$keywords" ]; then
        title="$title with $keywords"
    fi
    
    echo "$title"
}

ISSUE_TITLE=$(generate_title "$DIALECT" "$CRASH_TYPE" "$FAILING_PASS" "$KEYWORDS")
echo "Generated title: $ISSUE_TITLE"
```

### Step 3: 提取根因摘要

```bash
# 从 root_cause.md 提取 Executive Summary
extract_summary() {
    if [ -f root_cause.md ]; then
        # 提取 Executive Summary 部分
        sed -n '/^## Executive Summary/,/^##/p' root_cause.md | head -n -1 | tail -n +2
    else
        echo "Root cause analysis not available."
    fi
}

ROOT_CAUSE_SUMMARY=$(extract_summary)

# 提取假设
extract_hypotheses() {
    if [ -f root_cause.md ]; then
        sed -n '/^### Hypothesis 1/,/^### Hypothesis 2/p' root_cause.md | head -n -1
    fi
}

TOP_HYPOTHESIS=$(extract_hypotheses)
```

### Step 4: 处理 Stack Trace

```bash
# 提取并格式化 stack trace
extract_stack_trace() {
    if [ -f error.log ]; then
        # 提取 stack trace 部分（通常在 assertion 之后）
        grep -A 100 -E '(PLEASE submit a bug report|Stack dump:|Backtrace:)' error.log | head -50
    fi
}

STACK_TRACE=$(extract_stack_trace)

# 过滤只保留 circt/mlir 相关帧
filter_stack_trace() {
    echo "$STACK_TRACE" | grep -E '(circt|mlir|llvm)' | head -20
}

FILTERED_STACK=$(filter_stack_trace)
```

### Step 5: 获取相关 Issue

```bash
# 从 duplicates.json 提取相关 Issue
extract_related_issues() {
    if [ -f duplicates.json ]; then
        jq -r '.results.issues[0:3][] | "- #\(.number): \(.title)"' duplicates.json 2>/dev/null
    fi
}

RELATED_ISSUES=$(extract_related_issues)
```

### Step 6: 生成 issue.md

```bash
# 生成语言标识
case $BUG_EXT in
    sv) LANG_TAG="systemverilog" ;;
    fir) LANG_TAG="firrtl" ;;
    mlir) LANG_TAG="mlir" ;;
    *) LANG_TAG="" ;;
esac

# 生成 Issue
cat > issue.md << 'ISSUE_HEADER'
<!-- 
  CIRCT Bug Report
  Generated by circt-bug-reporter skill
-->

ISSUE_HEADER

# 标题注释
echo "<!-- Title: $ISSUE_TITLE -->" >> issue.md
echo "" >> issue.md

# Description
cat >> issue.md << DESCRIPTION_SECTION
## Description

$ROOT_CAUSE_SUMMARY

**Crash Type**: $CRASH_TYPE
**Dialect**: $DIALECT
**Failing Pass**: $FAILING_PASS

DESCRIPTION_SECTION

# Steps to Reproduce
cat >> issue.md << REPRO_SECTION
## Steps to Reproduce

1. Save the test case below as \`test.$BUG_EXT\`
2. Run:
   \`\`\`bash
   $REPRO_CMD
   \`\`\`

REPRO_SECTION

# Test Case
echo "## Test Case" >> issue.md
echo "" >> issue.md
echo "\`\`\`$LANG_TAG" >> issue.md
cat "$BUG_FILE" >> issue.md
echo "\`\`\`" >> issue.md
echo "" >> issue.md

# Error Output
echo "## Error Output" >> issue.md
echo "" >> issue.md
echo "\`\`\`" >> issue.md
# 只包含关键错误信息，不包含完整 stack trace
head -30 error.log >> issue.md
echo "..." >> issue.md
echo "\`\`\`" >> issue.md
echo "" >> issue.md

# Root Cause Analysis (简化版)
if [ -n "$TOP_HYPOTHESIS" ]; then
cat >> issue.md << RCA_SECTION
## Root Cause Analysis

$TOP_HYPOTHESIS

RCA_SECTION
fi

# Environment
cat >> issue.md << ENV_SECTION
## Environment

- **CIRCT Version**: $TOOL_VERSION
- **OS**: $(uname -s) $(uname -r)
- **Architecture**: $(uname -m)

ENV_SECTION

# Stack Trace (折叠)
if [ -n "$FILTERED_STACK" ]; then
cat >> issue.md << STACK_SECTION
## Stack Trace

<details>
<summary>Click to expand stack trace</summary>

\`\`\`
$FILTERED_STACK
\`\`\`

</details>

STACK_SECTION
fi

# Related Issues
if [ -n "$RELATED_ISSUES" ]; then
cat >> issue.md << RELATED_SECTION
## Related Issues

$RELATED_ISSUES

RELATED_SECTION
fi

# Footer
cat >> issue.md << FOOTER
---
*This issue was generated with assistance from an automated bug reporter.*
FOOTER

echo ""
echo "========================================"
echo "issue.md generated successfully"
echo "========================================"
echo ""
echo "Title: $ISSUE_TITLE"
echo ""
echo "Preview (first 50 lines):"
head -50 issue.md
```

## Issue 模板参考

### 好的 Issue 示例

```markdown
## Description

CIRCT's Moore dialect crashes when processing a SystemVerilog `always_ff` block 
that uses array element indexing in the sensitivity list (e.g., `@(posedge clkin_data[0])`).

The crash occurs during the MooreToCore lowering pass when attempting to convert
the EventControl operation. The lowering expects a signal reference but receives
an array index operation.

**Crash Type**: assertion
**Dialect**: Moore
**Failing Pass**: MooreToCore

## Steps to Reproduce

1. Save the test case below as `test.sv`
2. Run:
   ```bash
   circt-verilog test.sv --ir-moore 2>&1 | firtool --verilog
   ```

## Test Case

```systemverilog
module top(input logic [1:0] clkin_data, output logic out);
  always_ff @(posedge clkin_data[0]) begin
    out <= clkin_data[1];
  end
endmodule
```

## Error Output

```
circt-verilog: /path/to/MooreToCore.cpp:123: void lowerEventControl(): 
Assertion `isa<hw::SignalOp>(val)` failed.
```

## Root Cause Analysis

### Hypothesis 1 (High Confidence)
**Cause**: Moore to LLHD lowering doesn't handle array element indexing in sensitivity lists

**Evidence**:
- Test case uses `clkin_data[0]` in `@(posedge clkin_data[0])`
- Assertion: "Expected signal reference, got ArrayIndexOp"
- LLHD EventControl only accepts signal references

## Environment

- **CIRCT Version**: firtool-1.140.0
- **OS**: Linux 5.15.0
- **Architecture**: x86_64

## Stack Trace

<details>
<summary>Click to expand stack trace</summary>

```
#0 lowerEventControl() at MooreToCore.cpp:123
#1 MooreToCoreLowering::runOnOperation() at MooreToCore.cpp:456
#2 mlir::detail::OpToOpPassAdaptor::run() at Pass.cpp:789
...
```

</details>

## Related Issues

- #1234: Array indexing issues in Moore dialect
- #5678: EventControl lowering improvements

---
*This issue was generated with assistance from an automated bug reporter.*
```

## 质量检查清单

生成 Issue 前确认：

- [ ] 标题简洁且描述性强
- [ ] Description 包含问题概述
- [ ] 复现步骤清晰可执行
- [ ] 测例是最小化的
- [ ] 错误输出包含关键信息
- [ ] 环境信息完整
- [ ] Stack trace 已折叠
- [ ] 相关 Issue 已链接

## 标签建议

根据分析结果建议适当的 GitHub 标签：

| 条件 | 建议标签 |
|------|----------|
| Dialect = Moore | `Moore` |
| Dialect = FIRRTL | `FIRRTL` |
| crash_type = assertion | `crash` |
| 来自 fuzzing | `found-by-fuzzing` |
| validation = feature_request | `enhancement` |

## 注意事项

1. **敏感信息**：确保测例不包含敏感信息
2. **最小化**：测例应该是最小化的
3. **可复现**：确保复现命令可以直接执行
4. **格式化**：代码块使用正确的语言标识
5. **折叠**：长内容（如 stack trace）使用折叠
6. **链接**：相关 Issue 使用 # 引用
7. **标题**：不要在标题中包含文件路径或哈希值
