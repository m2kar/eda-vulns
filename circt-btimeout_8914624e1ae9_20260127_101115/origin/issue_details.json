{
  "9469": {
    "body": "## [circt-verilog][arcilator] Inconsistent compilation behavior: direct array indexing in always_ff sensitivity list vs. intermediate wire\n\n## Summary\nI encountered an inconsistent compilation behavior in the arcilator flow when using synchronous reset with SystemVerilog array indexing. When directly using array indices (`clkin_data[0]` and `clkin_data[32]`) in an `always_ff` block, the compilation fails with an `llhd.constant_time` error. However, when the same signals are first assigned to intermediate wires and then used in the `always_ff` block, the compilation succeeds. This suggests a potential issue in how `circt-verilog` handles array indexing in sensitivity lists.\n\n## Problem Description\n\nThe SystemVerilog design uses a 64-bit input `clkin_data` where:\n- `clkin_data[0]` is used as the clock signal\n- `clkin_data[32]` is used as the reset signal (active low)\n\nTwo semantically equivalent approaches to implement synchronous reset logic produce different compilation results:\n\n**Solution 1** - Direct array indexing (compilation fails\u274c):\n```systemverilog\nalways_ff @(posedge clkin_data[0])\n  if (!clkin_data[32]) _00_ <= 6'h00;\n  else _00_ <= in_data[7:2];\n```\n\n**Solution 2** - Intermediate wires (compilation succeeds\u2705):\n```systemverilog\nwire clkin_0 = clkin_data[0];\nwire rst = clkin_data[32];\nalways_ff @(posedge clkin_0) begin\n  if (!rst) _00_ <= 6'h00;\n  else _00_ <= in_data[7:2];\nend\n```\n\nBoth solutions implement identical synchronous reset logic, but Solution 1 fails during the `circt-verilog --ir-hw` to `arcilator` conversion pipeline with an `llhd.constant_time` error. From a SystemVerilog semantics perspective, these two approaches should be equivalent. The compilation failure in Solution 1 appears to be a tool limitation rather than a semantic difference.\n\n## Reproduction\n\n**Note:** The test cases described below (`top1.sv` and `top2.sv`) are simplified versions that isolate the core issue. The original complete test case was generated by Yosys and includes additional combinational logic (folding blocks). The full original test case is provided in the [Original Complete Test Case](#original-complete-test-case) section below.\n\n### Solution 1: Direct Array Indexing (Fails)\n\nCreate `top1.sv`:\n```systemverilog\nmodule top_arc(clkin_data, in_data, out_data);\n  reg [5:0] _00_;\n  input [63:0] clkin_data;\n  wire [63:0] clkin_data;\n  input [191:0] in_data;\n  wire [191:0] in_data;\n  output [191:0] out_data;\n  wire [191:0] out_data;\n\n  always_ff @(posedge clkin_data[0])\n    if (!clkin_data[32]) _00_ <= 6'h00;\n    else _00_ <= in_data[7:2];\nendmodule\n```\n\nCompile with:\n```bash\ncirct-verilog --ir-hw top1.sv | arcilator --state-file=top1.json | opt -O3 --strip-debug -S | llc -O3 --filetype=obj -o top1.o\n```\n\n**Result:** \u274c Compilation fails with the following error:\n```\n<stdin>:5:10: error: failed to legalize operation 'llhd.constant_time' that was explicitly marked illegal\n    %0 = llhd.constant_time <0ns, 0d, 1e>\n         ^\n<stdin>:5:10: note: see current operation: %2 = \"llhd.constant_time\"() <{value = #llhd.time<0ns, 0d, 1e>}> : () -> !llhd.time\n<stdin>:1:1: error: conversion to arcs failed\n```\n\n**Note:** The error occurs when piping the output directly from `circt-verilog` to `arcilator`, so the error location shows `<stdin>` instead of a file name. The error happens during the `arcilator` conversion phase.\n\n### Solution 2: Intermediate Wires (Succeeds)\n\nCreate `top2.sv`:\n```systemverilog\nmodule top_arc(clkin_data, in_data, out_data);\n  reg [5:0] _00_;\n  input [63:0] clkin_data;\n  wire [63:0] clkin_data;\n  input [191:0] in_data;\n  wire [191:0] in_data;\n  output [191:0] out_data;\n  wire [191:0] out_data;\n\n  wire clkin_0 = clkin_data[0];\n  wire rst = clkin_data[32];\n  always_ff @(posedge clkin_0) begin\n    if (!rst) _00_ <= 6'h00;\n    else _00_ <= in_data[7:2];\n  end\nendmodule\n```\n\nCompile with:\n```bash\ncirct-verilog --ir-hw top2.sv | arcilator --state-file=top2.json | opt -O3 --strip-debug -S | llc -O3 --filetype=obj -o top2.o\n```\n\n**Result:** \u2705 Compilation succeeds, generates `top2.o` and `top2.json`\n\n## Expected Result\n\nBoth Solution 1 and Solution 2 should compile successfully since they are semantically equivalent. The direct use of array indices in sensitivity lists should be supported, or at minimum, a clear error message should indicate that intermediate wires are required.\n\n## Analysis of Failure Cause\n\nBased on the error message, the failure occurs during the conversion from LLHD to arcs:\n\n1. **Solution 1** generates `llhd.constant_time` operations when array indices are used directly in the sensitivity list\n2. The `ConvertToArcs` pass marks `llhd.constant_time` as illegal and does not provide a legalization pattern\n3. **Solution 2** avoids this issue by using intermediate wires, which apparently results in a different LLHD representation that does not generate `llhd.constant_time` operations\n\nThe root cause appears to be in how `circt-verilog` handles array indexing in sensitivity lists. When array indices are used directly, it may be generating timing-related operations (`llhd.constant_time`) that are not supported by the arcilator pipeline. Using intermediate wires changes the IR representation in a way that avoids these problematic operations.\n\n## Questions\n\n1. Why does direct array indexing in sensitivity lists generate `llhd.constant_time` operations?\n2. Is this a known limitation, or should it be considered a bug?\n3. Should `circt-verilog` be able to handle direct array indexing in sensitivity lists, or is using intermediate wires the recommended approach?\n4. If intermediate wires are required, should the compiler provide a clearer error message or automatically insert them?\n\n## Environment\n\n- OS: Linux 5.15.0-164-generic\n- CIRCT: firtool-1.139.0 (or current development version)\n- LLVM: 22.0.0git\n\n## Original Complete Test Case\n\n<details>\n<summary>Original Complete Test Case</summary>\n\nThe original test case was generated by Yosys and includes the problematic `always_ff` block along with additional combinational logic (folding blocks). The complete file is shown below:\n\n```systemverilog\n/* Generated by Yosys 0.37+29 (git sha1 3c3788ee2, clang 18.1.3 -fPIC -Os) */\n\nmodule top(clkin_data, in_data, out_data);\n  reg [5:0] _00_;\n  wire celloutsig_0_0z;\n  reg [2:0] celloutsig_0_2z;\n  wire [3:0] celloutsig_0_3z;\n  wire celloutsig_0_4z;\n  wire celloutsig_0_8z;\n  wire celloutsig_0_9z;\n  wire celloutsig_1_0z;\n  wire celloutsig_1_10z;\n  wire celloutsig_1_11z;\n  wire [2:0] celloutsig_1_13z;\n  wire celloutsig_1_14z;\n  wire [2:0] celloutsig_1_15z;\n  wire celloutsig_1_18z;\n  wire [3:0] celloutsig_1_19z;\n  wire celloutsig_1_1z;\n  wire celloutsig_1_2z;\n  wire celloutsig_1_4z;\n  wire [26:0] celloutsig_1_5z;\n  wire celloutsig_1_6z;\n  wire [2:0] celloutsig_1_7z;\n  wire [13:0] celloutsig_1_8z;\n  wire celloutsig_1_9z;\n  input [63:0] clkin_data;\n  wire [63:0] clkin_data;\n  input [191:0] in_data;\n  wire [191:0] in_data;\n  output [191:0] out_data;\n  wire [191:0] out_data;\n  assign celloutsig_1_9z = ~celloutsig_1_1z;\n  assign celloutsig_1_2z = celloutsig_1_1z | celloutsig_1_0z;\n  assign celloutsig_1_4z = celloutsig_1_0z | celloutsig_1_2z;\n  \n\n  // Original approach (async reset, not supported by Arcilator)\n  // \u274c Compilation fails\n  always_ff @(posedge clkin_data[0], negedge clkin_data[32])\n    if (!clkin_data[32]) _00_ <= 6'h00;\n    else _00_ <= in_data[7:2];\n  /*\n  Compile Error Log:\n\n  top_arc.mlir:6:10: error: failed to legalize operation 'llhd.constant_time' that was explicitly marked illegal\n    %0 = llhd.constant_time <0ns, 1d, 0e>\n         ^\ntop_arc.mlir:6:10: note: see current operation: %3 = \"llhd.constant_time\"() <{value = #llhd.time<0ns, 1d, 0e>}> : () -> !llhd.time\ntop_arc.mlir:1:1: error: conversion to arcs failed\n   */\n\n  // Note: Arcilator is a cycle-accurate simulator that only supports synchronous reset\n  // True async reset semantics (reset signal takes effect immediately on falling edge) cannot be achieved\n  // However, we can approximate async reset behavior through the following approaches:\n  // 1. Check reset signal on clock rising edge, clear immediately if reset is low\n  // 2. Reset signal must be stable at clock rising edge (meet setup/hold time requirements)\n  // 3. Reset response delay is at most one clock cycle (main difference between sync and async reset)\n\n  // Solution 1 (synchronous reset, Arcilator compatible)\n  // \u274c Compilation fails\n  always_ff @(posedge clkin_data[0])\n    // Check reset signal on clock rising edge\n    if (!clkin_data[32]) _00_ <= 6'h00;\n    else _00_ <= in_data[7:2];\n   /*\n  Compile Error Log:\n\n  top_arc.mlir:6:10: error: failed to legalize operation 'llhd.constant_time' that was explicitly marked illegal\n    %0 = llhd.constant_time <0ns, 1d, 0e>\n         ^\ntop_arc.mlir:6:10: note: see current operation: %3 = \"llhd.constant_time\"() <{value = #llhd.time<0ns, 1d, 0e>}> : () -> !llhd.time\ntop_arc.mlir:1:1: error: conversion to arcs failed\n   */\n  \n\n  // Solution 2 (synchronous reset, Arcilator compatible)\n  // \u2705 Compilation succeeds\n\n  // Define additional clock and reset wires\n  wire clkin_0 = clkin_data[0];\n  wire rst = clkin_data[32];\n  \n  always_ff @(posedge clkin_0) begin\n    // Check reset signal on clock rising edge\n    if (!rst) _00_ <= 6'h00;\n    else _00_ <= in_data[7:2];\n  end\n\n\n\n  assign celloutsig_0_3z = { celloutsig_0_0z, celloutsig_0_2z } & { celloutsig_0_2z[0], celloutsig_0_2z };\n  assign celloutsig_1_1z = in_data[185:171] && { in_data[181:170], celloutsig_1_0z, celloutsig_1_0z, celloutsig_1_0z };\n  assign celloutsig_0_0z = ! in_data[82:51];\n  assign celloutsig_0_4z = ! { celloutsig_0_3z[3:2], celloutsig_0_0z, celloutsig_0_3z, celloutsig_0_0z, celloutsig_0_2z, _00_ };\n  assign celloutsig_1_10z = celloutsig_1_5z[22:8] < celloutsig_1_5z[15:1];\n  assign celloutsig_1_19z = { celloutsig_1_7z, celloutsig_1_18z } % { 1'h1, celloutsig_1_13z };\n  assign celloutsig_1_7z = { celloutsig_1_2z, celloutsig_1_0z, celloutsig_1_2z } * in_data[172:170];\n  assign celloutsig_1_13z = in_data[139] ? { celloutsig_1_8z[13:12], celloutsig_1_0z } : celloutsig_1_7z;\n  assign celloutsig_0_9z = { in_data[78:61], celloutsig_0_0z, celloutsig_0_3z } !== { in_data[77:56], celloutsig_0_8z };\n  assign celloutsig_1_6z = celloutsig_1_0z & celloutsig_1_5z[26];\n  assign celloutsig_1_18z = | celloutsig_1_15z;\n  assign celloutsig_1_14z = ^ { celloutsig_1_11z, celloutsig_1_0z, celloutsig_1_6z, celloutsig_1_6z };\n  assign celloutsig_1_8z = { celloutsig_1_5z[18:8], celloutsig_1_2z, celloutsig_1_0z, celloutsig_1_6z } >>> { in_data[116:112], celloutsig_1_7z, celloutsig_1_0z, celloutsig_1_6z, celloutsig_1_0z, celloutsig_1_2z, celloutsig_1_1z, celloutsig_1_4z };\n  assign celloutsig_1_15z = { celloutsig_1_14z, celloutsig_1_9z, celloutsig_1_11z } - { celloutsig_1_13z[1:0], celloutsig_1_0z };\n  assign celloutsig_1_5z = { in_data[162:145], celloutsig_1_4z, celloutsig_1_0z, celloutsig_1_0z, celloutsig_1_2z, celloutsig_1_0z, celloutsig_1_0z, celloutsig_1_4z, celloutsig_1_2z, celloutsig_1_1z } ~^ in_data[134:108];\n  assign celloutsig_0_8z = ~((celloutsig_0_0z & celloutsig_0_4z) | celloutsig_0_4z);\n  assign celloutsig_1_0z = ~((in_data[134] & in_data[145]) | in_data[182]);\n  always_latch\n    if (!clkin_data[32]) celloutsig_0_2z = 3'h0;\n    else if (!celloutsig_1_18z) celloutsig_0_2z = in_data[83:81];\n  assign celloutsig_1_11z = ~((celloutsig_1_10z & celloutsig_1_9z) | (celloutsig_1_4z & celloutsig_1_6z));\n  assign { out_data[128], out_data[99:96], out_data[32], out_data[0] } = { celloutsig_1_18z, celloutsig_1_19z, celloutsig_0_8z, celloutsig_0_9z };\nendmodule\n```\n\nThis complete test case demonstrates the same issue: when using direct array indexing (`clkin_data[0]` and `clkin_data[32]`) in the `always_ff` sensitivity list, the compilation fails. The additional combinational logic (folding blocks) does not affect the core issue but provides a more realistic test case scenario.\n</details>\n\n## Notes\n\n- The error occurs during the `arcilator` conversion phase when processing the LLHD IR generated by `circt-verilog --ir-hw`\n- The same pattern (direct array indexing vs. intermediate wires) may affect other SystemVerilog constructs beyond `always_ff` blocks\n- This issue is related to but distinct from issue #9467 , which deals with `#1` delays generating `llhd.constant_time` operations\n\n",
    "closedAt": "2026-01-25T05:13:52Z",
    "createdAt": "2026-01-18T08:04:02Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMTY1NDc5NTk1",
        "name": "LLHD",
        "description": "",
        "color": "e07b00"
      },
      {
        "id": "LA_kwDODpuCgs8AAAABNapjiA",
        "name": "Arc",
        "description": "Involving the `arc` dialect",
        "color": "bfd4f2"
      }
    ],
    "number": 9469,
    "state": "CLOSED",
    "title": "[circt-verilog][arcilator] Inconsistent compilation behavior: direct array indexing in always_ff sensitivity list vs. intermediate wire"
  },
  "9467": {
    "body": "## Title\n[circt-verilog][arcilator] `arcilator` fails to lower `llhd.constant_time` generated from simple SV delay (`#1`)\n\n## Summary\nI ran into a failure in the arcilator flow with a minimal SystemVerilog module using a single `#1` delay. The same design runs under Verilator, but arcilator reports `llhd.constant_time` as illegal during conversion to `arcs` and stops. I did a preliminary source-level analysis (below) and would like to discuss with maintainers whether this behavior is expected or should be treated as a bug.\n\n## Details\n\nThe SV design is intentionally minimal and only uses an `initial` block with a\nsingle `#1` delay. There are no clocks, resets, or inputs. The only signals are\ntwo outputs (`q` and `ok`) to indicate observable state and a success message.\n\nBehavior:\n- At time 0, both `q` and `ok` are set to `0`.\n- After `#1`, `q` is set to `1`, `ok` is set to `1`, and a `$display` message is\n  printed.\n\nObserved issue:\n- `circt-verilog --ir-hw` converts the `#1` delay into `llhd.constant_time`.\n- The arcilator pipeline then fails when lowering to `arcs`, reporting that\n  `llhd.constant_time` is illegal and the conversion fails.\n- The same SV code runs successfully under Verilator, so the issue appears\n  specific to the arcilator lowering path.\n\n\n## Reproduction\n### arcilator\nCreate `top.sv`:\n```systemverilog\nmodule top(output logic q, output logic ok);\n  initial begin\n    q = 1'b0;\n    ok = 1'b0;\n    #1 q = 1'b1;\n    ok = 1'b1;\n    $display(\"OK: arcilator run completed\");\n  end\nendmodule\n```\n\nRun:\n```bash\ncirct-verilog --ir-hw top.sv -o top.mlir\narcilator top.mlir --state-file=top.json | opt -O3 --strip-debug -S | llc -O3 --filetype=obj -o top.o\ncc top.o -o top\n./top\n```\n\n### verilator\nUse the same `top.sv` content as above.\n\nRun:\n```bash\nverilator -Wall --cc top.sv --exe sim_main.cpp\nmake -C obj_dir -f Vtop.mk Vtop\n./obj_dir/Vtop\n```\n\n## Actual Result (arcilator)\n```\ntop.mlir:4:10: error: failed to legalize operation 'llhd.constant_time' that was explicitly marked illegal\n    %0 = llhd.constant_time <1000000fs, 0d, 0e>\n         ^\ntop.mlir:1:1: error: conversion to arcs failed\nmodule {\n^\n```\n\n## Expected Result\nThe minimal delay should either:\n- be supported by arcilator, or\n- be lowered to something legal for `arcs` without failing.\n\n### Question:\nHow to solve this problem and simulate this sv problem?\n\n## Analysis of Failure Cause\nBased on the current sources, my preliminary analysis is that the failure stems from a missing legalization pattern in the `ConvertToArcs` pass:\n- `llhd.constant_time` is a valid LLHD op produced by `circt-verilog --ir-hw` for `#1` delays.\n- The arcilator pipeline runs `ConvertToArcs`, which marks the entire LLHD dialect illegal and only provides conversions for `llhd.combinational` and `llhd.yield`.\n\nhttps://github.com/llvm/circt/blob/3c58046f1d8fc6f5355a7f2c2b73b43ffb37ba4d/lib/Conversion/ConvertToArcs/ConvertToArcs.cpp#L567-L585\n\n- As a result, `llhd.constant_time` remains illegal with no rewrite available, and the dialect conversion reports a legalization failure.\n\n\n## Environment\n- OS: Linux 5.15.0-164-generic\n- CIRCT: firtool-1.139.0\n- LLVM: 22.0.0git\n- Verilator: 5.022 2024-02-24 (rev v5.020-157-g2b4852048)\n- Git commit: 2e2f4775452d1e0bb2c8075d845808f781268049\n\n## Notes\nThe failure appears at the `llhd.constant_time` op introduced during `circt-verilog --ir-hw`, before `arcilator` lowers to `arcs`.\n\n## Relevant Source References\n- `llhd.constant_time` is a core LLHD op that materializes a time constant. It is defined as `llhd.constant_time` in the LLHD value ops definition file. See `include/circt/Dialect/LLHD/IR/LLHDValueOps.td`.\n- The `ConvertToArcs` pass marks the entire LLHD dialect as illegal and only provides conversion patterns for `llhd.combinational` and `llhd.yield`. This means any other LLHD ops (including `llhd.constant_time`) remain illegal and will trigger a legalization failure. See `lib/Conversion/ConvertToArcs/ConvertToArcs.cpp`.\n- The arcilator pipeline explicitly runs `ConvertToArcs` as part of its arc conversion pipeline. See `lib/Tools/arcilator/pipelines.cpp`.\n",
    "closedAt": null,
    "createdAt": "2026-01-17T18:13:38Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMTY1NDc5NTk1",
        "name": "LLHD",
        "description": "",
        "color": "e07b00"
      },
      {
        "id": "LA_kwDODpuCgs8AAAABNapjiA",
        "name": "Arc",
        "description": "Involving the `arc` dialect",
        "color": "bfd4f2"
      }
    ],
    "number": 9467,
    "state": "OPEN",
    "title": "[circt-verilog][arcilator] `arcilator` fails to lower `llhd.constant_time` generated from simple SV delay (`#1`)"
  },
  "9395": {
    "body": "Hi, all! Let's look at this example on _Verilog_:\n\n```\nmodule comb_assert(\n    input wire clk,\n    input wire resetn\n);\n    always @* begin\n        if (resetn) begin\n            assert (0);\n        end\n    end\nendmodule\n```\nWhen we process this using _circt-verilog_ and _arcilator_:\n\n`circt-verilog test.v | arcilator`\n\nwe get the following internal _MLIR_ assertion failure: \n\n```\narcilator: /home/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:2230: void mlir::ConversionPatternRewriter::replaceUsesWithIf(mlir::Value, mlir::ValueRange, mlir::function_ref<bool(mlir::OpOperand&)>, bool*): Assertion `!allUsesReplaced && \"allUsesReplaced is not supported in a dialect conversion\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace and instructions to reproduce the bug.\nStack dump:\n0.\tProgram arguments: ./build/bin/arcilator comb_assert.mlir --state-file comb_assert.json -o comb_assert.ll\n #0 0x00005888f6a8a262 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (./build/bin/arcilator+0x3ac262)\n #1 0x00005888f6a86f5f llvm::sys::RunSignalHandlers() (./build/bin/arcilator+0x3a8f5f)\n #2 0x00005888f6a870ac SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x0000732c30c45330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #4 0x0000732c30c9eb2c __pthread_kill_implementation ./nptl/pthread_kill.c:44:76\n #5 0x0000732c30c9eb2c __pthread_kill_internal ./nptl/pthread_kill.c:78:10\n #6 0x0000732c30c9eb2c pthread_kill ./nptl/pthread_kill.c:89:10\n #7 0x0000732c30c4527e raise ./signal/../sysdeps/posix/raise.c:27:6\n #8 0x0000732c30c288ff abort ./stdlib/abort.c:81:7\n #9 0x0000732c30c2881b _nl_load_domain ./intl/loadmsgcat.c:1177:9\n#10 0x0000732c30c3b517 (/lib/x86_64-linux-gnu/libc.so.6+0x3b517)\n#11 0x00005888fab6c9c5 (./build/bin/arcilator+0x448e9c5)\n#12 0x00005888fab899b7 mlir::ConversionPatternRewriter::replaceUsesWithIf(mlir::Value, mlir::Value, llvm::function_ref<bool (mlir::OpOperand&)>, bool*) (./build/bin/arcilator+0x44ab9b7)\n#13 0x00005888fb6bd3f5 mlir::RewriterBase::replaceUsesWithIf(mlir::ValueRange, mlir::ValueRange, llvm::function_ref<bool (mlir::OpOperand&)>, bool*) (./build/bin/arcilator+0x4fdf3f5)\n#14 0x00005888fabb5c21 mlir::makeRegionIsolatedFromAbove(mlir::RewriterBase&, mlir::Region&, llvm::function_ref<bool (mlir::Operation*)>) (./build/bin/arcilator+0x44d7c21)\n#15 0x00005888f71de7a5 convert(circt::llhd::CombinationalOp, circt::llhd::CombinationalOpAdaptor, mlir::ConversionPatternRewriter&, mlir::TypeConverter const&) /home/circt/lib/Conversion/ConvertToArcs/ConvertToArcs.cpp:537:24\n#16 0x00005888f71e40f0 circt::ConversionPatternSet& circt::ConversionPatternSet::add<circt::llhd::CombinationalOp>(llvm::LogicalResult (*)(circt::llhd::CombinationalOp, circt::llhd::CombinationalOp::Adaptor, mlir::ConversionPatternRewriter&, mlir::TypeConverter const&))::FnPattern::matchAndRewrite(circt::llhd::CombinationalOp, circt::llhd::CombinationalOpAdaptor, mlir::ConversionPatternRewriter&) const /home/circt/include/circt/Support/ConversionPatternSet.h:72:16\n#17 0x00005888f71f331f llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::llhd::CombinationalOp>, circt::llhd::CombinationalOp>(mlir::OpConversionPattern<circt::llhd::CombinationalOp> const&, circt::llhd::CombinationalOp, circt::llhd::CombinationalOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) /home/circt/llvm/mlir/include/mlir/Transforms/DialectConversion.h:1069:30\n#18 0x00005888f71f2c46 mlir::OpConversionPattern<circt::llhd::CombinationalOp>::matchAndRewrite(circt::llhd::CombinationalOp, circt::llhd::CombinationalOpGenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) const /home/circt/llvm/mlir/include/mlir/Transforms/DialectConversion.h:727:26\n#19 0x00005888f71f2bb4 mlir::OpConversionPattern<circt::llhd::CombinationalOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const /home/circt/llvm/mlir/include/mlir/Transforms/DialectConversion.h:713:27\n#20 0x00005888fab9169e mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (./build/bin/arcilator+0x44b369e)\n#21 0x00005888fabd8ef3 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::'lambda'()::operator()() const PatternApplicator.cpp:0:0\n#22 0x00005888fabda49f mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (./build/bin/arcilator+0x44fc49f)\n#23 0x00005888fab8bf7c (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*) DialectConversion.cpp:0:0\n#24 0x00005888fab8c444 mlir::OperationConverter::convert(mlir::Operation*, bool) (./build/bin/arcilator+0x44ae444)\n#25 0x00005888fab95df6 mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (./build/bin/arcilator+0x44b7df6)\n#26 0x00005888fab9861b applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode) DialectConversion.cpp:0:0\n#27 0x00005888fab987bf mlir::applyPartialConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (./build/bin/arcilator+0x44ba7bf)\n#28 0x00005888f71dee91 (anonymous namespace)::ConvertToArcsPass::runOnOperation() /home/circt/lib/Conversion/ConvertToArcs/ConvertToArcs.cpp:594:13\n#29 0x00005888fac4e13e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (./build/bin/arcilator+0x457013e)\n#30 0x00005888fac4e5be mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (./build/bin/arcilator+0x45705be)\n#31 0x00005888fac4ed32 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) (./build/bin/arcilator+0x4570d32)\n#32 0x00005888fac4ff50 mlir::PassManager::run(mlir::Operation*) (./build/bin/arcilator+0x4571f50)\n#33 0x00005888f699ef42 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/circt/tools/arcilator/arcilator.cpp:330:13\n#34 0x00005888f69a0525 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/circt/tools/arcilator/arcilator.cpp:546:25\n#35 0x00005888f69a06ee processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/circt/tools/arcilator/arcilator.cpp:562:29\n#36 0x00005888f69a0a6e executeArcilator(mlir::MLIRContext&) /home/circt/tools/arcilator/arcilator.cpp:629:13\n#37 0x00005888f69a0ce7 main /home/circt/tools/arcilator/arcilator.cpp:692:33\n#38 0x0000732c30c2a1ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#39 0x0000732c30c2a28b call_init ./csu/../csu/libc-start.c:128:20\n#40 0x0000732c30c2a28b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#41 0x00005888f699e505 _start (./build/bin/arcilator+0x2c0505)\n```\n",
    "closedAt": "2026-01-19T11:24:22Z",
    "createdAt": "2025-12-29T16:25:43Z",
    "labels": [
      {
        "id": "LA_kwDODpuCgs8AAAABNapjiA",
        "name": "Arc",
        "description": "Involving the `arc` dialect",
        "color": "bfd4f2"
      },
      {
        "id": "LA_kwDODpuCgs8AAAABp1j0gg",
        "name": "ImportVerilog",
        "description": "",
        "color": "e99695"
      }
    ],
    "number": 9395,
    "state": "CLOSED",
    "title": "[circt-verilog][arcilator] Arcilator assertion failure"
  },
  "9057": {
    "body": "Hello, I'm having an issue when trying to import Verilog generated with Yosys. It leads into a combinatorial cycle that isn't present in the Verilog program.\nHere is a simple example of problematic Verilog:\n```sv\nmodule outline_control_3(output [1:0] result, input arg0);\n  assign result[1] = arg0;\n  assign result[0] = result[1];\nendmodule\n```\nWhen I import the Verilog into Moore with `./circt-translate --import-verilog test.sv` it generates the following program:\n```mlir\nmodule {\n  moore.module @outline_control_3(out result : !moore.l2, in %arg0 : !moore.l1) {\n    %result = moore.net wire : <l2>\n    %arg0_0 = moore.net name \"arg0\" wire : <l1>\n    %0 = moore.extract_ref %result from 1 : <l2> -> <l1>\n    %1 = moore.read %arg0_0 : <l1>\n    moore.assign %0, %1 : l1\n    %2 = moore.extract_ref %result from 0 : <l2> -> <l1>\n    %3 = moore.read %result : <l2>\n    %4 = moore.extract %3 from 1 : l2 -> l1\n    moore.assign %2, %4 : l1\n    %5 = moore.read %result : <l2>\n    moore.assign %arg0_0, %arg0 : l1\n    moore.output %5 : !moore.l2\n  }\n}\n```\nBut then, when I lower it into the comb/HW dialects with `./circt-translate --import-verilog test.sv | ./circt-opt --moore-lower-concatref --canonicalize --cse --convert-moore-to-core --llhd-sig2reg --canonicalize --cse`. It generates the following program:\n```mlir\nmodule {\n  hw.module @outline_control_3(out result : i2, in %arg0 : i1) {\n    %false = hw.constant false\n    %0 = comb.concat %false, %3 : i1, i1\n    %1 = comb.concat %arg0, %false : i1, i1\n    %2 = comb.or %1, %0 : i2\n    %3 = comb.extract %2 from 1 : (i2) -> i1\n    hw.output %2 : i2\n  }\n}\n```\nMy problem here is that `%3` depends on `%2`, which in turn depends on `%0`, which also depends on `%3`. As the hw.module contains a `graph` region, it doesn't seem to be an invalid MLIR program. But is it the expected behavior? There is a combinatorial cycle that wasn't present in the imported Verilog.",
    "closedAt": "2026-01-15T23:45:26Z",
    "createdAt": "2025-10-06T12:22:11Z",
    "labels": [
      {
        "id": "LA_kwDODpuCgs8AAAABp1j0gg",
        "name": "ImportVerilog",
        "description": "",
        "color": "e99695"
      }
    ],
    "number": 9057,
    "state": "CLOSED",
    "title": "[MooreToCore] Unexpected topological cycle after importing generated verilog"
  },
  "8286": {
    "body": "Hi all!\n\nThere are a few issues related to moore to llvm lowering pipeline.\n\nCurrently there is no possibility to lower combination logic with control flow operators into LLVM. For example:\n\n```verilog\nmodule  top  (\n    input           clk ,\n    input           rstn ,\n    input      in\n    output     out\n    );\n\n    parameter            P1   = 3'd0 ;\n    parameter            P2  = 3'd3 ;\n\n    reg [2:0]            r1 = 3'd1;\n\n    always_comb begin\n        if (in)\n            r1 = P1;\n        else\n            r1 = P2;\n    end\nendmodule\n```\n\nbecause it fails with this : `error: failed to legalize operation 'llhd.constant_time'`\n\nAnd also `arcilator` fails to lower sequential logic which contains both blocking and nonblocking assignments like this example:\n\n```verilog\nmodule  top  (\n    input           clk ,\n    input           rstn ,\n    input      in\n    output     out\n    );\n\n    parameter            P1   = 3'd0 ;\n    parameter            P2  = 3'd3 ;\n\n    reg [2:0]            r1 = 3'd1;\n\n    always @(posedge clk or negedge rstn) begin\n        r1 = P1;\n        r1 <= P2 + r1;\n    end\n\nendmodule\n```\n\nbecause it fails with that:\n\n```\n error: body contains non-pure operation\n    %2 = comb.add %1, %c3_i3 : i3\n```\n\nI'm using to lower a such cmd:\n\n```\ncirct-verilog sample.sv | arcilator \n```\n\nAlso I tried to add into \"populate LLHD\" pipeline a newly added passes  -- \"llhd-hoist-signals\" and \"llhd-mem2reg\". It didn't help.\n\nMaybe I'm doing something wrong or what could be the issue?\n\n1) What are the plans for improving verilog-to-llvm lowering  and do they exist at all?\n2) Will the \"llhd-hoist-signals\" and \"llhd-mem2reg\" passes be added to the `circt-verilog` tool or will they stay standalone?\n\n@fabianschuiki @maerhart ",
    "closedAt": null,
    "createdAt": "2025-03-03T10:23:03Z",
    "labels": [],
    "number": 8286,
    "state": "OPEN",
    "title": "[circt-verilog][llhd][arcilator] Verilog-to-LLVM lowering issues"
  }
}