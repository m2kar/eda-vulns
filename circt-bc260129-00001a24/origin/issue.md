<!-- 
  CIRCT Bug Report
  Generated by circt-bug-reporter skill
-->

<!-- Title: [LLHD] Assertion failure in Mem2Reg pass when processing real type in always_ff block -->

## Description

CIRCT crashes with an assertion failure when processing SystemVerilog code that uses the `real` (floating-point) type in sequential logic (`always_ff` blocks). The LLHD Mem2Reg pass attempts to create an IntegerType with a bitwidth of 1,073,741,823 bits (0x40000000 = 1GiB) when handling floating-point types, which exceeds MLIR's built-in limit of 16,777,215 bits.

The root cause is that `hw::getBitWidth()` returns an invalid sentinel value for floating-point types, and the Mem2Reg pass unconditionally tries to create an IntegerType with this bitwidth without checking if the type is actually an integer type.

**Crash Type**: assertion
**Dialect**: LLHD
**Failing Pass**: Mem2Reg

## Steps to Reproduce

1. Save the test case below as `test.sv`
2. Run:
   ```bash
   export PATH=/edazz/FeatureFuzz-SV/target/circt-1.139.0/bin:$PATH
   circt-verilog test.sv --ir-hw
   ```

## Test Case

```systemverilog
module bug(
  input real in_real,
  input logic clk,
  output real out_real
);

  always_ff @(posedge clk) begin
    out_real <= in_real * 0.9;
  end

endmodule
```

## Error Output

```
<unknown>:0: error: integer bitwidth is limited to 16777215 bits
circt-verilog: /home/zhiqing/edazz/FeatureFuzz-SV/target/circt-1.139.0-src/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:180: static ConcreteT mlir::detail::StorageUserBase<mlir::IntegerType, mlir::Type, mlir::detail::IntegerTypeStorage, mlir::detail::TypeUniquer, mlir::VectorElementTypeInterface::Trait>::get(MLIRContext *, Args &&...) [ConcreteT = mlir::IntegerType, BaseT = mlir::Type, StorageT = mlir::detail::IntegerTypeStorage, UniquerT = mlir::detail::TypeUniquer, Traits = <mlir::VectorElementTypeInterface::Trait>, Args = <unsigned int &, mlir::IntegerType::SignednessSemantics &>]: Assertion `succeeded( ConcreteT::verifyInvariants(getDefaultDiagnosticEmitFn(ctx), args...))' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: circt-verilog test.sv --ir-hw
 #0 0x000055e46a8c032f llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/zhiqing/edazz/FeatureFuzz-SV/target/circt-1.139.0-src/llvm/llvm/lib/Support/Unix/Signals.inc:842:13
 #1 0x000055e46a8c12e9 llvm::sys::RunSignalHandlers() /home/zhiqing/edazz/FeatureFuzz-SV/target/circt-1.139.0-src/llvm/llvm/lib/Support/Signals.cpp:109:18
...
#13 0x000055e469185429 (anonymous namespace)::Promoter::insertBlockArgs((anonymous namespace)::BlockEntry*) /home/zhiqing/edazz/FeatureFuzz-SV/target/circt-1.139.0-src/lib/Dialect/LLHD/Transforms/Mem2Reg.cpp:1742:35
 #14 0x000055e469185429 (anonymous namespace)::Promoter::insertBlockArgs() /home/zhiqing/edazz/FeatureFuzz-SV/target/circt-1.139.0-src/lib/Dialect/LLHD/Transforms/Mem2Reg.cpp:1654:28
 #15 0x000055e469185429 (anonymous namespace)::Promoter::promote() /home/zhiqing/edazz/FeatureFuzz-SV/target/circt-1.139.0-src/lib/Dialect/LLHD/Transforms/Mem2Reg.cpp:764:3
 #16 0x000055e46917d202 (anonymous namespace)::Mem2RegPass::runOnOperation() /home/zhiqing/edazz/FeatureFuzz-SV/target/circt-1.139.0-src/lib/Dialect/LLHD/Transforms/Mem2Reg.cpp:1844:34
```

## Root Cause Analysis

### Hypothesis 1 (High Confidence)
**Cause**: The LLHD Mem2Reg pass assumes all stored types can be represented as integers with a bitwidth. When encountering floating-point types (`f64`), `hw::getBitWidth()` returns an invalid/placeholder value (1,073,741,823 bits = 0x40000000), triggering MLIR assertion.

**Evidence**:
- Crash occurs specifically when calling `builder.getIntegerType(hw::getBitWidth(type))` at Mem2Reg.cpp:1742
- Bitwidth 1,073,741,823 (0x40000000) is a sentinel value indicating "not an integer type"
- SystemVerilog `real` type maps to MLIR's `Float64Type`, not an integer type
- No special handling exists in Mem2Reg.cpp for floating-point types before calling `getBitWidth()`
- The error message "hw.bitcast op result must be Type wherein the bitwidth in hardware is known, but got 'f64'" in newer versions confirms type issue

**Mechanism**:
1. `real` type is lowered to MLIR's `Float64Type` within a `RefType`
2. `hw::getBitWidth(f64)` is called, which has no meaningful result for floats
3. It likely returns a sentinel value (0x40000000 = 1GiB) to indicate "not an integer type"
4. Mem2Reg unconditionally tries to create `IntegerType` with this bitwidth
5. MLIR's type system rejects bitwidth > 16,777,215, causing assertion failure

## Environment

- **CIRCT Version**: LLVM version 22.0.0git
- **OS**: Linux
- **Architecture**: x86_64

## Stack Trace

<details>
<summary>Click to expand stack trace</summary>

```
 #0 0x000055e46a8c032f llvm::sys::PrintStackTrace(llvm::raw_ostream&, int)
 #1 0x000055e46a8c12e9 llvm::sys::RunSignalHandlers()
 #12 0x000055e469185429 mlir::IntegerType::get(mlir::MLIRContext*, unsigned int, mlir::IntegerType::SignednessSemantics) MLIRContext.cpp:1101:1
 #13 0x000055e469185429 (anonymous namespace)::Promoter::insertBlockArgs((anonymous namespace)::BlockEntry*) Mem2Reg.cpp:1742:35
 #14 0x000055e469185429 (anonymous namespace)::Promoter::insertBlockArgs() Mem2Reg.cpp:1654:28
 #15 0x000055e469185429 (anonymous namespace)::Promoter::promote() Mem2Reg.cpp:764:3
 #16 0x000055e46917d202 (anonymous namespace)::Mem2RegPass::runOnOperation() Mem2Reg.cpp:1844:34
```

</details>

## Related Issues

While this is a distinct bug, there are related issues about floating-point type support and bitwidth handling:

- [#9287](https://github.com/llvm/circt/issues/9287): [HW] Make `hw::getBitWidth` use std::optional vs -1 - Related to bitwidth calculation
- [#8269](https://github.com/llvm/circt/issues/8269): [MooreToCore] Support `real` constants - Related to real type support
- [#2667](https://github.com/llvm/circt/issues/2667): Support of IEEE single and double precision floating point operations - Related to floating-point support
- [#8693](https://github.com/llvm/circt/issues/8693): [Mem2Reg] Local signal does not dominate final drive - Related to Mem2Reg pass issues
- [#9013](https://github.com/llvm/circt/issues/9013): [circt-opt] Segmentation fault during XOR op building - Related to LLHD crashes

## Suggested Fix Directions

1. **Add float type check in Mem2Reg**: Before calling `hw::getBitWidth()`, check if the type is a floating-point type. If so, handle it specially (e.g., use floating-point constants or skip Mem2Reg optimization for those slots).

2. **Improve `hw::getBitWidth()` error handling**: Instead of returning an invalid sentinel value that causes assertion failures, return `None` or use `llvm::Expected` to explicitly indicate the type doesn't have a meaningful bitwidth.

3. **Update MLIR IntegerType limit**: While technically possible, increasing the limit from 16,777,215 bits is not the right fix - the real issue is attempting to represent floating-point types as integers.

4. **Document SystemVerilog `real` type support**: Clearly document whether `real` type is supported in sequential logic (`always_ff` blocks) in CIRCT.

## Labels

`LLHD` `crash` `found-by-fuzzing`
