# [LLHD][Moore] Timeout in canonicalize pass after llhd-sig2reg on partial struct field assignment

## Description

The CIRCT compiler times out (>300 seconds) when compiling SystemVerilog code containing partial struct field assignments in combinational logic blocks. The issue occurs in the `circt-verilog --ir-hw` pipeline, specifically in the canonicalize pass following the llhd-sig2reg transformation.

**Impact:** Any SystemVerilog code with partial packed struct field assignments in `always_comb` blocks that read different fields elsewhere can trigger this infinite loop, making a common coding pattern completely unusable with CIRCT.

**Severity:** High - This blocks compilation of valid, synthesizable SystemVerilog code.

### Problem Summary

When a packed struct variable has:
1. Only some fields assigned in an `always_comb` block
2. Other fields read in sequential or other combinational logic

The `llhd-sig2reg` pass generates malformed IR with circular SSA definitions (violating MLIR's SSA invariant). The subsequent `canonicalize` pass enters an infinite loop attempting to optimize these cyclic operations, causing a timeout.

---

## Steps to Reproduce

### Minimal Test Case

```systemverilog
module m(input clk);
  typedef struct packed {logic a, b;} s;
  s x;
  logic y;
  always_comb x.a = 0;
  always_ff @(posedge clk) y <= x.b;
endmodule
```

### Reproduction Commands

1. **Direct compilation (times out):**
   ```bash
   timeout 30s circt-verilog --ir-hw bug.sv
   ```
   Expected: Exit code 124 (timeout)

2. **Intermediate pipeline isolation:**
   ```bash
   circt-verilog --ir-llhd bug.sv | circt-opt --pass-pipeline='builtin.module(hw.module(llhd-sig2reg,cse,canonicalize))'
   ```
   This isolates the problematic pass sequence.

3. **Frontend validation (passes):**
   ```bash
   circt-verilog --ir-llhd bug.sv  # ✅ Generates valid LLHD IR
   ```

---

## Expected Behavior

The compiler should either:
1. Successfully lower the partial struct field assignment to valid HW IR, or
2. Emit a clear error message indicating unsupported code pattern

Instead, the compilation hangs indefinitely due to an infinite loop in the canonicalize pass.

---

## Actual Behavior

```
$ timeout 60s circt-verilog --ir-hw bug.sv
[Process hangs for 60 seconds and is killed by timeout]
Exit code: 124 (TIMEOUT)
```

The timeout occurs within the LLHD→HW lowering pipeline, specifically in the pass sequence:
```
llhd-sig2reg → cse → canonicalize
```

### Malformed IR Generated by llhd-sig2reg

After `llhd-sig2reg` and `cse`, the IR contains a circular SSA definition:

```mlir
%4 = hw.bitcast %7 : (!hw.struct<valid: i1, data: i8>) -> i9
%5 = hw.bitcast %4 : (i9) -> !hw.struct<valid: i1, data: i8>
%7 = hw.struct_inject %5["data"], %6 : !hw.struct<valid: i1, data: i8>
```

**Dependency cycle:** `%7 → %4 → %5 → %7`

This violates SSA form where each value must be defined before use. The canonicalize pass has no guard against circular definitions and enters an infinite loop.

---

## Environment

- **CIRCT version:** 1.139.0
- **Host OS:** Linux
- **Reproduction method:** timeout 30s circt-verilog --ir-hw bug.sv
- **SystemVerilog features used:** Packed structs, always_comb, always_ff, struct field access
- **Cross-tool validation:**
  - slang 10.0.6: ✅ PASS
  - verilator 5.022: ✅ PASS
  - CIRCT --ir-llhd: ✅ PASS (valid intermediate IR)
  - CIRCT --ir-hw: ❌ TIMEOUT

---

## Root Cause Analysis

### Mechanism

1. **Input Pattern:** A `always_comb` block assigns only one field of a packed struct (`x.a = 0`), while other code reads a different field (`y <= x.b`)

2. **LLHD Representation:** The always_comb is represented as:
   - `llhd.prb %x` - probe current struct value
   - `hw.struct_inject` - create new struct with modified field
   - `llhd.drv %x` - drive modified struct back

3. **llhd-sig2reg Bug:** When converting LLHD signals to HW registers, the pass creates a "read-modify-write" pattern:
   - It attempts to feed the struct's output back to create its own input
   - Instead of recognizing undriven fields as constants, it creates a circular SSA reference
   - The circular chain: `struct_inject(%5) → bitcast(%4) → bitcast(%7) → struct_inject(...)` 

4. **Canonicalize Failure:** The canonicalize pass lacks protection against circular SSA definitions:
   - Attempts to fold/simplify the cyclic operations infinitely
   - Cannot detect the cycle or break the optimization loop
   - Eventually hits timeout (300 seconds default)

### Root Cause

**The `llhd-sig2reg` pass in CIRCT 1.139.0 incorrectly handles partial struct field assignments:**
- When a packed struct has only some fields assigned in combinational logic and other fields read elsewhere
- The pass generates malformed IR with circular SSA definitions
- This violates MLIR's fundamental SSA invariant
- Downstream passes (canonicalize) hang trying to process invalid IR

### Related Components

- **Pass:** `llhd-sig2reg` (lib/Dialect/LLHD/Transforms/Sig2RegPass.cpp)
- **Dialect:** LLHD (LLHD dialect for hardware description)
- **Affected Operations:** `llhd.sig`, `llhd.drv`, `llhd.prb`, `hw.struct_inject`, `hw.struct_extract`, `hw.bitcast`
- **Related Passes:** `canonicalize`, `cse`

---

## Additional Context

### Validation Status

✅ **Valid Bug Report** - Confirmed by:
- Standard SystemVerilog syntax (accepted by slang and verilator)
- CIRCT's own LLHD IR generation works correctly
- Bug reproduces consistently
- Minimized to essential pattern (7 lines)

### Workarounds

Until this is fixed:
1. **Assign all struct fields:** Initialize all struct fields in the same `always_comb` block
   ```systemverilog
   always_comb begin
     x.a = 0;
     x.b = 1;  // Must assign all fields
   end
   ```

2. **Use separate signals:** Avoid packed structs, use individual logic signals:
   ```systemverilog
   logic a, b;
   always_comb a = 0;
   always_ff @(posedge clk) y <= b;
   ```

### Duplicate Check Results

This issue is **related to but distinct from** existing CIRCT issues:

**Most Similar:** Issue #9560 - [FIRRTL] Canonicalize infinite loop
- Same symptom: canonicalize entering infinite loop → timeout
- Same date reported (indicating systematic canonicalize stability issue)
- Different dialect: FIRRTL vs LLHD/Moore
- **Recommendation:** Review whether both are manifestations of canonicalize's inability to handle circular SSA definitions

**Related Issues (same canonicalize infinite loop problem):**
- #8865: [Comb] AddOp canonicalizer hangs in infinite loop (CLOSED)
- #8022: [Comb] OrOp folder infinite loop (OPEN)
- #8863: [Comb] Concat/extract canonicalizer crash on loop (OPEN)

**Related Issues (llhd-sig2reg + canonicalize pipeline failures):**
- #8065: [LLHD][Arc] Indexing/slicing lowering fails after canonicalize
- #8012: [Moore][Arc][LLHD] Moore to LLVM lowering issues with canonicalize

### Summary

This appears to be a novel trigger pattern (partial struct field assignment in always_comb), but likely stems from a known canonicalize stability issue. The underlying problem is that:
1. `llhd-sig2reg` can generate circular SSA definitions
2. `canonicalize` lacks guards against infinite loops on cyclic IR

Both components need review and hardening.

---

## Test Case Metadata

- **Test Case ID:** 260128-00000bf1
- **Dialect:** SystemVerilog (Moore)
- **Crash Type:** Timeout (infinite loop)
- **Pipeline Stage:** circt-verilog --ir-hw (LLHD→HW lowering)
- **Timeout Pass:** canonicalize (after llhd-sig2reg)
- **Minimized Size:** 150 bytes (70% reduction)
- **Report Date:** 2026-01-31
