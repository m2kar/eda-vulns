[{"body":"## Bug Description\n\n`circt-verilog` crashes with an assertion failure when processing a SystemVerilog module that has a `string` type output port. The crash occurs during the MooreToCore conversion pass when the `getModulePortInfo()` function fails to properly handle cases where type conversion returns an invalid/empty type, causing a `dyn_cast` assertion failure in `ModulePortInfo::sanitizeInOut()`.\n\nThis is a valid SystemVerilog construct per IEEE 1800-2017 Section 6.16 (String data type). Both **slang** and **verilator** accept the code without errors.\n\n## Steps to Reproduce\n\n1. Save the following test case as `bug.sv`\n2. Run: `circt-verilog --ir-hw bug.sv`\n\n## Test Case\n\n```systemverilog\nmodule test_module(output string a);\nendmodule\n```\n\n## Expected Behavior\n\nCIRCT should either:\n1. Support simulation constructs like string ports appropriately, OR\n2. Emit a proper diagnostic error message indicating that string ports are not supported for hardware synthesis\n\n## Actual Behavior\n\nThe tool crashes with an assertion failure:\n\n```\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: circt-verilog --ir-hw bug.sv\n #0 0x00007fe810a738a8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x2008a8)\n #1 0x00007fe810a712f5 llvm::sys::RunSignalHandlers() (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x1fe2f5)\n #2 0x00007fe810a74631 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x00007fe810581330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #4 0x00007fe814c958ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007fe814c95b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007fe814c95530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n #7 0x00007fe812fa7438 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2a438)\n #8 0x00007fe812f718ed void llvm::function_ref<void ()>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_0>(long) PatternApplicator.cpp:0:0\n #9 0x00007fe812f6e774 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/opt/firtool-1.139.0/bin/../lib/libMLIRRewrite.so+0x7774)\n#10 0x00007fe812fa8c6f (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*) DialectConversion.cpp:0:0\n#11 0x00007fe812fa8470 mlir::OperationConverter::convert(mlir::Operation*, bool) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2b470)\n#12 0x00007fe812fa8dae mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2bdae)\n#13 0x00007fe812fb68e4 void llvm::function_ref<void ()>::callback_fn<applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode)::$_0>(long) DialectConversion.cpp:0:0\n#14 0x00007fe812fadf7d applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode) DialectConversion.cpp:0:0\n#15 0x00007fe812fae0fe mlir::applyFullConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x310fe)\n#16 0x00007fe814c67231 (anonymous namespace)::MooreToCorePass::runOnOperation() MooreToCore.cpp:0:0\n#17 0x00007fe812d632a5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x172a5)\n#18 0x00007fe812d667a9 mlir::PassManager::run(mlir::Operation*) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x1a7a9)\n#19 0x0000561bab9605d0 executeWithSources(mlir::MLIRContext*, llvm::SourceMgr&) circt-verilog.cpp:0:0\n#20 0x0000561bab95bdd5 execute(mlir::MLIRContext*) circt-verilog.cpp:0:0\n#21 0x0000561bab95b4b8 main (/opt/firtool-1.139.0/bin/circt-verilog+0x84b8)\n#22 0x00007fe8105661ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#23 0x00007fe81056628b call_init ./csu/../csu/libc-start.c:128:20\n#24 0x00007fe81056628b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#25 0x0000561bab95ab05 _start (/opt/firtool-1.139.0/bin/circt-verilog+0x7b05)\n\n```\n\n## Root Cause Analysis\n\n### Crash Location\n- **File**: `lib/Conversion/MooreToCore/MooreToCore.cpp`\n- **Function**: `getModulePortInfo()` → calls `ModulePortInfo::sanitizeInOut()`\n- **Assertion**: `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"`\n\n### Analysis\n\nThe root cause is **missing validation of type conversion result** in `getModulePortInfo()`:\n\n```cpp\n// MooreToCore.cpp:233-259\nstatic hw::ModulePortInfo getModulePortInfo(const TypeConverter &typeConverter,\n                                            SVModuleOp op) {\n  // ...\n  for (auto port : moduleTy.getPorts()) {\n    Type portTy = typeConverter.convertType(port.type);  // <-- May return empty Type!\n    // ...\n    ports.push_back(hw::PortInfo({{port.name, portTy, port.dir}, ...}));  // <-- Stores empty Type\n  }\n  return hw::ModulePortInfo(ports);  // <-- Constructor calls sanitizeInOut()\n}\n```\n\nWhen `typeConverter.convertType()` fails for the `string` port type (returns empty `Type`), this invalid type is passed to `sanitizeInOut()` which calls `dyn_cast<hw::InOutType>(p.type)` on the empty type, triggering the assertion.\n\n### Suggested Fix\n\nAdd validation in `getModulePortInfo()` to check if `typeConverter.convertType()` returns a valid type:\n\n```cpp\nType portTy = typeConverter.convertType(port.type);\nif (!portTy) {\n  // Emit proper diagnostic error\n  return failure();\n}\n```\n\n## Environment\n\n- **CIRCT Version**: firtool-1.139.0 (LLVM 22.0.0git)\n- **OS**: Linux 5.15.0 (x86_64)\n\n## Cross-Tool Validation\n\n| Tool | Version | Status | Notes |\n|------|---------|--------|-------|\n| slang | 10.0.6+3d7e6cd2e | ✅ Pass | Build succeeded: 0 errors, 0 warnings |\n| verilator | 5.022 | ✅ Pass | No errors |\n| iverilog | - | ❌ Error | \"Port with type string is not supported\" (tool limitation, not syntax error) |\n\nThis confirms the test case is **syntactically valid** SystemVerilog per IEEE 1800-2017.\n","labels":[],"number":9572,"state":"OPEN","title":"[Moore] Assertion failure when module has string type output port","url":"https://github.com/llvm/circt/issues/9572"}]
