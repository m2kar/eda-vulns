// -----// IR Dump Before StripOMPass (strip-om) //----- //
module {
  hw.module @data_processor(in %clk : i1, in %in_data : i32, out result : i4) {
    %true = hw.constant true
    %c-1_i32 = hw.constant -1 : i32
    %c0_i2 = hw.constant 0 : i2
    %c1_i2 = hw.constant 1 : i2
    %c-2_i2 = hw.constant -2 : i2
    %c0_i30 = hw.constant 0 : i30
    %c-1_i2 = hw.constant -1 : i2
    %c3_i32 = hw.constant 3 : i32
    %c4_i32 = hw.constant 4 : i32
    %c1_i32 = hw.constant 1 : i32
    %0:4 = llhd.combinational -> i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1 {
      %13 = comb.extract %data_reg from 0 : (i32) -> i8
      %14 = hw.struct_create (%13, %data_reg) : !hw.struct<header: i8, payload: i32>
      %15 = hw.array_inject %packet_array[%c-1_i2], %14 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      cf.br ^bb1(%c1_i32, %15 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb1(%16: i32, %17: !hw.array<4xstruct<header: i8, payload: i32>>):  // 2 preds: ^bb0, ^bb2
      %18 = comb.icmp slt %16, %c4_i32 : i32
      cf.cond_br %18, ^bb2, ^bb3(%in_data, %true, %17, %true : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1)
    ^bb2:  // pred: ^bb1
      %19 = comb.sub %c3_i32, %16 : i32
      %20 = comb.extract %19 from 2 : (i32) -> i30
      %21 = comb.icmp eq %20, %c0_i30 : i30
      %22 = comb.extract %19 from 0 : (i32) -> i2
      %23 = comb.mux %21, %22, %c-1_i2 : i2
      %24 = comb.add %16, %c-1_i32 : i32
      %25 = comb.sub %c3_i32, %24 : i32
      %26 = comb.extract %25 from 2 : (i32) -> i30
      %27 = comb.icmp eq %26, %c0_i30 : i30
      %28 = comb.extract %25 from 0 : (i32) -> i2
      %29 = comb.mux %27, %28, %c-1_i2 : i2
      %30 = hw.array_get %packet_array[%29] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %payload_3 = hw.struct_extract %30["payload"] : !hw.struct<header: i8, payload: i32>
      %header = hw.struct_extract %30["header"] : !hw.struct<header: i8, payload: i32>
      %31 = hw.struct_create (%header, %payload_3) : !hw.struct<header: i8, payload: i32>
      %32 = hw.array_inject %17[%23], %31 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %33 = comb.add %16, %c1_i32 : i32
      cf.br ^bb1(%33, %32 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb3(%34: i32, %35: i1, %36: !hw.array<4xstruct<header: i8, payload: i32>>, %37: i1):  // pred: ^bb1
      llhd.yield %34, %35, %36, %37 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1
    }
    %1 = seq.to_clock %clk
    %2 = comb.mux bin %0#1, %in_data, %data_reg : i32
    %data_reg = seq.firreg %2 clock %1 : i32
    %3 = comb.mux bin %0#3, %0#2, %packet_array : !hw.array<4xstruct<header: i8, payload: i32>>
    %packet_array = seq.firreg %3 clock %1 : !hw.array<4xstruct<header: i8, payload: i32>>
    %4 = hw.array_get %packet_array[%c-1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload = hw.struct_extract %4["payload"] : !hw.struct<header: i8, payload: i32>
    %5 = comb.extract %payload from 0 : (i32) -> i4
    %6 = hw.array_get %packet_array[%c-2_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_0 = hw.struct_extract %6["payload"] : !hw.struct<header: i8, payload: i32>
    %7 = comb.extract %payload_0 from 0 : (i32) -> i4
    %8 = hw.array_get %packet_array[%c1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_1 = hw.struct_extract %8["payload"] : !hw.struct<header: i8, payload: i32>
    %9 = comb.extract %payload_1 from 0 : (i32) -> i4
    %10 = hw.array_get %packet_array[%c0_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_2 = hw.struct_extract %10["payload"] : !hw.struct<header: i8, payload: i32>
    %11 = comb.extract %payload_2 from 0 : (i32) -> i4
    %12 = comb.xor %5, %7, %9, %11 : i4
    hw.output %12 : i4
  }
}


// -----// IR Dump Before StripEmitPass (strip-emit) //----- //
module {
  hw.module @data_processor(in %clk : i1, in %in_data : i32, out result : i4) {
    %true = hw.constant true
    %c-1_i32 = hw.constant -1 : i32
    %c0_i2 = hw.constant 0 : i2
    %c1_i2 = hw.constant 1 : i2
    %c-2_i2 = hw.constant -2 : i2
    %c0_i30 = hw.constant 0 : i30
    %c-1_i2 = hw.constant -1 : i2
    %c3_i32 = hw.constant 3 : i32
    %c4_i32 = hw.constant 4 : i32
    %c1_i32 = hw.constant 1 : i32
    %0:4 = llhd.combinational -> i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1 {
      %13 = comb.extract %data_reg from 0 : (i32) -> i8
      %14 = hw.struct_create (%13, %data_reg) : !hw.struct<header: i8, payload: i32>
      %15 = hw.array_inject %packet_array[%c-1_i2], %14 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      cf.br ^bb1(%c1_i32, %15 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb1(%16: i32, %17: !hw.array<4xstruct<header: i8, payload: i32>>):  // 2 preds: ^bb0, ^bb2
      %18 = comb.icmp slt %16, %c4_i32 : i32
      cf.cond_br %18, ^bb2, ^bb3(%in_data, %true, %17, %true : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1)
    ^bb2:  // pred: ^bb1
      %19 = comb.sub %c3_i32, %16 : i32
      %20 = comb.extract %19 from 2 : (i32) -> i30
      %21 = comb.icmp eq %20, %c0_i30 : i30
      %22 = comb.extract %19 from 0 : (i32) -> i2
      %23 = comb.mux %21, %22, %c-1_i2 : i2
      %24 = comb.add %16, %c-1_i32 : i32
      %25 = comb.sub %c3_i32, %24 : i32
      %26 = comb.extract %25 from 2 : (i32) -> i30
      %27 = comb.icmp eq %26, %c0_i30 : i30
      %28 = comb.extract %25 from 0 : (i32) -> i2
      %29 = comb.mux %27, %28, %c-1_i2 : i2
      %30 = hw.array_get %packet_array[%29] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %payload_3 = hw.struct_extract %30["payload"] : !hw.struct<header: i8, payload: i32>
      %header = hw.struct_extract %30["header"] : !hw.struct<header: i8, payload: i32>
      %31 = hw.struct_create (%header, %payload_3) : !hw.struct<header: i8, payload: i32>
      %32 = hw.array_inject %17[%23], %31 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %33 = comb.add %16, %c1_i32 : i32
      cf.br ^bb1(%33, %32 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb3(%34: i32, %35: i1, %36: !hw.array<4xstruct<header: i8, payload: i32>>, %37: i1):  // pred: ^bb1
      llhd.yield %34, %35, %36, %37 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1
    }
    %1 = seq.to_clock %clk
    %2 = comb.mux bin %0#1, %in_data, %data_reg : i32
    %data_reg = seq.firreg %2 clock %1 : i32
    %3 = comb.mux bin %0#3, %0#2, %packet_array : !hw.array<4xstruct<header: i8, payload: i32>>
    %packet_array = seq.firreg %3 clock %1 : !hw.array<4xstruct<header: i8, payload: i32>>
    %4 = hw.array_get %packet_array[%c-1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload = hw.struct_extract %4["payload"] : !hw.struct<header: i8, payload: i32>
    %5 = comb.extract %payload from 0 : (i32) -> i4
    %6 = hw.array_get %packet_array[%c-2_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_0 = hw.struct_extract %6["payload"] : !hw.struct<header: i8, payload: i32>
    %7 = comb.extract %payload_0 from 0 : (i32) -> i4
    %8 = hw.array_get %packet_array[%c1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_1 = hw.struct_extract %8["payload"] : !hw.struct<header: i8, payload: i32>
    %9 = comb.extract %payload_1 from 0 : (i32) -> i4
    %10 = hw.array_get %packet_array[%c0_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_2 = hw.struct_extract %10["payload"] : !hw.struct<header: i8, payload: i32>
    %11 = comb.extract %payload_2 from 0 : (i32) -> i4
    %12 = comb.xor %5, %7, %9, %11 : i4
    hw.output %12 : i4
  }
}


// -----// IR Dump Before LowerFirMem (lower-seq-firmem) //----- //
module {
  hw.module @data_processor(in %clk : i1, in %in_data : i32, out result : i4) {
    %true = hw.constant true
    %c-1_i32 = hw.constant -1 : i32
    %c0_i2 = hw.constant 0 : i2
    %c1_i2 = hw.constant 1 : i2
    %c-2_i2 = hw.constant -2 : i2
    %c0_i30 = hw.constant 0 : i30
    %c-1_i2 = hw.constant -1 : i2
    %c3_i32 = hw.constant 3 : i32
    %c4_i32 = hw.constant 4 : i32
    %c1_i32 = hw.constant 1 : i32
    %0:4 = llhd.combinational -> i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1 {
      %13 = comb.extract %data_reg from 0 : (i32) -> i8
      %14 = hw.struct_create (%13, %data_reg) : !hw.struct<header: i8, payload: i32>
      %15 = hw.array_inject %packet_array[%c-1_i2], %14 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      cf.br ^bb1(%c1_i32, %15 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb1(%16: i32, %17: !hw.array<4xstruct<header: i8, payload: i32>>):  // 2 preds: ^bb0, ^bb2
      %18 = comb.icmp slt %16, %c4_i32 : i32
      cf.cond_br %18, ^bb2, ^bb3(%in_data, %true, %17, %true : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1)
    ^bb2:  // pred: ^bb1
      %19 = comb.sub %c3_i32, %16 : i32
      %20 = comb.extract %19 from 2 : (i32) -> i30
      %21 = comb.icmp eq %20, %c0_i30 : i30
      %22 = comb.extract %19 from 0 : (i32) -> i2
      %23 = comb.mux %21, %22, %c-1_i2 : i2
      %24 = comb.add %16, %c-1_i32 : i32
      %25 = comb.sub %c3_i32, %24 : i32
      %26 = comb.extract %25 from 2 : (i32) -> i30
      %27 = comb.icmp eq %26, %c0_i30 : i30
      %28 = comb.extract %25 from 0 : (i32) -> i2
      %29 = comb.mux %27, %28, %c-1_i2 : i2
      %30 = hw.array_get %packet_array[%29] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %payload_3 = hw.struct_extract %30["payload"] : !hw.struct<header: i8, payload: i32>
      %header = hw.struct_extract %30["header"] : !hw.struct<header: i8, payload: i32>
      %31 = hw.struct_create (%header, %payload_3) : !hw.struct<header: i8, payload: i32>
      %32 = hw.array_inject %17[%23], %31 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %33 = comb.add %16, %c1_i32 : i32
      cf.br ^bb1(%33, %32 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb3(%34: i32, %35: i1, %36: !hw.array<4xstruct<header: i8, payload: i32>>, %37: i1):  // pred: ^bb1
      llhd.yield %34, %35, %36, %37 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1
    }
    %1 = seq.to_clock %clk
    %2 = comb.mux bin %0#1, %in_data, %data_reg : i32
    %data_reg = seq.firreg %2 clock %1 : i32
    %3 = comb.mux bin %0#3, %0#2, %packet_array : !hw.array<4xstruct<header: i8, payload: i32>>
    %packet_array = seq.firreg %3 clock %1 : !hw.array<4xstruct<header: i8, payload: i32>>
    %4 = hw.array_get %packet_array[%c-1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload = hw.struct_extract %4["payload"] : !hw.struct<header: i8, payload: i32>
    %5 = comb.extract %payload from 0 : (i32) -> i4
    %6 = hw.array_get %packet_array[%c-2_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_0 = hw.struct_extract %6["payload"] : !hw.struct<header: i8, payload: i32>
    %7 = comb.extract %payload_0 from 0 : (i32) -> i4
    %8 = hw.array_get %packet_array[%c1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_1 = hw.struct_extract %8["payload"] : !hw.struct<header: i8, payload: i32>
    %9 = comb.extract %payload_1 from 0 : (i32) -> i4
    %10 = hw.array_get %packet_array[%c0_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_2 = hw.struct_extract %10["payload"] : !hw.struct<header: i8, payload: i32>
    %11 = comb.extract %payload_2 from 0 : (i32) -> i4
    %12 = comb.xor %5, %7, %9, %11 : i4
    hw.output %12 : i4
  }
}


// -----// IR Dump Before LowerVerifSimulationsPass (arc-lower-verif-simulations) //----- //
module {
  hw.module @data_processor(in %clk : i1, in %in_data : i32, out result : i4) {
    %true = hw.constant true
    %c-1_i32 = hw.constant -1 : i32
    %c0_i2 = hw.constant 0 : i2
    %c1_i2 = hw.constant 1 : i2
    %c-2_i2 = hw.constant -2 : i2
    %c0_i30 = hw.constant 0 : i30
    %c-1_i2 = hw.constant -1 : i2
    %c3_i32 = hw.constant 3 : i32
    %c4_i32 = hw.constant 4 : i32
    %c1_i32 = hw.constant 1 : i32
    %0:4 = llhd.combinational -> i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1 {
      %13 = comb.extract %data_reg from 0 : (i32) -> i8
      %14 = hw.struct_create (%13, %data_reg) : !hw.struct<header: i8, payload: i32>
      %15 = hw.array_inject %packet_array[%c-1_i2], %14 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      cf.br ^bb1(%c1_i32, %15 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb1(%16: i32, %17: !hw.array<4xstruct<header: i8, payload: i32>>):  // 2 preds: ^bb0, ^bb2
      %18 = comb.icmp slt %16, %c4_i32 : i32
      cf.cond_br %18, ^bb2, ^bb3(%in_data, %true, %17, %true : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1)
    ^bb2:  // pred: ^bb1
      %19 = comb.sub %c3_i32, %16 : i32
      %20 = comb.extract %19 from 2 : (i32) -> i30
      %21 = comb.icmp eq %20, %c0_i30 : i30
      %22 = comb.extract %19 from 0 : (i32) -> i2
      %23 = comb.mux %21, %22, %c-1_i2 : i2
      %24 = comb.add %16, %c-1_i32 : i32
      %25 = comb.sub %c3_i32, %24 : i32
      %26 = comb.extract %25 from 2 : (i32) -> i30
      %27 = comb.icmp eq %26, %c0_i30 : i30
      %28 = comb.extract %25 from 0 : (i32) -> i2
      %29 = comb.mux %27, %28, %c-1_i2 : i2
      %30 = hw.array_get %packet_array[%29] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %payload_3 = hw.struct_extract %30["payload"] : !hw.struct<header: i8, payload: i32>
      %header = hw.struct_extract %30["header"] : !hw.struct<header: i8, payload: i32>
      %31 = hw.struct_create (%header, %payload_3) : !hw.struct<header: i8, payload: i32>
      %32 = hw.array_inject %17[%23], %31 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %33 = comb.add %16, %c1_i32 : i32
      cf.br ^bb1(%33, %32 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb3(%34: i32, %35: i1, %36: !hw.array<4xstruct<header: i8, payload: i32>>, %37: i1):  // pred: ^bb1
      llhd.yield %34, %35, %36, %37 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1
    }
    %1 = seq.to_clock %clk
    %2 = comb.mux bin %0#1, %in_data, %data_reg : i32
    %data_reg = seq.firreg %2 clock %1 : i32
    %3 = comb.mux bin %0#3, %0#2, %packet_array : !hw.array<4xstruct<header: i8, payload: i32>>
    %packet_array = seq.firreg %3 clock %1 : !hw.array<4xstruct<header: i8, payload: i32>>
    %4 = hw.array_get %packet_array[%c-1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload = hw.struct_extract %4["payload"] : !hw.struct<header: i8, payload: i32>
    %5 = comb.extract %payload from 0 : (i32) -> i4
    %6 = hw.array_get %packet_array[%c-2_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_0 = hw.struct_extract %6["payload"] : !hw.struct<header: i8, payload: i32>
    %7 = comb.extract %payload_0 from 0 : (i32) -> i4
    %8 = hw.array_get %packet_array[%c1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_1 = hw.struct_extract %8["payload"] : !hw.struct<header: i8, payload: i32>
    %9 = comb.extract %payload_1 from 0 : (i32) -> i4
    %10 = hw.array_get %packet_array[%c0_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_2 = hw.struct_extract %10["payload"] : !hw.struct<header: i8, payload: i32>
    %11 = comb.extract %payload_2 from 0 : (i32) -> i4
    %12 = comb.xor %5, %7, %9, %11 : i4
    hw.output %12 : i4
  }
}


// -----// IR Dump Before AddTaps (arc-add-taps) //----- //
module {
  func.func private @exit(i32)
  hw.module @data_processor(in %clk : i1, in %in_data : i32, out result : i4) {
    %true = hw.constant true
    %c-1_i32 = hw.constant -1 : i32
    %c0_i2 = hw.constant 0 : i2
    %c1_i2 = hw.constant 1 : i2
    %c-2_i2 = hw.constant -2 : i2
    %c0_i30 = hw.constant 0 : i30
    %c-1_i2 = hw.constant -1 : i2
    %c3_i32 = hw.constant 3 : i32
    %c4_i32 = hw.constant 4 : i32
    %c1_i32 = hw.constant 1 : i32
    %0:4 = llhd.combinational -> i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1 {
      %13 = comb.extract %data_reg from 0 : (i32) -> i8
      %14 = hw.struct_create (%13, %data_reg) : !hw.struct<header: i8, payload: i32>
      %15 = hw.array_inject %packet_array[%c-1_i2], %14 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      cf.br ^bb1(%c1_i32, %15 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb1(%16: i32, %17: !hw.array<4xstruct<header: i8, payload: i32>>):  // 2 preds: ^bb0, ^bb2
      %18 = comb.icmp slt %16, %c4_i32 : i32
      cf.cond_br %18, ^bb2, ^bb3(%in_data, %true, %17, %true : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1)
    ^bb2:  // pred: ^bb1
      %19 = comb.sub %c3_i32, %16 : i32
      %20 = comb.extract %19 from 2 : (i32) -> i30
      %21 = comb.icmp eq %20, %c0_i30 : i30
      %22 = comb.extract %19 from 0 : (i32) -> i2
      %23 = comb.mux %21, %22, %c-1_i2 : i2
      %24 = comb.add %16, %c-1_i32 : i32
      %25 = comb.sub %c3_i32, %24 : i32
      %26 = comb.extract %25 from 2 : (i32) -> i30
      %27 = comb.icmp eq %26, %c0_i30 : i30
      %28 = comb.extract %25 from 0 : (i32) -> i2
      %29 = comb.mux %27, %28, %c-1_i2 : i2
      %30 = hw.array_get %packet_array[%29] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %payload_3 = hw.struct_extract %30["payload"] : !hw.struct<header: i8, payload: i32>
      %header = hw.struct_extract %30["header"] : !hw.struct<header: i8, payload: i32>
      %31 = hw.struct_create (%header, %payload_3) : !hw.struct<header: i8, payload: i32>
      %32 = hw.array_inject %17[%23], %31 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %33 = comb.add %16, %c1_i32 : i32
      cf.br ^bb1(%33, %32 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb3(%34: i32, %35: i1, %36: !hw.array<4xstruct<header: i8, payload: i32>>, %37: i1):  // pred: ^bb1
      llhd.yield %34, %35, %36, %37 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1
    }
    %1 = seq.to_clock %clk
    %2 = comb.mux bin %0#1, %in_data, %data_reg : i32
    %data_reg = seq.firreg %2 clock %1 : i32
    %3 = comb.mux bin %0#3, %0#2, %packet_array : !hw.array<4xstruct<header: i8, payload: i32>>
    %packet_array = seq.firreg %3 clock %1 : !hw.array<4xstruct<header: i8, payload: i32>>
    %4 = hw.array_get %packet_array[%c-1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload = hw.struct_extract %4["payload"] : !hw.struct<header: i8, payload: i32>
    %5 = comb.extract %payload from 0 : (i32) -> i4
    %6 = hw.array_get %packet_array[%c-2_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_0 = hw.struct_extract %6["payload"] : !hw.struct<header: i8, payload: i32>
    %7 = comb.extract %payload_0 from 0 : (i32) -> i4
    %8 = hw.array_get %packet_array[%c1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_1 = hw.struct_extract %8["payload"] : !hw.struct<header: i8, payload: i32>
    %9 = comb.extract %payload_1 from 0 : (i32) -> i4
    %10 = hw.array_get %packet_array[%c0_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_2 = hw.struct_extract %10["payload"] : !hw.struct<header: i8, payload: i32>
    %11 = comb.extract %payload_2 from 0 : (i32) -> i4
    %12 = comb.xor %5, %7, %9, %11 : i4
    hw.output %12 : i4
  }
}


// -----// IR Dump Before StripSV (arc-strip-sv) //----- //
module {
  func.func private @exit(i32)
  hw.module @data_processor(in %clk : i1, in %in_data : i32, out result : i4) {
    %true = hw.constant true
    %c-1_i32 = hw.constant -1 : i32
    %c0_i2 = hw.constant 0 : i2
    %c1_i2 = hw.constant 1 : i2
    %c-2_i2 = hw.constant -2 : i2
    %c0_i30 = hw.constant 0 : i30
    %c-1_i2 = hw.constant -1 : i2
    %c3_i32 = hw.constant 3 : i32
    %c4_i32 = hw.constant 4 : i32
    %c1_i32 = hw.constant 1 : i32
    %0:4 = llhd.combinational -> i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1 {
      %13 = comb.extract %data_reg from 0 : (i32) -> i8
      %14 = hw.struct_create (%13, %data_reg) : !hw.struct<header: i8, payload: i32>
      %15 = hw.array_inject %packet_array[%c-1_i2], %14 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      cf.br ^bb1(%c1_i32, %15 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb1(%16: i32, %17: !hw.array<4xstruct<header: i8, payload: i32>>):  // 2 preds: ^bb0, ^bb2
      %18 = comb.icmp slt %16, %c4_i32 : i32
      cf.cond_br %18, ^bb2, ^bb3(%in_data, %true, %17, %true : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1)
    ^bb2:  // pred: ^bb1
      %19 = comb.sub %c3_i32, %16 : i32
      %20 = comb.extract %19 from 2 : (i32) -> i30
      %21 = comb.icmp eq %20, %c0_i30 : i30
      %22 = comb.extract %19 from 0 : (i32) -> i2
      %23 = comb.mux %21, %22, %c-1_i2 : i2
      %24 = comb.add %16, %c-1_i32 : i32
      %25 = comb.sub %c3_i32, %24 : i32
      %26 = comb.extract %25 from 2 : (i32) -> i30
      %27 = comb.icmp eq %26, %c0_i30 : i30
      %28 = comb.extract %25 from 0 : (i32) -> i2
      %29 = comb.mux %27, %28, %c-1_i2 : i2
      %30 = hw.array_get %packet_array[%29] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %payload_3 = hw.struct_extract %30["payload"] : !hw.struct<header: i8, payload: i32>
      %header = hw.struct_extract %30["header"] : !hw.struct<header: i8, payload: i32>
      %31 = hw.struct_create (%header, %payload_3) : !hw.struct<header: i8, payload: i32>
      %32 = hw.array_inject %17[%23], %31 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %33 = comb.add %16, %c1_i32 : i32
      cf.br ^bb1(%33, %32 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb3(%34: i32, %35: i1, %36: !hw.array<4xstruct<header: i8, payload: i32>>, %37: i1):  // pred: ^bb1
      llhd.yield %34, %35, %36, %37 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1
    }
    %1 = seq.to_clock %clk
    %2 = comb.mux bin %0#1, %in_data, %data_reg : i32
    %data_reg = seq.firreg %2 clock %1 : i32
    %3 = comb.mux bin %0#3, %0#2, %packet_array : !hw.array<4xstruct<header: i8, payload: i32>>
    %packet_array = seq.firreg %3 clock %1 : !hw.array<4xstruct<header: i8, payload: i32>>
    %4 = hw.array_get %packet_array[%c-1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload = hw.struct_extract %4["payload"] : !hw.struct<header: i8, payload: i32>
    %5 = comb.extract %payload from 0 : (i32) -> i4
    %6 = hw.array_get %packet_array[%c-2_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_0 = hw.struct_extract %6["payload"] : !hw.struct<header: i8, payload: i32>
    %7 = comb.extract %payload_0 from 0 : (i32) -> i4
    %8 = hw.array_get %packet_array[%c1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_1 = hw.struct_extract %8["payload"] : !hw.struct<header: i8, payload: i32>
    %9 = comb.extract %payload_1 from 0 : (i32) -> i4
    %10 = hw.array_get %packet_array[%c0_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_2 = hw.struct_extract %10["payload"] : !hw.struct<header: i8, payload: i32>
    %11 = comb.extract %payload_2 from 0 : (i32) -> i4
    %12 = comb.xor %5, %7, %9, %11 : i4
    hw.output %12 : i4
  }
}


// -----// IR Dump Before InferMemories (arc-infer-memories) //----- //
module {
  func.func private @exit(i32)
  hw.module @data_processor(in %clk : i1, in %in_data : i32, out result : i4) {
    %true = hw.constant true
    %c-1_i32 = hw.constant -1 : i32
    %c0_i2 = hw.constant 0 : i2
    %c1_i2 = hw.constant 1 : i2
    %c-2_i2 = hw.constant -2 : i2
    %c0_i30 = hw.constant 0 : i30
    %c-1_i2 = hw.constant -1 : i2
    %c3_i32 = hw.constant 3 : i32
    %c4_i32 = hw.constant 4 : i32
    %c1_i32 = hw.constant 1 : i32
    %0:4 = llhd.combinational -> i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1 {
      %13 = comb.extract %data_reg from 0 : (i32) -> i8
      %14 = hw.struct_create (%13, %data_reg) : !hw.struct<header: i8, payload: i32>
      %15 = hw.array_inject %packet_array[%c-1_i2], %14 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      cf.br ^bb1(%c1_i32, %15 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb1(%16: i32, %17: !hw.array<4xstruct<header: i8, payload: i32>>):  // 2 preds: ^bb0, ^bb2
      %18 = comb.icmp slt %16, %c4_i32 : i32
      cf.cond_br %18, ^bb2, ^bb3(%in_data, %true, %17, %true : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1)
    ^bb2:  // pred: ^bb1
      %19 = comb.sub %c3_i32, %16 : i32
      %20 = comb.extract %19 from 2 : (i32) -> i30
      %21 = comb.icmp eq %20, %c0_i30 : i30
      %22 = comb.extract %19 from 0 : (i32) -> i2
      %23 = comb.mux %21, %22, %c-1_i2 : i2
      %24 = comb.add %16, %c-1_i32 : i32
      %25 = comb.sub %c3_i32, %24 : i32
      %26 = comb.extract %25 from 2 : (i32) -> i30
      %27 = comb.icmp eq %26, %c0_i30 : i30
      %28 = comb.extract %25 from 0 : (i32) -> i2
      %29 = comb.mux %27, %28, %c-1_i2 : i2
      %30 = hw.array_get %packet_array[%29] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %payload_3 = hw.struct_extract %30["payload"] : !hw.struct<header: i8, payload: i32>
      %header = hw.struct_extract %30["header"] : !hw.struct<header: i8, payload: i32>
      %31 = hw.struct_create (%header, %payload_3) : !hw.struct<header: i8, payload: i32>
      %32 = hw.array_inject %17[%23], %31 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %33 = comb.add %16, %c1_i32 : i32
      cf.br ^bb1(%33, %32 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb3(%34: i32, %35: i1, %36: !hw.array<4xstruct<header: i8, payload: i32>>, %37: i1):  // pred: ^bb1
      llhd.yield %34, %35, %36, %37 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1
    }
    %1 = seq.to_clock %clk
    %2 = comb.mux bin %0#1, %in_data, %data_reg : i32
    %data_reg = seq.compreg %2, %1 : i32  
    %3 = comb.mux bin %0#3, %0#2, %packet_array : !hw.array<4xstruct<header: i8, payload: i32>>
    %packet_array = seq.compreg %3, %1 : !hw.array<4xstruct<header: i8, payload: i32>>  
    %4 = hw.array_get %packet_array[%c-1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload = hw.struct_extract %4["payload"] : !hw.struct<header: i8, payload: i32>
    %5 = comb.extract %payload from 0 : (i32) -> i4
    %6 = hw.array_get %packet_array[%c-2_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_0 = hw.struct_extract %6["payload"] : !hw.struct<header: i8, payload: i32>
    %7 = comb.extract %payload_0 from 0 : (i32) -> i4
    %8 = hw.array_get %packet_array[%c1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_1 = hw.struct_extract %8["payload"] : !hw.struct<header: i8, payload: i32>
    %9 = comb.extract %payload_1 from 0 : (i32) -> i4
    %10 = hw.array_get %packet_array[%c0_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_2 = hw.struct_extract %10["payload"] : !hw.struct<header: i8, payload: i32>
    %11 = comb.extract %payload_2 from 0 : (i32) -> i4
    %12 = comb.xor %5, %7, %9, %11 : i4
    hw.output %12 : i4
  }
}


// -----// IR Dump Before LowerDPIFunc (sim-lower-dpi-func) //----- //
module {
  func.func private @exit(i32)
  hw.module @data_processor(in %clk : i1, in %in_data : i32, out result : i4) {
    %true = hw.constant true
    %c-1_i32 = hw.constant -1 : i32
    %c0_i2 = hw.constant 0 : i2
    %c1_i2 = hw.constant 1 : i2
    %c-2_i2 = hw.constant -2 : i2
    %c0_i30 = hw.constant 0 : i30
    %c-1_i2 = hw.constant -1 : i2
    %c3_i32 = hw.constant 3 : i32
    %c4_i32 = hw.constant 4 : i32
    %c1_i32 = hw.constant 1 : i32
    %0:4 = llhd.combinational -> i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1 {
      %13 = comb.extract %data_reg from 0 : (i32) -> i8
      %14 = hw.struct_create (%13, %data_reg) : !hw.struct<header: i8, payload: i32>
      %15 = hw.array_inject %packet_array[%c-1_i2], %14 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      cf.br ^bb1(%c1_i32, %15 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb1(%16: i32, %17: !hw.array<4xstruct<header: i8, payload: i32>>):  // 2 preds: ^bb0, ^bb2
      %18 = comb.icmp slt %16, %c4_i32 : i32
      cf.cond_br %18, ^bb2, ^bb3(%in_data, %true, %17, %true : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1)
    ^bb2:  // pred: ^bb1
      %19 = comb.sub %c3_i32, %16 : i32
      %20 = comb.extract %19 from 2 : (i32) -> i30
      %21 = comb.icmp eq %20, %c0_i30 : i30
      %22 = comb.extract %19 from 0 : (i32) -> i2
      %23 = comb.mux %21, %22, %c-1_i2 : i2
      %24 = comb.add %16, %c-1_i32 : i32
      %25 = comb.sub %c3_i32, %24 : i32
      %26 = comb.extract %25 from 2 : (i32) -> i30
      %27 = comb.icmp eq %26, %c0_i30 : i30
      %28 = comb.extract %25 from 0 : (i32) -> i2
      %29 = comb.mux %27, %28, %c-1_i2 : i2
      %30 = hw.array_get %packet_array[%29] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %payload_3 = hw.struct_extract %30["payload"] : !hw.struct<header: i8, payload: i32>
      %header = hw.struct_extract %30["header"] : !hw.struct<header: i8, payload: i32>
      %31 = hw.struct_create (%header, %payload_3) : !hw.struct<header: i8, payload: i32>
      %32 = hw.array_inject %17[%23], %31 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %33 = comb.add %16, %c1_i32 : i32
      cf.br ^bb1(%33, %32 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb3(%34: i32, %35: i1, %36: !hw.array<4xstruct<header: i8, payload: i32>>, %37: i1):  // pred: ^bb1
      llhd.yield %34, %35, %36, %37 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1
    }
    %1 = seq.to_clock %clk
    %2 = comb.mux bin %0#1, %in_data, %data_reg : i32
    %data_reg = seq.compreg %2, %1 : i32  
    %3 = comb.mux bin %0#3, %0#2, %packet_array : !hw.array<4xstruct<header: i8, payload: i32>>
    %packet_array = seq.compreg %3, %1 : !hw.array<4xstruct<header: i8, payload: i32>>  
    %4 = hw.array_get %packet_array[%c-1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload = hw.struct_extract %4["payload"] : !hw.struct<header: i8, payload: i32>
    %5 = comb.extract %payload from 0 : (i32) -> i4
    %6 = hw.array_get %packet_array[%c-2_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_0 = hw.struct_extract %6["payload"] : !hw.struct<header: i8, payload: i32>
    %7 = comb.extract %payload_0 from 0 : (i32) -> i4
    %8 = hw.array_get %packet_array[%c1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_1 = hw.struct_extract %8["payload"] : !hw.struct<header: i8, payload: i32>
    %9 = comb.extract %payload_1 from 0 : (i32) -> i4
    %10 = hw.array_get %packet_array[%c0_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_2 = hw.struct_extract %10["payload"] : !hw.struct<header: i8, payload: i32>
    %11 = comb.extract %payload_2 from 0 : (i32) -> i4
    %12 = comb.xor %5, %7, %9, %11 : i4
    hw.output %12 : i4
  }
}


// -----// IR Dump Before CSE (cse) //----- //
module {
  func.func private @exit(i32)
  hw.module @data_processor(in %clk : i1, in %in_data : i32, out result : i4) {
    %true = hw.constant true
    %c-1_i32 = hw.constant -1 : i32
    %c0_i2 = hw.constant 0 : i2
    %c1_i2 = hw.constant 1 : i2
    %c-2_i2 = hw.constant -2 : i2
    %c0_i30 = hw.constant 0 : i30
    %c-1_i2 = hw.constant -1 : i2
    %c3_i32 = hw.constant 3 : i32
    %c4_i32 = hw.constant 4 : i32
    %c1_i32 = hw.constant 1 : i32
    %0:4 = llhd.combinational -> i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1 {
      %13 = comb.extract %data_reg from 0 : (i32) -> i8
      %14 = hw.struct_create (%13, %data_reg) : !hw.struct<header: i8, payload: i32>
      %15 = hw.array_inject %packet_array[%c-1_i2], %14 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      cf.br ^bb1(%c1_i32, %15 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb1(%16: i32, %17: !hw.array<4xstruct<header: i8, payload: i32>>):  // 2 preds: ^bb0, ^bb2
      %18 = comb.icmp slt %16, %c4_i32 : i32
      cf.cond_br %18, ^bb2, ^bb3(%in_data, %true, %17, %true : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1)
    ^bb2:  // pred: ^bb1
      %19 = comb.sub %c3_i32, %16 : i32
      %20 = comb.extract %19 from 2 : (i32) -> i30
      %21 = comb.icmp eq %20, %c0_i30 : i30
      %22 = comb.extract %19 from 0 : (i32) -> i2
      %23 = comb.mux %21, %22, %c-1_i2 : i2
      %24 = comb.add %16, %c-1_i32 : i32
      %25 = comb.sub %c3_i32, %24 : i32
      %26 = comb.extract %25 from 2 : (i32) -> i30
      %27 = comb.icmp eq %26, %c0_i30 : i30
      %28 = comb.extract %25 from 0 : (i32) -> i2
      %29 = comb.mux %27, %28, %c-1_i2 : i2
      %30 = hw.array_get %packet_array[%29] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %payload_3 = hw.struct_extract %30["payload"] : !hw.struct<header: i8, payload: i32>
      %header = hw.struct_extract %30["header"] : !hw.struct<header: i8, payload: i32>
      %31 = hw.struct_create (%header, %payload_3) : !hw.struct<header: i8, payload: i32>
      %32 = hw.array_inject %17[%23], %31 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %33 = comb.add %16, %c1_i32 : i32
      cf.br ^bb1(%33, %32 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb3(%34: i32, %35: i1, %36: !hw.array<4xstruct<header: i8, payload: i32>>, %37: i1):  // pred: ^bb1
      llhd.yield %34, %35, %36, %37 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1
    }
    %1 = seq.to_clock %clk
    %2 = comb.mux bin %0#1, %in_data, %data_reg : i32
    %data_reg = seq.compreg %2, %1 : i32  
    %3 = comb.mux bin %0#3, %0#2, %packet_array : !hw.array<4xstruct<header: i8, payload: i32>>
    %packet_array = seq.compreg %3, %1 : !hw.array<4xstruct<header: i8, payload: i32>>  
    %4 = hw.array_get %packet_array[%c-1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload = hw.struct_extract %4["payload"] : !hw.struct<header: i8, payload: i32>
    %5 = comb.extract %payload from 0 : (i32) -> i4
    %6 = hw.array_get %packet_array[%c-2_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_0 = hw.struct_extract %6["payload"] : !hw.struct<header: i8, payload: i32>
    %7 = comb.extract %payload_0 from 0 : (i32) -> i4
    %8 = hw.array_get %packet_array[%c1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_1 = hw.struct_extract %8["payload"] : !hw.struct<header: i8, payload: i32>
    %9 = comb.extract %payload_1 from 0 : (i32) -> i4
    %10 = hw.array_get %packet_array[%c0_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_2 = hw.struct_extract %10["payload"] : !hw.struct<header: i8, payload: i32>
    %11 = comb.extract %payload_2 from 0 : (i32) -> i4
    %12 = comb.xor %5, %7, %9, %11 : i4
    hw.output %12 : i4
  }
}


// -----// IR Dump Before ArcCanonicalizer (arc-canonicalizer) //----- //
module {
  func.func private @exit(i32)
  hw.module @data_processor(in %clk : i1, in %in_data : i32, out result : i4) {
    %true = hw.constant true
    %c-1_i32 = hw.constant -1 : i32
    %c0_i2 = hw.constant 0 : i2
    %c1_i2 = hw.constant 1 : i2
    %c-2_i2 = hw.constant -2 : i2
    %c0_i30 = hw.constant 0 : i30
    %c-1_i2 = hw.constant -1 : i2
    %c3_i32 = hw.constant 3 : i32
    %c4_i32 = hw.constant 4 : i32
    %c1_i32 = hw.constant 1 : i32
    %0:4 = llhd.combinational -> i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1 {
      %13 = comb.extract %data_reg from 0 : (i32) -> i8
      %14 = hw.struct_create (%13, %data_reg) : !hw.struct<header: i8, payload: i32>
      %15 = hw.array_inject %packet_array[%c-1_i2], %14 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      cf.br ^bb1(%c1_i32, %15 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb1(%16: i32, %17: !hw.array<4xstruct<header: i8, payload: i32>>):  // 2 preds: ^bb0, ^bb2
      %18 = comb.icmp slt %16, %c4_i32 : i32
      cf.cond_br %18, ^bb2, ^bb3(%in_data, %true, %17, %true : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1)
    ^bb2:  // pred: ^bb1
      %19 = comb.sub %c3_i32, %16 : i32
      %20 = comb.extract %19 from 2 : (i32) -> i30
      %21 = comb.icmp eq %20, %c0_i30 : i30
      %22 = comb.extract %19 from 0 : (i32) -> i2
      %23 = comb.mux %21, %22, %c-1_i2 : i2
      %24 = comb.add %16, %c-1_i32 : i32
      %25 = comb.sub %c3_i32, %24 : i32
      %26 = comb.extract %25 from 2 : (i32) -> i30
      %27 = comb.icmp eq %26, %c0_i30 : i30
      %28 = comb.extract %25 from 0 : (i32) -> i2
      %29 = comb.mux %27, %28, %c-1_i2 : i2
      %30 = hw.array_get %packet_array[%29] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %payload_3 = hw.struct_extract %30["payload"] : !hw.struct<header: i8, payload: i32>
      %header = hw.struct_extract %30["header"] : !hw.struct<header: i8, payload: i32>
      %31 = hw.struct_create (%header, %payload_3) : !hw.struct<header: i8, payload: i32>
      %32 = hw.array_inject %17[%23], %31 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %33 = comb.add %16, %c1_i32 : i32
      cf.br ^bb1(%33, %32 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb3(%34: i32, %35: i1, %36: !hw.array<4xstruct<header: i8, payload: i32>>, %37: i1):  // pred: ^bb1
      llhd.yield %34, %35, %36, %37 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1
    }
    %1 = seq.to_clock %clk
    %2 = comb.mux bin %0#1, %in_data, %data_reg : i32
    %data_reg = seq.compreg %2, %1 : i32  
    %3 = comb.mux bin %0#3, %0#2, %packet_array : !hw.array<4xstruct<header: i8, payload: i32>>
    %packet_array = seq.compreg %3, %1 : !hw.array<4xstruct<header: i8, payload: i32>>  
    %4 = hw.array_get %packet_array[%c-1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload = hw.struct_extract %4["payload"] : !hw.struct<header: i8, payload: i32>
    %5 = comb.extract %payload from 0 : (i32) -> i4
    %6 = hw.array_get %packet_array[%c-2_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_0 = hw.struct_extract %6["payload"] : !hw.struct<header: i8, payload: i32>
    %7 = comb.extract %payload_0 from 0 : (i32) -> i4
    %8 = hw.array_get %packet_array[%c1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_1 = hw.struct_extract %8["payload"] : !hw.struct<header: i8, payload: i32>
    %9 = comb.extract %payload_1 from 0 : (i32) -> i4
    %10 = hw.array_get %packet_array[%c0_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_2 = hw.struct_extract %10["payload"] : !hw.struct<header: i8, payload: i32>
    %11 = comb.extract %payload_2 from 0 : (i32) -> i4
    %12 = comb.xor %5, %7, %9, %11 : i4
    hw.output %12 : i4
  }
}


// -----// IR Dump Before ConvertToArcsPass (convert-to-arcs) //----- //
module {
  func.func private @exit(i32)
  hw.module @data_processor(in %clk : i1, in %in_data : i32, out result : i4) {
    %true = hw.constant true
    %c-1_i32 = hw.constant -1 : i32
    %c0_i2 = hw.constant 0 : i2
    %c1_i2 = hw.constant 1 : i2
    %c-2_i2 = hw.constant -2 : i2
    %c0_i30 = hw.constant 0 : i30
    %c-1_i2 = hw.constant -1 : i2
    %c3_i32 = hw.constant 3 : i32
    %c4_i32 = hw.constant 4 : i32
    %c1_i32 = hw.constant 1 : i32
    %0:4 = llhd.combinational -> i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1 {
      %13 = comb.extract %data_reg from 0 : (i32) -> i8
      %14 = hw.struct_create (%13, %data_reg) : !hw.struct<header: i8, payload: i32>
      %15 = hw.array_inject %packet_array[%c-1_i2], %14 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      cf.br ^bb1(%c1_i32, %15 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb1(%16: i32, %17: !hw.array<4xstruct<header: i8, payload: i32>>):  // 2 preds: ^bb0, ^bb2
      %18 = comb.icmp slt %16, %c4_i32 : i32
      cf.cond_br %18, ^bb2, ^bb3(%in_data, %true, %17, %true : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1)
    ^bb2:  // pred: ^bb1
      %19 = comb.sub %c3_i32, %16 : i32
      %20 = comb.extract %19 from 2 : (i32) -> i30
      %21 = comb.icmp eq %20, %c0_i30 : i30
      %22 = comb.extract %19 from 0 : (i32) -> i2
      %23 = comb.mux %21, %22, %c-1_i2 : i2
      %24 = comb.add %16, %c-1_i32 : i32
      %25 = comb.sub %c3_i32, %24 : i32
      %26 = comb.extract %25 from 2 : (i32) -> i30
      %27 = comb.icmp eq %26, %c0_i30 : i30
      %28 = comb.extract %25 from 0 : (i32) -> i2
      %29 = comb.mux %27, %28, %c-1_i2 : i2
      %30 = hw.array_get %packet_array[%29] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %payload_3 = hw.struct_extract %30["payload"] : !hw.struct<header: i8, payload: i32>
      %header = hw.struct_extract %30["header"] : !hw.struct<header: i8, payload: i32>
      %31 = hw.struct_create (%header, %payload_3) : !hw.struct<header: i8, payload: i32>
      %32 = hw.array_inject %17[%23], %31 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %33 = comb.add %16, %c1_i32 : i32
      cf.br ^bb1(%33, %32 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb3(%34: i32, %35: i1, %36: !hw.array<4xstruct<header: i8, payload: i32>>, %37: i1):  // pred: ^bb1
      llhd.yield %34, %35, %36, %37 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1
    }
    %1 = seq.to_clock %clk
    %2 = comb.mux bin %0#1, %in_data, %data_reg : i32
    %data_reg = seq.compreg %2, %1 : i32  
    %3 = comb.mux bin %0#3, %0#2, %packet_array : !hw.array<4xstruct<header: i8, payload: i32>>
    %packet_array = seq.compreg %3, %1 : !hw.array<4xstruct<header: i8, payload: i32>>  
    %4 = hw.array_get %packet_array[%c-1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload = hw.struct_extract %4["payload"] : !hw.struct<header: i8, payload: i32>
    %5 = comb.extract %payload from 0 : (i32) -> i4
    %6 = hw.array_get %packet_array[%c-2_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_0 = hw.struct_extract %6["payload"] : !hw.struct<header: i8, payload: i32>
    %7 = comb.extract %payload_0 from 0 : (i32) -> i4
    %8 = hw.array_get %packet_array[%c1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_1 = hw.struct_extract %8["payload"] : !hw.struct<header: i8, payload: i32>
    %9 = comb.extract %payload_1 from 0 : (i32) -> i4
    %10 = hw.array_get %packet_array[%c0_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_2 = hw.struct_extract %10["payload"] : !hw.struct<header: i8, payload: i32>
    %11 = comb.extract %payload_2 from 0 : (i32) -> i4
    %12 = comb.xor %5, %7, %9, %11 : i4
    hw.output %12 : i4
  }
}


// -----// IR Dump Before Dedup (arc-dedup) //----- //
module {
  func.func private @exit(i32)
  arc.define @data_processor_arc(%arg0: i1, %arg1: i32, %arg2: i32) -> i32 {
    %0 = comb.mux bin %arg0, %arg1, %arg2 : i32
    arc.output %0 : i32
  }
  arc.define @data_processor_arc_0(%arg0: i1, %arg1: !hw.array<4xstruct<header: i8, payload: i32>>, %arg2: !hw.array<4xstruct<header: i8, payload: i32>>) -> !hw.array<4xstruct<header: i8, payload: i32>> {
    %0 = comb.mux bin %arg0, %arg1, %arg2 : !hw.array<4xstruct<header: i8, payload: i32>>
    arc.output %0 : !hw.array<4xstruct<header: i8, payload: i32>>
  }
  arc.define @data_processor_arc_1(%arg0: i1) -> !seq.clock {
    %0 = seq.to_clock %arg0
    arc.output %0 : !seq.clock
  }
  arc.define @data_processor_arc_2(%arg0: !hw.array<4xstruct<header: i8, payload: i32>>, %arg1: i2, %arg2: i2, %arg3: i2, %arg4: i2) -> i4 {
    %0 = hw.array_get %arg0[%arg1] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload = hw.struct_extract %0["payload"] : !hw.struct<header: i8, payload: i32>
    %1 = comb.extract %payload from 0 : (i32) -> i4
    %2 = hw.array_get %arg0[%arg2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_0 = hw.struct_extract %2["payload"] : !hw.struct<header: i8, payload: i32>
    %3 = comb.extract %payload_0 from 0 : (i32) -> i4
    %4 = hw.array_get %arg0[%arg3] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_1 = hw.struct_extract %4["payload"] : !hw.struct<header: i8, payload: i32>
    %5 = comb.extract %payload_1 from 0 : (i32) -> i4
    %6 = hw.array_get %arg0[%arg4] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_2 = hw.struct_extract %6["payload"] : !hw.struct<header: i8, payload: i32>
    %7 = comb.extract %payload_2 from 0 : (i32) -> i4
    %8 = comb.xor %7, %5, %3, %1 : i4
    arc.output %8 : i4
  }
  hw.module @data_processor(in %clk : i1, in %in_data : i32, out result : i4) {
    %true = hw.constant true
    %c-1_i32 = hw.constant -1 : i32
    %c0_i2 = hw.constant 0 : i2
    %c1_i2 = hw.constant 1 : i2
    %c-2_i2 = hw.constant -2 : i2
    %c0_i30 = hw.constant 0 : i30
    %c-1_i2 = hw.constant -1 : i2
    %c3_i32 = hw.constant 3 : i32
    %c4_i32 = hw.constant 4 : i32
    %c1_i32 = hw.constant 1 : i32
    %0:4 = arc.execute (%1, %2, %in_data : i32, !hw.array<4xstruct<header: i8, payload: i32>>, i32) -> (i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1) {
    ^bb0(%arg0: i32, %arg1: !hw.array<4xstruct<header: i8, payload: i32>>, %arg2: i32):
      %c-1_i2_0 = hw.constant -1 : i2
      %c1_i32_1 = hw.constant 1 : i32
      %c4_i32_2 = hw.constant 4 : i32
      %true_3 = hw.constant true
      %c3_i32_4 = hw.constant 3 : i32
      %c0_i30_5 = hw.constant 0 : i30
      %c-1_i32_6 = hw.constant -1 : i32
      %5 = comb.extract %arg0 from 0 : (i32) -> i8
      %6 = hw.struct_create (%5, %arg0) : !hw.struct<header: i8, payload: i32>
      %7 = hw.array_inject %arg1[%c-1_i2_0], %6 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      cf.br ^bb1(%c1_i32_1, %7 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb1(%8: i32, %9: !hw.array<4xstruct<header: i8, payload: i32>>):  // 2 preds: ^bb0, ^bb2
      %10 = comb.icmp slt %8, %c4_i32_2 : i32
      cf.cond_br %10, ^bb2, ^bb3(%arg2, %true_3, %9, %true_3 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1)
    ^bb2:  // pred: ^bb1
      %11 = comb.sub %c3_i32_4, %8 : i32
      %12 = comb.extract %11 from 2 : (i32) -> i30
      %13 = comb.icmp eq %12, %c0_i30_5 : i30
      %14 = comb.extract %11 from 0 : (i32) -> i2
      %15 = comb.mux %13, %14, %c-1_i2_0 : i2
      %16 = comb.add %8, %c-1_i32_6 : i32
      %17 = comb.sub %c3_i32_4, %16 : i32
      %18 = comb.extract %17 from 2 : (i32) -> i30
      %19 = comb.icmp eq %18, %c0_i30_5 : i30
      %20 = comb.extract %17 from 0 : (i32) -> i2
      %21 = comb.mux %19, %20, %c-1_i2_0 : i2
      %22 = hw.array_get %arg1[%21] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %payload = hw.struct_extract %22["payload"] : !hw.struct<header: i8, payload: i32>
      %header = hw.struct_extract %22["header"] : !hw.struct<header: i8, payload: i32>
      %23 = hw.struct_create (%header, %payload) : !hw.struct<header: i8, payload: i32>
      %24 = hw.array_inject %9[%15], %23 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %25 = comb.add %8, %c1_i32_1 : i32
      cf.br ^bb1(%25, %24 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb3(%26: i32, %27: i1, %28: !hw.array<4xstruct<header: i8, payload: i32>>, %29: i1):  // pred: ^bb1
      arc.output %26, %27, %28, %29 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1
    }
    %1 = arc.state @data_processor_arc(%0#1, %in_data, %1) clock %3 latency 1 : (i1, i32, i32) -> i32
    %2 = arc.state @data_processor_arc_0(%0#3, %0#2, %2) clock %3 latency 1 : (i1, !hw.array<4xstruct<header: i8, payload: i32>>, !hw.array<4xstruct<header: i8, payload: i32>>) -> !hw.array<4xstruct<header: i8, payload: i32>>
    %3 = arc.call @data_processor_arc_1(%clk) : (i1) -> !seq.clock
    %4 = arc.call @data_processor_arc_2(%2, %c0_i2, %c1_i2, %c-2_i2, %c-1_i2) : (!hw.array<4xstruct<header: i8, payload: i32>>, i2, i2, i2, i2) -> i4
    hw.output %4 : i4
  }
}


// -----// IR Dump Before FlattenModules (hw-flatten-modules) //----- //
module {
  func.func private @exit(i32)
  arc.define @data_processor_arc(%arg0: i1, %arg1: i32, %arg2: i32) -> i32 {
    %0 = comb.mux bin %arg0, %arg1, %arg2 : i32
    arc.output %0 : i32
  }
  arc.define @data_processor_arc_0(%arg0: i1, %arg1: !hw.array<4xstruct<header: i8, payload: i32>>, %arg2: !hw.array<4xstruct<header: i8, payload: i32>>) -> !hw.array<4xstruct<header: i8, payload: i32>> {
    %0 = comb.mux bin %arg0, %arg1, %arg2 : !hw.array<4xstruct<header: i8, payload: i32>>
    arc.output %0 : !hw.array<4xstruct<header: i8, payload: i32>>
  }
  arc.define @data_processor_arc_1(%arg0: i1) -> !seq.clock {
    %0 = seq.to_clock %arg0
    arc.output %0 : !seq.clock
  }
  arc.define @data_processor_arc_2(%arg0: !hw.array<4xstruct<header: i8, payload: i32>>, %arg1: i2, %arg2: i2, %arg3: i2, %arg4: i2) -> i4 {
    %0 = hw.array_get %arg0[%arg1] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload = hw.struct_extract %0["payload"] : !hw.struct<header: i8, payload: i32>
    %1 = comb.extract %payload from 0 : (i32) -> i4
    %2 = hw.array_get %arg0[%arg2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_0 = hw.struct_extract %2["payload"] : !hw.struct<header: i8, payload: i32>
    %3 = comb.extract %payload_0 from 0 : (i32) -> i4
    %4 = hw.array_get %arg0[%arg3] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_1 = hw.struct_extract %4["payload"] : !hw.struct<header: i8, payload: i32>
    %5 = comb.extract %payload_1 from 0 : (i32) -> i4
    %6 = hw.array_get %arg0[%arg4] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_2 = hw.struct_extract %6["payload"] : !hw.struct<header: i8, payload: i32>
    %7 = comb.extract %payload_2 from 0 : (i32) -> i4
    %8 = comb.xor %7, %5, %3, %1 : i4
    arc.output %8 : i4
  }
  hw.module @data_processor(in %clk : i1, in %in_data : i32, out result : i4) {
    %true = hw.constant true
    %c-1_i32 = hw.constant -1 : i32
    %c0_i2 = hw.constant 0 : i2
    %c1_i2 = hw.constant 1 : i2
    %c-2_i2 = hw.constant -2 : i2
    %c0_i30 = hw.constant 0 : i30
    %c-1_i2 = hw.constant -1 : i2
    %c3_i32 = hw.constant 3 : i32
    %c4_i32 = hw.constant 4 : i32
    %c1_i32 = hw.constant 1 : i32
    %0:4 = arc.execute (%1, %2, %in_data : i32, !hw.array<4xstruct<header: i8, payload: i32>>, i32) -> (i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1) {
    ^bb0(%arg0: i32, %arg1: !hw.array<4xstruct<header: i8, payload: i32>>, %arg2: i32):
      %c-1_i2_0 = hw.constant -1 : i2
      %c1_i32_1 = hw.constant 1 : i32
      %c4_i32_2 = hw.constant 4 : i32
      %true_3 = hw.constant true
      %c3_i32_4 = hw.constant 3 : i32
      %c0_i30_5 = hw.constant 0 : i30
      %c-1_i32_6 = hw.constant -1 : i32
      %5 = comb.extract %arg0 from 0 : (i32) -> i8
      %6 = hw.struct_create (%5, %arg0) : !hw.struct<header: i8, payload: i32>
      %7 = hw.array_inject %arg1[%c-1_i2_0], %6 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      cf.br ^bb1(%c1_i32_1, %7 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb1(%8: i32, %9: !hw.array<4xstruct<header: i8, payload: i32>>):  // 2 preds: ^bb0, ^bb2
      %10 = comb.icmp slt %8, %c4_i32_2 : i32
      cf.cond_br %10, ^bb2, ^bb3(%arg2, %true_3, %9, %true_3 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1)
    ^bb2:  // pred: ^bb1
      %11 = comb.sub %c3_i32_4, %8 : i32
      %12 = comb.extract %11 from 2 : (i32) -> i30
      %13 = comb.icmp eq %12, %c0_i30_5 : i30
      %14 = comb.extract %11 from 0 : (i32) -> i2
      %15 = comb.mux %13, %14, %c-1_i2_0 : i2
      %16 = comb.add %8, %c-1_i32_6 : i32
      %17 = comb.sub %c3_i32_4, %16 : i32
      %18 = comb.extract %17 from 2 : (i32) -> i30
      %19 = comb.icmp eq %18, %c0_i30_5 : i30
      %20 = comb.extract %17 from 0 : (i32) -> i2
      %21 = comb.mux %19, %20, %c-1_i2_0 : i2
      %22 = hw.array_get %arg1[%21] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %payload = hw.struct_extract %22["payload"] : !hw.struct<header: i8, payload: i32>
      %header = hw.struct_extract %22["header"] : !hw.struct<header: i8, payload: i32>
      %23 = hw.struct_create (%header, %payload) : !hw.struct<header: i8, payload: i32>
      %24 = hw.array_inject %9[%15], %23 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %25 = comb.add %8, %c1_i32_1 : i32
      cf.br ^bb1(%25, %24 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb3(%26: i32, %27: i1, %28: !hw.array<4xstruct<header: i8, payload: i32>>, %29: i1):  // pred: ^bb1
      arc.output %26, %27, %28, %29 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1
    }
    %1 = arc.state @data_processor_arc(%0#1, %in_data, %1) clock %3 latency 1 : (i1, i32, i32) -> i32
    %2 = arc.state @data_processor_arc_0(%0#3, %0#2, %2) clock %3 latency 1 : (i1, !hw.array<4xstruct<header: i8, payload: i32>>, !hw.array<4xstruct<header: i8, payload: i32>>) -> !hw.array<4xstruct<header: i8, payload: i32>>
    %3 = arc.call @data_processor_arc_1(%clk) : (i1) -> !seq.clock
    %4 = arc.call @data_processor_arc_2(%2, %c0_i2, %c1_i2, %c-2_i2, %c-1_i2) : (!hw.array<4xstruct<header: i8, payload: i32>>, i2, i2, i2, i2) -> i4
    hw.output %4 : i4
  }
}


// -----// IR Dump Before CSE (cse) //----- //
module {
  func.func private @exit(i32)
  arc.define @data_processor_arc(%arg0: i1, %arg1: i32, %arg2: i32) -> i32 {
    %0 = comb.mux bin %arg0, %arg1, %arg2 : i32
    arc.output %0 : i32
  }
  arc.define @data_processor_arc_0(%arg0: i1, %arg1: !hw.array<4xstruct<header: i8, payload: i32>>, %arg2: !hw.array<4xstruct<header: i8, payload: i32>>) -> !hw.array<4xstruct<header: i8, payload: i32>> {
    %0 = comb.mux bin %arg0, %arg1, %arg2 : !hw.array<4xstruct<header: i8, payload: i32>>
    arc.output %0 : !hw.array<4xstruct<header: i8, payload: i32>>
  }
  arc.define @data_processor_arc_1(%arg0: i1) -> !seq.clock {
    %0 = seq.to_clock %arg0
    arc.output %0 : !seq.clock
  }
  arc.define @data_processor_arc_2(%arg0: !hw.array<4xstruct<header: i8, payload: i32>>, %arg1: i2, %arg2: i2, %arg3: i2, %arg4: i2) -> i4 {
    %0 = hw.array_get %arg0[%arg1] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload = hw.struct_extract %0["payload"] : !hw.struct<header: i8, payload: i32>
    %1 = comb.extract %payload from 0 : (i32) -> i4
    %2 = hw.array_get %arg0[%arg2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_0 = hw.struct_extract %2["payload"] : !hw.struct<header: i8, payload: i32>
    %3 = comb.extract %payload_0 from 0 : (i32) -> i4
    %4 = hw.array_get %arg0[%arg3] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_1 = hw.struct_extract %4["payload"] : !hw.struct<header: i8, payload: i32>
    %5 = comb.extract %payload_1 from 0 : (i32) -> i4
    %6 = hw.array_get %arg0[%arg4] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_2 = hw.struct_extract %6["payload"] : !hw.struct<header: i8, payload: i32>
    %7 = comb.extract %payload_2 from 0 : (i32) -> i4
    %8 = comb.xor %7, %5, %3, %1 : i4
    arc.output %8 : i4
  }
  hw.module @data_processor(in %clk : i1, in %in_data : i32, out result : i4) {
    %true = hw.constant true
    %c-1_i32 = hw.constant -1 : i32
    %c0_i2 = hw.constant 0 : i2
    %c1_i2 = hw.constant 1 : i2
    %c-2_i2 = hw.constant -2 : i2
    %c0_i30 = hw.constant 0 : i30
    %c-1_i2 = hw.constant -1 : i2
    %c3_i32 = hw.constant 3 : i32
    %c4_i32 = hw.constant 4 : i32
    %c1_i32 = hw.constant 1 : i32
    %0:4 = arc.execute (%1, %2, %in_data : i32, !hw.array<4xstruct<header: i8, payload: i32>>, i32) -> (i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1) {
    ^bb0(%arg0: i32, %arg1: !hw.array<4xstruct<header: i8, payload: i32>>, %arg2: i32):
      %c-1_i2_0 = hw.constant -1 : i2
      %c1_i32_1 = hw.constant 1 : i32
      %c4_i32_2 = hw.constant 4 : i32
      %true_3 = hw.constant true
      %c3_i32_4 = hw.constant 3 : i32
      %c0_i30_5 = hw.constant 0 : i30
      %c-1_i32_6 = hw.constant -1 : i32
      %5 = comb.extract %arg0 from 0 : (i32) -> i8
      %6 = hw.struct_create (%5, %arg0) : !hw.struct<header: i8, payload: i32>
      %7 = hw.array_inject %arg1[%c-1_i2_0], %6 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      cf.br ^bb1(%c1_i32_1, %7 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb1(%8: i32, %9: !hw.array<4xstruct<header: i8, payload: i32>>):  // 2 preds: ^bb0, ^bb2
      %10 = comb.icmp slt %8, %c4_i32_2 : i32
      cf.cond_br %10, ^bb2, ^bb3(%arg2, %true_3, %9, %true_3 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1)
    ^bb2:  // pred: ^bb1
      %11 = comb.sub %c3_i32_4, %8 : i32
      %12 = comb.extract %11 from 2 : (i32) -> i30
      %13 = comb.icmp eq %12, %c0_i30_5 : i30
      %14 = comb.extract %11 from 0 : (i32) -> i2
      %15 = comb.mux %13, %14, %c-1_i2_0 : i2
      %16 = comb.add %8, %c-1_i32_6 : i32
      %17 = comb.sub %c3_i32_4, %16 : i32
      %18 = comb.extract %17 from 2 : (i32) -> i30
      %19 = comb.icmp eq %18, %c0_i30_5 : i30
      %20 = comb.extract %17 from 0 : (i32) -> i2
      %21 = comb.mux %19, %20, %c-1_i2_0 : i2
      %22 = hw.array_get %arg1[%21] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %payload = hw.struct_extract %22["payload"] : !hw.struct<header: i8, payload: i32>
      %header = hw.struct_extract %22["header"] : !hw.struct<header: i8, payload: i32>
      %23 = hw.struct_create (%header, %payload) : !hw.struct<header: i8, payload: i32>
      %24 = hw.array_inject %9[%15], %23 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %25 = comb.add %8, %c1_i32_1 : i32
      cf.br ^bb1(%25, %24 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb3(%26: i32, %27: i1, %28: !hw.array<4xstruct<header: i8, payload: i32>>, %29: i1):  // pred: ^bb1
      arc.output %26, %27, %28, %29 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1
    }
    %1 = arc.state @data_processor_arc(%0#1, %in_data, %1) clock %3 latency 1 : (i1, i32, i32) -> i32
    %2 = arc.state @data_processor_arc_0(%0#3, %0#2, %2) clock %3 latency 1 : (i1, !hw.array<4xstruct<header: i8, payload: i32>>, !hw.array<4xstruct<header: i8, payload: i32>>) -> !hw.array<4xstruct<header: i8, payload: i32>>
    %3 = arc.call @data_processor_arc_1(%clk) : (i1) -> !seq.clock
    %4 = arc.call @data_processor_arc_2(%2, %c0_i2, %c1_i2, %c-2_i2, %c-1_i2) : (!hw.array<4xstruct<header: i8, payload: i32>>, i2, i2, i2, i2) -> i4
    hw.output %4 : i4
  }
}


// -----// IR Dump Before ArcCanonicalizer (arc-canonicalizer) //----- //
module {
  func.func private @exit(i32)
  arc.define @data_processor_arc(%arg0: i1, %arg1: i32, %arg2: i32) -> i32 {
    %0 = comb.mux bin %arg0, %arg1, %arg2 : i32
    arc.output %0 : i32
  }
  arc.define @data_processor_arc_0(%arg0: i1, %arg1: !hw.array<4xstruct<header: i8, payload: i32>>, %arg2: !hw.array<4xstruct<header: i8, payload: i32>>) -> !hw.array<4xstruct<header: i8, payload: i32>> {
    %0 = comb.mux bin %arg0, %arg1, %arg2 : !hw.array<4xstruct<header: i8, payload: i32>>
    arc.output %0 : !hw.array<4xstruct<header: i8, payload: i32>>
  }
  arc.define @data_processor_arc_1(%arg0: i1) -> !seq.clock {
    %0 = seq.to_clock %arg0
    arc.output %0 : !seq.clock
  }
  arc.define @data_processor_arc_2(%arg0: !hw.array<4xstruct<header: i8, payload: i32>>, %arg1: i2, %arg2: i2, %arg3: i2, %arg4: i2) -> i4 {
    %0 = hw.array_get %arg0[%arg1] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload = hw.struct_extract %0["payload"] : !hw.struct<header: i8, payload: i32>
    %1 = comb.extract %payload from 0 : (i32) -> i4
    %2 = hw.array_get %arg0[%arg2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_0 = hw.struct_extract %2["payload"] : !hw.struct<header: i8, payload: i32>
    %3 = comb.extract %payload_0 from 0 : (i32) -> i4
    %4 = hw.array_get %arg0[%arg3] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_1 = hw.struct_extract %4["payload"] : !hw.struct<header: i8, payload: i32>
    %5 = comb.extract %payload_1 from 0 : (i32) -> i4
    %6 = hw.array_get %arg0[%arg4] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_2 = hw.struct_extract %6["payload"] : !hw.struct<header: i8, payload: i32>
    %7 = comb.extract %payload_2 from 0 : (i32) -> i4
    %8 = comb.xor %7, %5, %3, %1 : i4
    arc.output %8 : i4
  }
  hw.module @data_processor(in %clk : i1, in %in_data : i32, out result : i4) {
    %c0_i2 = hw.constant 0 : i2
    %c1_i2 = hw.constant 1 : i2
    %c-2_i2 = hw.constant -2 : i2
    %c-1_i2 = hw.constant -1 : i2
    %0:4 = arc.execute (%1, %2, %in_data : i32, !hw.array<4xstruct<header: i8, payload: i32>>, i32) -> (i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1) {
    ^bb0(%arg0: i32, %arg1: !hw.array<4xstruct<header: i8, payload: i32>>, %arg2: i32):
      %c-1_i2_0 = hw.constant -1 : i2
      %c1_i32 = hw.constant 1 : i32
      %c4_i32 = hw.constant 4 : i32
      %true = hw.constant true
      %c3_i32 = hw.constant 3 : i32
      %c0_i30 = hw.constant 0 : i30
      %c-1_i32 = hw.constant -1 : i32
      %5 = comb.extract %arg0 from 0 : (i32) -> i8
      %6 = hw.struct_create (%5, %arg0) : !hw.struct<header: i8, payload: i32>
      %7 = hw.array_inject %arg1[%c-1_i2_0], %6 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      cf.br ^bb1(%c1_i32, %7 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb1(%8: i32, %9: !hw.array<4xstruct<header: i8, payload: i32>>):  // 2 preds: ^bb0, ^bb2
      %10 = comb.icmp slt %8, %c4_i32 : i32
      cf.cond_br %10, ^bb2, ^bb3(%arg2, %true, %9, %true : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1)
    ^bb2:  // pred: ^bb1
      %11 = comb.sub %c3_i32, %8 : i32
      %12 = comb.extract %11 from 2 : (i32) -> i30
      %13 = comb.icmp eq %12, %c0_i30 : i30
      %14 = comb.extract %11 from 0 : (i32) -> i2
      %15 = comb.mux %13, %14, %c-1_i2_0 : i2
      %16 = comb.add %8, %c-1_i32 : i32
      %17 = comb.sub %c3_i32, %16 : i32
      %18 = comb.extract %17 from 2 : (i32) -> i30
      %19 = comb.icmp eq %18, %c0_i30 : i30
      %20 = comb.extract %17 from 0 : (i32) -> i2
      %21 = comb.mux %19, %20, %c-1_i2_0 : i2
      %22 = hw.array_get %arg1[%21] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %payload = hw.struct_extract %22["payload"] : !hw.struct<header: i8, payload: i32>
      %header = hw.struct_extract %22["header"] : !hw.struct<header: i8, payload: i32>
      %23 = hw.struct_create (%header, %payload) : !hw.struct<header: i8, payload: i32>
      %24 = hw.array_inject %9[%15], %23 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %25 = comb.add %8, %c1_i32 : i32
      cf.br ^bb1(%25, %24 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb3(%26: i32, %27: i1, %28: !hw.array<4xstruct<header: i8, payload: i32>>, %29: i1):  // pred: ^bb1
      arc.output %26, %27, %28, %29 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1
    }
    %1 = arc.state @data_processor_arc(%0#1, %in_data, %1) clock %3 latency 1 : (i1, i32, i32) -> i32
    %2 = arc.state @data_processor_arc_0(%0#3, %0#2, %2) clock %3 latency 1 : (i1, !hw.array<4xstruct<header: i8, payload: i32>>, !hw.array<4xstruct<header: i8, payload: i32>>) -> !hw.array<4xstruct<header: i8, payload: i32>>
    %3 = arc.call @data_processor_arc_1(%clk) : (i1) -> !seq.clock
    %4 = arc.call @data_processor_arc_2(%2, %c0_i2, %c1_i2, %c-2_i2, %c-1_i2) : (!hw.array<4xstruct<header: i8, payload: i32>>, i2, i2, i2, i2) -> i4
    hw.output %4 : i4
  }
}


// -----// IR Dump Before SplitLoops (arc-split-loops) //----- //
module {
  func.func private @exit(i32)
  arc.define @data_processor_arc(%arg0: i1, %arg1: i32, %arg2: i32) -> i32 {
    %0 = comb.mux bin %arg0, %arg1, %arg2 : i32
    arc.output %0 : i32
  }
  arc.define @data_processor_arc_0(%arg0: i1, %arg1: !hw.array<4xstruct<header: i8, payload: i32>>, %arg2: !hw.array<4xstruct<header: i8, payload: i32>>) -> !hw.array<4xstruct<header: i8, payload: i32>> {
    %0 = comb.mux bin %arg0, %arg1, %arg2 : !hw.array<4xstruct<header: i8, payload: i32>>
    arc.output %0 : !hw.array<4xstruct<header: i8, payload: i32>>
  }
  arc.define @data_processor_arc_1(%arg0: i1) -> !seq.clock {
    %0 = seq.to_clock %arg0
    arc.output %0 : !seq.clock
  }
  arc.define @data_processor_arc_2(%arg0: !hw.array<4xstruct<header: i8, payload: i32>>) -> i4 {
    %c0_i2 = hw.constant 0 : i2
    %c1_i2 = hw.constant 1 : i2
    %c-2_i2 = hw.constant -2 : i2
    %c-1_i2 = hw.constant -1 : i2
    %0 = hw.array_get %arg0[%c0_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload = hw.struct_extract %0["payload"] : !hw.struct<header: i8, payload: i32>
    %1 = comb.extract %payload from 0 : (i32) -> i4
    %2 = hw.array_get %arg0[%c1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_0 = hw.struct_extract %2["payload"] : !hw.struct<header: i8, payload: i32>
    %3 = comb.extract %payload_0 from 0 : (i32) -> i4
    %4 = hw.array_get %arg0[%c-2_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_1 = hw.struct_extract %4["payload"] : !hw.struct<header: i8, payload: i32>
    %5 = comb.extract %payload_1 from 0 : (i32) -> i4
    %6 = hw.array_get %arg0[%c-1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_2 = hw.struct_extract %6["payload"] : !hw.struct<header: i8, payload: i32>
    %7 = comb.extract %payload_2 from 0 : (i32) -> i4
    %8 = comb.xor %7, %5, %3, %1 : i4
    arc.output %8 : i4
  }
  hw.module @data_processor(in %clk : i1, in %in_data : i32, out result : i4) {
    %0:4 = arc.execute (%1, %2, %in_data : i32, !hw.array<4xstruct<header: i8, payload: i32>>, i32) -> (i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1) {
    ^bb0(%arg0: i32, %arg1: !hw.array<4xstruct<header: i8, payload: i32>>, %arg2: i32):
      %c-1_i2 = hw.constant -1 : i2
      %c1_i32 = hw.constant 1 : i32
      %c4_i32 = hw.constant 4 : i32
      %true = hw.constant true
      %c3_i32 = hw.constant 3 : i32
      %c0_i30 = hw.constant 0 : i30
      %c-1_i32 = hw.constant -1 : i32
      %5 = comb.extract %arg0 from 0 : (i32) -> i8
      %6 = hw.struct_create (%5, %arg0) : !hw.struct<header: i8, payload: i32>
      %7 = hw.array_inject %arg1[%c-1_i2], %6 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      cf.br ^bb1(%c1_i32, %7 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb1(%8: i32, %9: !hw.array<4xstruct<header: i8, payload: i32>>):  // 2 preds: ^bb0, ^bb2
      %10 = comb.icmp slt %8, %c4_i32 : i32
      cf.cond_br %10, ^bb2, ^bb3(%arg2, %true, %9, %true : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1)
    ^bb2:  // pred: ^bb1
      %11 = comb.sub %c3_i32, %8 : i32
      %12 = comb.extract %11 from 2 : (i32) -> i30
      %13 = comb.icmp eq %12, %c0_i30 : i30
      %14 = comb.extract %11 from 0 : (i32) -> i2
      %15 = comb.mux %13, %14, %c-1_i2 : i2
      %16 = comb.add %8, %c-1_i32 : i32
      %17 = comb.sub %c3_i32, %16 : i32
      %18 = comb.extract %17 from 2 : (i32) -> i30
      %19 = comb.icmp eq %18, %c0_i30 : i30
      %20 = comb.extract %17 from 0 : (i32) -> i2
      %21 = comb.mux %19, %20, %c-1_i2 : i2
      %22 = hw.array_get %arg1[%21] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %payload = hw.struct_extract %22["payload"] : !hw.struct<header: i8, payload: i32>
      %header = hw.struct_extract %22["header"] : !hw.struct<header: i8, payload: i32>
      %23 = hw.struct_create (%header, %payload) : !hw.struct<header: i8, payload: i32>
      %24 = hw.array_inject %9[%15], %23 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %25 = comb.add %8, %c1_i32 : i32
      cf.br ^bb1(%25, %24 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb3(%26: i32, %27: i1, %28: !hw.array<4xstruct<header: i8, payload: i32>>, %29: i1):  // pred: ^bb1
      arc.output %26, %27, %28, %29 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1
    }
    %1 = arc.state @data_processor_arc(%0#1, %in_data, %1) clock %3 latency 1 : (i1, i32, i32) -> i32
    %2 = arc.state @data_processor_arc_0(%0#3, %0#2, %2) clock %3 latency 1 : (i1, !hw.array<4xstruct<header: i8, payload: i32>>, !hw.array<4xstruct<header: i8, payload: i32>>) -> !hw.array<4xstruct<header: i8, payload: i32>>
    %3 = arc.call @data_processor_arc_1(%clk) : (i1) -> !seq.clock
    %4 = arc.call @data_processor_arc_2(%2) : (!hw.array<4xstruct<header: i8, payload: i32>>) -> i4
    hw.output %4 : i4
  }
}


// -----// IR Dump Before Dedup (arc-dedup) //----- //
module {
  func.func private @exit(i32)
  arc.define @data_processor_arc(%arg0: i1, %arg1: i32, %arg2: i32) -> i32 {
    %0 = comb.mux bin %arg0, %arg1, %arg2 : i32
    arc.output %0 : i32
  }
  arc.define @data_processor_arc_0(%arg0: i1, %arg1: !hw.array<4xstruct<header: i8, payload: i32>>, %arg2: !hw.array<4xstruct<header: i8, payload: i32>>) -> !hw.array<4xstruct<header: i8, payload: i32>> {
    %0 = comb.mux bin %arg0, %arg1, %arg2 : !hw.array<4xstruct<header: i8, payload: i32>>
    arc.output %0 : !hw.array<4xstruct<header: i8, payload: i32>>
  }
  arc.define @data_processor_arc_1(%arg0: i1) -> !seq.clock {
    %0 = seq.to_clock %arg0
    arc.output %0 : !seq.clock
  }
  arc.define @data_processor_arc_2(%arg0: !hw.array<4xstruct<header: i8, payload: i32>>) -> i4 {
    %c0_i2 = hw.constant 0 : i2
    %c1_i2 = hw.constant 1 : i2
    %c-2_i2 = hw.constant -2 : i2
    %c-1_i2 = hw.constant -1 : i2
    %0 = hw.array_get %arg0[%c0_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload = hw.struct_extract %0["payload"] : !hw.struct<header: i8, payload: i32>
    %1 = comb.extract %payload from 0 : (i32) -> i4
    %2 = hw.array_get %arg0[%c1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_0 = hw.struct_extract %2["payload"] : !hw.struct<header: i8, payload: i32>
    %3 = comb.extract %payload_0 from 0 : (i32) -> i4
    %4 = hw.array_get %arg0[%c-2_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_1 = hw.struct_extract %4["payload"] : !hw.struct<header: i8, payload: i32>
    %5 = comb.extract %payload_1 from 0 : (i32) -> i4
    %6 = hw.array_get %arg0[%c-1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_2 = hw.struct_extract %6["payload"] : !hw.struct<header: i8, payload: i32>
    %7 = comb.extract %payload_2 from 0 : (i32) -> i4
    %8 = comb.xor %7, %5, %3, %1 : i4
    arc.output %8 : i4
  }
  hw.module @data_processor(in %clk : i1, in %in_data : i32, out result : i4) {
    %0:4 = arc.execute (%1, %2, %in_data : i32, !hw.array<4xstruct<header: i8, payload: i32>>, i32) -> (i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1) {
    ^bb0(%arg0: i32, %arg1: !hw.array<4xstruct<header: i8, payload: i32>>, %arg2: i32):
      %c-1_i2 = hw.constant -1 : i2
      %c1_i32 = hw.constant 1 : i32
      %c4_i32 = hw.constant 4 : i32
      %true = hw.constant true
      %c3_i32 = hw.constant 3 : i32
      %c0_i30 = hw.constant 0 : i30
      %c-1_i32 = hw.constant -1 : i32
      %5 = comb.extract %arg0 from 0 : (i32) -> i8
      %6 = hw.struct_create (%5, %arg0) : !hw.struct<header: i8, payload: i32>
      %7 = hw.array_inject %arg1[%c-1_i2], %6 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      cf.br ^bb1(%c1_i32, %7 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb1(%8: i32, %9: !hw.array<4xstruct<header: i8, payload: i32>>):  // 2 preds: ^bb0, ^bb2
      %10 = comb.icmp slt %8, %c4_i32 : i32
      cf.cond_br %10, ^bb2, ^bb3(%arg2, %true, %9, %true : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1)
    ^bb2:  // pred: ^bb1
      %11 = comb.sub %c3_i32, %8 : i32
      %12 = comb.extract %11 from 2 : (i32) -> i30
      %13 = comb.icmp eq %12, %c0_i30 : i30
      %14 = comb.extract %11 from 0 : (i32) -> i2
      %15 = comb.mux %13, %14, %c-1_i2 : i2
      %16 = comb.add %8, %c-1_i32 : i32
      %17 = comb.sub %c3_i32, %16 : i32
      %18 = comb.extract %17 from 2 : (i32) -> i30
      %19 = comb.icmp eq %18, %c0_i30 : i30
      %20 = comb.extract %17 from 0 : (i32) -> i2
      %21 = comb.mux %19, %20, %c-1_i2 : i2
      %22 = hw.array_get %arg1[%21] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %payload = hw.struct_extract %22["payload"] : !hw.struct<header: i8, payload: i32>
      %header = hw.struct_extract %22["header"] : !hw.struct<header: i8, payload: i32>
      %23 = hw.struct_create (%header, %payload) : !hw.struct<header: i8, payload: i32>
      %24 = hw.array_inject %9[%15], %23 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %25 = comb.add %8, %c1_i32 : i32
      cf.br ^bb1(%25, %24 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb3(%26: i32, %27: i1, %28: !hw.array<4xstruct<header: i8, payload: i32>>, %29: i1):  // pred: ^bb1
      arc.output %26, %27, %28, %29 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1
    }
    %1 = arc.state @data_processor_arc(%0#1, %in_data, %1) clock %3 latency 1 : (i1, i32, i32) -> i32
    %2 = arc.state @data_processor_arc_0(%0#3, %0#2, %2) clock %3 latency 1 : (i1, !hw.array<4xstruct<header: i8, payload: i32>>, !hw.array<4xstruct<header: i8, payload: i32>>) -> !hw.array<4xstruct<header: i8, payload: i32>>
    %3 = arc.call @data_processor_arc_1(%clk) : (i1) -> !seq.clock
    %4 = arc.call @data_processor_arc_2(%2) : (!hw.array<4xstruct<header: i8, payload: i32>>) -> i4
    hw.output %4 : i4
  }
}


// -----// IR Dump Before InferStateProperties (arc-infer-state-properties) //----- //
module {
  func.func private @exit(i32)
  arc.define @data_processor_arc(%arg0: i1, %arg1: i32, %arg2: i32) -> i32 {
    %0 = comb.mux bin %arg0, %arg1, %arg2 : i32
    arc.output %0 : i32
  }
  arc.define @data_processor_arc_0(%arg0: i1, %arg1: !hw.array<4xstruct<header: i8, payload: i32>>, %arg2: !hw.array<4xstruct<header: i8, payload: i32>>) -> !hw.array<4xstruct<header: i8, payload: i32>> {
    %0 = comb.mux bin %arg0, %arg1, %arg2 : !hw.array<4xstruct<header: i8, payload: i32>>
    arc.output %0 : !hw.array<4xstruct<header: i8, payload: i32>>
  }
  arc.define @data_processor_arc_1(%arg0: i1) -> !seq.clock {
    %0 = seq.to_clock %arg0
    arc.output %0 : !seq.clock
  }
  arc.define @data_processor_arc_2(%arg0: !hw.array<4xstruct<header: i8, payload: i32>>) -> i4 {
    %c0_i2 = hw.constant 0 : i2
    %c1_i2 = hw.constant 1 : i2
    %c-2_i2 = hw.constant -2 : i2
    %c-1_i2 = hw.constant -1 : i2
    %0 = hw.array_get %arg0[%c0_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload = hw.struct_extract %0["payload"] : !hw.struct<header: i8, payload: i32>
    %1 = comb.extract %payload from 0 : (i32) -> i4
    %2 = hw.array_get %arg0[%c1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_0 = hw.struct_extract %2["payload"] : !hw.struct<header: i8, payload: i32>
    %3 = comb.extract %payload_0 from 0 : (i32) -> i4
    %4 = hw.array_get %arg0[%c-2_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_1 = hw.struct_extract %4["payload"] : !hw.struct<header: i8, payload: i32>
    %5 = comb.extract %payload_1 from 0 : (i32) -> i4
    %6 = hw.array_get %arg0[%c-1_i2] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
    %payload_2 = hw.struct_extract %6["payload"] : !hw.struct<header: i8, payload: i32>
    %7 = comb.extract %payload_2 from 0 : (i32) -> i4
    %8 = comb.xor %7, %5, %3, %1 : i4
    arc.output %8 : i4
  }
  hw.module @data_processor(in %clk : i1, in %in_data : i32, out result : i4) {
    %0:4 = arc.execute (%1, %2, %in_data : i32, !hw.array<4xstruct<header: i8, payload: i32>>, i32) -> (i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1) {
    ^bb0(%arg0: i32, %arg1: !hw.array<4xstruct<header: i8, payload: i32>>, %arg2: i32):
      %c-1_i2 = hw.constant -1 : i2
      %c1_i32 = hw.constant 1 : i32
      %c4_i32 = hw.constant 4 : i32
      %true = hw.constant true
      %c3_i32 = hw.constant 3 : i32
      %c0_i30 = hw.constant 0 : i30
      %c-1_i32 = hw.constant -1 : i32
      %5 = comb.extract %arg0 from 0 : (i32) -> i8
      %6 = hw.struct_create (%5, %arg0) : !hw.struct<header: i8, payload: i32>
      %7 = hw.array_inject %arg1[%c-1_i2], %6 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      cf.br ^bb1(%c1_i32, %7 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb1(%8: i32, %9: !hw.array<4xstruct<header: i8, payload: i32>>):  // 2 preds: ^bb0, ^bb2
      %10 = comb.icmp slt %8, %c4_i32 : i32
      cf.cond_br %10, ^bb2, ^bb3(%arg2, %true, %9, %true : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1)
    ^bb2:  // pred: ^bb1
      %11 = comb.sub %c3_i32, %8 : i32
      %12 = comb.extract %11 from 2 : (i32) -> i30
      %13 = comb.icmp eq %12, %c0_i30 : i30
      %14 = comb.extract %11 from 0 : (i32) -> i2
      %15 = comb.mux %13, %14, %c-1_i2 : i2
      %16 = comb.add %8, %c-1_i32 : i32
      %17 = comb.sub %c3_i32, %16 : i32
      %18 = comb.extract %17 from 2 : (i32) -> i30
      %19 = comb.icmp eq %18, %c0_i30 : i30
      %20 = comb.extract %17 from 0 : (i32) -> i2
      %21 = comb.mux %19, %20, %c-1_i2 : i2
      %22 = hw.array_get %arg1[%21] : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %payload = hw.struct_extract %22["payload"] : !hw.struct<header: i8, payload: i32>
      %header = hw.struct_extract %22["header"] : !hw.struct<header: i8, payload: i32>
      %23 = hw.struct_create (%header, %payload) : !hw.struct<header: i8, payload: i32>
      %24 = hw.array_inject %9[%15], %23 : !hw.array<4xstruct<header: i8, payload: i32>>, i2
      %25 = comb.add %8, %c1_i32 : i32
      cf.br ^bb1(%25, %24 : i32, !hw.array<4xstruct<header: i8, payload: i32>>)
    ^bb3(%26: i32, %27: i1, %28: !hw.array<4xstruct<header: i8, payload: i32>>, %29: i1):  // pred: ^bb1
      arc.output %26, %27, %28, %29 : i32, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i1
    }
    %1 = arc.state @data_processor_arc(%0#1, %in_data, %1) clock %3 latency 1 : (i1, i32, i32) -> i32
    %2 = arc.state @data_processor_arc_0(%0#3, %0#2, %2) clock %3 latency 1 : (i1, !hw.array<4xstruct<header: i8, payload: i32>>, !hw.array<4xstruct<header: i8, payload: i32>>) -> !hw.array<4xstruct<header: i8, payload: i32>>
    %3 = arc.call @data_processor_arc_1(%clk) : (i1) -> !seq.clock
    %4 = arc.call @data_processor_arc_2(%2) : (!hw.array<4xstruct<header: i8, payload: i32>>) -> i4
    hw.output %4 : i4
  }
}


<stdin>:46:10: error: 'arc.state' op operand type mismatch: operand #2
    %3 = comb.mux bin %0#3, %0#2, %packet_array : !hw.array<4xstruct<header: i8, payload: i32>>
         ^
<stdin>:46:10: note: see current operation: %6 = "arc.state"(%7, %0#3, %4, %0#2, %5) <{arc = @data_processor_arc_0, latency = 1 : i32, operandSegmentSizes = array<i32: 1, 1, 0, 3, 0>}> : (!seq.clock, i1, i1, !hw.array<4xstruct<header: i8, payload: i32>>, i820558712) -> !hw.array<4xstruct<header: i8, payload: i32>>
<stdin>:46:10: note: expected type: '!hw.array<4xstruct<header: i8, payload: i32>>'
<stdin>:46:10: note:   actual type: 'i820558712'
