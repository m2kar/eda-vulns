[
  {
    "issue_number": 1522,
    "title": "Experimentation with FSM dialect during Calyx lowering",
    "body": "In https://github.com/llvm/circt/pull/1506#pullrequestreview-720563236 I mentioned that it might be useful to use the proposed FSM dialect during Calyx's CompileControl pass. That pass is generating an FSM with Comb logic right now, but my hypothesis is targetting the FSM dialect would provide a more straightforward way to capture the notion of an FSM. Steve was mentioning it would be good for us to do some homework on the FSM proposal and bring our use-cases, so I'll experiment with this a bit.\r\n\r\nCC @cgyurgyik ",
    "labels": [
      "Tracking Issue",
      "Calyx",
      "FSM"
    ],
    "createdAt": "2021-08-04T22:00:23Z"
  },
  {
    "issue_number": 1545,
    "title": "[PrettifyVerilog] Transform (some) array_create/get pairs into cases",
    "body": "As [discussed in the design meeting](https://docs.google.com/document/d/1fOSRdyZR2w75D87yU2Ma9h2-_lEPL4NxvhJGJd-s5pk/edit#heading=h.ygmlwiic5e1y) it would make sense to lower certain array_create/get pairs into case statements (potentially in an always_comb block):\r\n\r\n1) When the expression feeding the elements is large, complicated, and single use it would make sense to generate case statements.\r\n2) When multiple array_get's exists that use the same index condition it makes sense to fold them together into a single larger case.  It is possible that this is just a \"case folding\" peephole that triggers after the first one.\r\n\r\nWe need to be careful not to go overboard here though, because the array_create syntax is nice for simple inline expressions.  The example in the [rationale docs](https://github.com/llvm/circt/blob/main/docs/RationaleHW-SV.md#operations) should stay inline for example.\r\n\r\n",
    "labels": [
      "ExportVerilog"
    ],
    "createdAt": "2021-08-11T20:23:23Z"
  },
  {
    "issue_number": 2006,
    "title": "Adopt \"pretty accessors\" in MLIR",
    "body": "MLIR mainline added the ability to synthesize get/setters with a properly camel cased and get/set-prefixed name, see [this patch](https://reviews.llvm.org/D111033) and [this announcement](https://llvm.discourse.group/t/psa-ods-generated-accessors-will-change-to-have-a-get-prefix-update-you-apis/4476/2).\r\n\r\nWe should do a merge from MLIR mainline to get this, and then adopt it in the CIRCT dialects.  I don't think we need to do the multistage adoption thing, we can just jump directly to `_Prefixed`\r\n",
    "labels": [
      "good first issue"
    ],
    "createdAt": "2021-10-16T20:06:14Z"
  },
  {
    "issue_number": 2565,
    "title": "[FIRRTL] Simplify PrefixModules pass",
    "body": "`PrefixModules` is a global pass that renames the modules based on certain annotation.\r\n It seems to be a relatively expensive pass for just renaming the modules.\r\nCan we simplify the pass for certain cases, like avoiding cloning modules, when each module is instantiated only once. \r\nOr, perform it using `verilogName` attribute during `LowerToHW` ?\r\nSome interesting discussion in the original PR: https://github.com/llvm/circt/pull/1183\r\nThis is a snapshot of runtime for an internal test case (`p550`) for the FIRRTL pipeline.\r\n\r\n```\r\n===-------------------------------------------------------------------------===\r\n                         ... Execution time report ...\r\n===-------------------------------------------------------------------------===\r\n  Total Execution Time: 264.1102 seconds\r\n\r\n  ----User Time----  ----Wall Time----  ----Name----\r\n   32.3520 (  5.9%)   32.3520 ( 12.2%)  FIR Parser\r\n  476.1045 ( 86.8%)  191.6725 ( 72.6%)  'firrtl.circuit' Pipeline\r\n   62.5173 ( 11.4%)    3.7192 (  1.4%)    'firrtl.module' Pipeline\r\n   57.9840 ( 10.6%)    3.5445 (  1.3%)      CSE\r\n    0.1501 (  0.0%)    0.0231 (  0.0%)        (A) DominanceInfo\r\n    4.2898 (  0.8%)    0.3141 (  0.1%)      LowerCHIRRTLPass\r\n   11.0799 (  2.0%)   11.0799 (  4.2%)    InferWidths\r\n   12.4964 (  2.3%)   12.4964 (  4.7%)    InferResets\r\n    0.6812 (  0.1%)    0.6812 (  0.3%)      (A) circt::firrtl::InstanceGraph\r\n    5.1985 (  0.9%)    5.1985 (  2.0%)    WireDFT\r\n   11.0132 (  2.0%)   11.0132 (  4.2%)    PrefixModules\r\n   28.7032 (  5.2%)   28.7032 ( 10.9%)    LowerFIRRTLTypes\r\n  179.6644 ( 32.8%)   13.8885 (  5.3%)    'firrtl.module' Pipeline\r\n   32.1330 (  5.9%)    4.2363 (  1.6%)      ExpandWhens\r\n    0.3756 (  0.1%)    0.1330 (  0.1%)      RemoveResets\r\n  135.7015 ( 24.7%)   11.2296 (  4.3%)      Canonicalizer\r\n   11.3954 (  2.1%)    0.8129 (  0.3%)      InferReadWrite\r\n    9.1897 (  1.7%)    9.1897 (  3.5%)    Inliner\r\n   15.1846 (  2.8%)   15.1846 (  5.7%)    IMConstProp\r\n    0.4841 (  0.1%)    0.4841 (  0.2%)      (A) circt::firrtl::InstanceGraph\r\n    3.3466 (  0.6%)    3.3466 (  1.3%)    BlackBoxReader\r\n   48.4989 (  8.8%)   48.4989 ( 18.4%)    GrandCentral\r\n    0.4658 (  0.1%)    0.4658 (  0.2%)      (A) circt::firrtl::InstanceGraph\r\n    6.8357 (  1.2%)    6.8357 (  2.6%)    GrandCentralTaps\r\n    0.5108 (  0.1%)    0.5108 (  0.2%)      (A) circt::firrtl::InstanceGraph\r\n   47.6537 (  8.7%)    7.5269 (  2.8%)    'firrtl.module' Pipeline\r\n    0.2128 (  0.0%)    0.0234 (  0.0%)      GrandCentralSignalMappings\r\n   47.2536 (  8.6%)    7.5137 (  2.8%)      Canonicalizer\r\n    5.5339 (  1.0%)    5.5339 (  2.1%)    RemoveUnusedPorts\r\n    0.4769 (  0.1%)    0.4769 (  0.2%)      (A) circt::firrtl::InstanceGraph\r\n    3.3695 (  0.6%)    3.3695 (  1.3%)    CreateSiFiveMetadata\r\n    0.4371 (  0.1%)    0.4371 (  0.2%)      (A) circt::firrtl::InstanceGraph\r\n    6.0398 (  1.1%)    6.0398 (  2.3%)    EmitOMIR\r\n   39.6520 (  7.2%)   39.6520 ( 15.0%)  Print .mlir output\r\n    0.4314 (  0.1%)    0.4314 (  0.2%)  Rest\r\n  548.5422 (100.0%)  264.1102 (100.0%)  Total\r\n```",
    "labels": [
      "FIRRTL"
    ],
    "createdAt": "2022-02-02T15:01:42Z"
  },
  {
    "issue_number": 4532,
    "title": "[ExportVerilog] always_comb ordering issue",
    "body": "The following MLIR (bear with me there's potentially a lot of un-important parts of this IR):\r\n\r\n```mlir\r\nmodule attributes {circt.loweringOptions = \"locationInfoStyle=none\"} {\r\n    hw.module @Main(%IA: i2, %IB: i2, %IS: i1) -> (O: i2) {\r\n        %0 = hw.constant 0 : i2\r\n        %1 = hw.constant 1 : i2\r\n        %2 = hw.constant 0 : i1\r\n        %3 = comb.extract %IA from 0 : (i2) -> i1\r\n        %4 = comb.extract %IA from 1 : (i2) -> i1\r\n        %5 = comb.extract %IB from 0 : (i2) -> i1\r\n        %6 = hw.constant 1 : i1\r\n        %7 = comb.extract %IB from 1 : (i2) -> i1\r\n        %14 = sv.reg : !hw.inout<i2>\r\n        %8 = sv.read_inout %14 : !hw.inout<i2>\r\n        %15 = sv.reg : !hw.inout<i2>\r\n        %9 = sv.read_inout %15 : !hw.inout<i2>\r\n        %16 = sv.reg : !hw.inout<i1>\r\n        %10 = sv.read_inout %16 : !hw.inout<i1>\r\n        %17 = sv.reg : !hw.inout<i1>\r\n        %11 = sv.read_inout %17 : !hw.inout<i1>\r\n        %18 = sv.reg : !hw.inout<i1>\r\n        %12 = sv.read_inout %18 : !hw.inout<i1>\r\n        %19 = sv.reg : !hw.inout<i1>\r\n        %13 = sv.read_inout %19 : !hw.inout<i1>\r\n        sv.alwayscomb {\r\n            sv.if %IS {\r\n                sv.bpassign %16, %2 : i1\r\n                sv.bpassign %17, %2 : i1\r\n                sv.bpassign %18, %5 : i1\r\n                sv.bpassign %19, %7 : i1\r\n            } else {\r\n                sv.bpassign %16, %3 : i1\r\n                sv.bpassign %17, %4 : i1\r\n                sv.bpassign %18, %6 : i1\r\n                sv.bpassign %19, %2 : i1\r\n            }\r\n        }\r\n        %20 = comb.concat %11, %11, %10 : i1, i1, i1\r\n        %21 = comb.concat %13, %13, %12 : i1, i1, i1\r\n        %22 = comb.add %20, %21 : i3\r\n        %23 = comb.extract %22 from 1 : (i3) -> i1\r\n        %24 = comb.extract %22 from 2 : (i3) -> i1\r\n        %25 = comb.concat %24, %23 : i1, i1\r\n        %26 = hw.constant 1 : i2\r\n        %27 = comb.icmp eq %25, %26 : i2\r\n        %28 = hw.constant 1 : i2\r\n        %29 = comb.concat %24, %23 : i1, i1\r\n        %30 = hw.constant -2 : i2\r\n        %31 = comb.icmp eq %29, %30 : i2\r\n        %32 = hw.constant 2 : i2\r\n        %33 = hw.constant 1 : i1\r\n        %34 = hw.constant 0 : i1\r\n        %35 = comb.extract %22 from 0 : (i3) -> i1\r\n        %39 = sv.reg : !hw.inout<i2>\r\n        %36 = sv.read_inout %39 : !hw.inout<i2>\r\n        %40 = sv.reg : !hw.inout<i1>\r\n        %37 = sv.read_inout %40 : !hw.inout<i1>\r\n        %41 = sv.reg : !hw.inout<i1>\r\n        %38 = sv.read_inout %41 : !hw.inout<i1>\r\n        sv.alwayscomb {\r\n            sv.if %27 {\r\n                sv.bpassign %40, %33 : i1\r\n                sv.bpassign %41, %34 : i1\r\n            } else {\r\n                sv.if %31 {\r\n                    sv.bpassign %40, %34 : i1\r\n                    sv.bpassign %41, %33 : i1\r\n                } else {\r\n                    sv.bpassign %40, %35 : i1\r\n                    sv.bpassign %41, %23 : i1\r\n                }\r\n            }\r\n        }\r\n        %42 = comb.concat %38, %37 : i1, i1\r\n        hw.output %42 : i2\r\n    }\r\n}\r\n```\r\n\r\nproduces the following Verilog:\r\n\r\n```verilog\r\n// Generated by CIRCT circtorg-0.0.0-1018-g3a39b339f\r\nmodule Main(\r\n  input  [1:0] IA,\r\n               IB,\r\n  input        IS,\r\n  output [1:0] O);\r\n\r\n  reg _GEN;\r\n  reg _GEN_0;\r\n  reg _GEN_1;\r\n  reg _GEN_2;\r\n  reg _GEN_3;\r\n  reg _GEN_4;\r\n  always_comb begin\r\n    automatic logic [2:0] _GEN_5;\r\n    _GEN_5 = {{2{_GEN_0}}, _GEN} + {{2{_GEN_2}}, _GEN_1};\r\n    if (IS) begin\r\n      _GEN = 1'h0;\r\n      _GEN_0 = 1'h0;\r\n      _GEN_1 = IB[0];\r\n      _GEN_2 = IB[1];\r\n    end\r\n    else begin\r\n      _GEN = IA[0];\r\n      _GEN_0 = IA[1];\r\n      _GEN_1 = 1'h1;\r\n      _GEN_2 = 1'h0;\r\n    end\r\n    if (_GEN_5[2:1] == 2'h1) begin\r\n      _GEN_3 = 1'h1;\r\n      _GEN_4 = 1'h0;\r\n    end\r\n    else if (_GEN_5[2:1] == 2'h2) begin\r\n      _GEN_3 = 1'h0;\r\n      _GEN_4 = 1'h1;\r\n    end\r\n    else begin\r\n      _GEN_3 = _GEN_5[0];\r\n      _GEN_4 = _GEN_5[1];\r\n    end\r\n  end // always_comb\r\n  assign O = {_GEN_4, _GEN_3};\r\nendmodule\r\n```\r\n\r\nThe issue here is that the add (`%22 = comb.add %20, %21 : i3`) which is outside of the first `always_comb` gets pushed into the *beginning* of the `always_comb` (`_GEN_5 = ... + ...`) in the Verilog, although it depends on register assignments later in that same `always_comb`. This results in a simulation where the add uses old values of the relevant registers.\r\n\r\nI believe that potentially using non-block assignments, *or* moving the add outside of the `always_comb` would fix this issue.",
    "labels": [],
    "createdAt": "2023-01-11T18:58:12Z"
  },
  {
    "issue_number": 6810,
    "title": "[Arc] Add basic assertion support",
    "body": "Add support for `verif.assert` and `sv.assert.concurrent` operations to the Arc dialect and passes. When lowering towards LLVM, the asserts should lower to an `scf.if` operation that checks whether their condition holds, and if it does not, calls a callback function (or aborts with a message for starters).\r\n\r\nThis is likely to uncover a lot of details about how clocked and unclocked asserts need to be handled, and where they have to be scheduled and checked in the simulation model.",
    "labels": [
      "good first issue",
      "Arc"
    ],
    "createdAt": "2024-03-11T16:54:47Z"
  },
  {
    "issue_number": 7535,
    "title": "[MooreToCore] VariableOp lowered failed",
    "body": "Dear @maerhart @fabianschuiki ,\r\n When lowering `SV` to `Hw` Dialect, there is a stack dump. \r\nDriver: circt-verilog %s\r\n```\r\nmodule top();\r\n  typedef struct {\r\n    int a;\r\n    int b;\r\n  } ms_t;\r\n\r\n  ms_t ms;\r\n\r\n  initial begin\r\n    ms = '{ 0, 1};\r\n\r\n    ms = '{ default:1, int:1};\r\n\r\n    ms = '{ int:0, int:1};\r\n  end\r\n\r\nendmodule\r\n```\r\nIt can be converted to `moore` Dialect like this\r\nDriver:  circt-verilog --ir-moore %s\r\n```\r\nmodule {\r\n  moore.module @top() {\r\n    %0 = moore.constant 1 : i32\r\n    %1 = moore.constant 0 : i32\r\n    %ms = moore.variable : <ustruct<{a: i32, b: i32}>>\r\n    moore.procedure initial {\r\n      %2 = moore.struct_create %1, %0 : !moore.i32, !moore.i32 -> ustruct<{a: i32, b: i32}>\r\n      moore.blocking_assign %ms, %2 : ustruct<{a: i32, b: i32}>\r\n      %3 = moore.struct_create %0, %0 : !moore.i32, !moore.i32 -> ustruct<{a: i32, b: i32}>\r\n      moore.blocking_assign %ms, %3 : ustruct<{a: i32, b: i32}>\r\n      moore.blocking_assign %ms, %3 : ustruct<{a: i32, b: i32}>\r\n      moore.return\r\n    }\r\n    moore.output\r\n  }\r\n}\r\n```\r\nBut it got stack dump when casting `hw::InOutType`. Maybe `structType` should be converted somehow.\r\nThis is part of error codes.\r\n```\r\n#19 0x00005f9660f42af4 (anonymous namespace)::OperationLegalizer::legalizeWithPattern(mlir::Operation*, mlir::ConversionPatternRewriter&) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:1958:21\r\n#20 0x00005f9660f3b100 (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:1850:17\r\n#21 0x00005f9660f3aa73 mlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:2384:26\r\n#22 0x00005f9660f3b41f mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:2436:16\r\n#23 0x00005f9660f3fdfc mlir::applyFullConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:3447:22\r\n#24 0x00005f9660f3fe9d mlir::applyFullConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) /home/pluto/Documents/circt/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:3453:10\r\n#25 0x00005f965faed60d (anonymous namespace)::MooreToCorePass::runOnOperation() /home/pluto/Documents/circt/circt/lib/Conversion/MooreToCore/MooreToCore.cpp:1398:14\r\n```",
    "labels": [],
    "createdAt": "2024-08-20T01:51:29Z"
  },
  {
    "issue_number": 7665,
    "title": "[LLHD][ProcessLowering] Incorrectly inlines aliasing drives",
    "body": "The ProcessLowering pass checks whether an `llhd.process` operation is a combinational process and inlines it into the parent module if that's the case.\r\n\r\nHowever, it doesn't check for aliasing drives. There can be a series of blocking drives where the first one does a general default assignment to the entire signal, and subsequent conditional drives, aliasing part of the signal, override parts. Since there is no fixed execution order inside modules, these must be combined before inlining. ProcessLowering should check for that and not perform the inlining in such cases.\r\n\r\nThe TemporalCodeMotion pass combines drives to the same signal to some degree but doesn't consider subelement aliasing. One option to support this is to perform SROA before TemporalCodeMotion.",
    "labels": [
      "bug",
      "LLHD"
    ],
    "createdAt": "2024-10-04T10:44:00Z"
  },
  {
    "issue_number": 7692,
    "title": "[Sim] Combine integer formatting ops into one op",
    "body": "@fzi-hielscher I was wondering what your thoughts are on maybe combining the integer formatting operations `sim.fmt.hex`, `sim.fmt.bin`, and `sim.fmt.dec` into a single `sim.fmt.int` operation. The Moore dialect wants to lower to these ops, and there are additional formatting options (width, alignment, zero/space padding) that apply to each of these ops. If we made the integer radix a parameter on the op, we might only have to add these formatting options to a single op. WDYT?",
    "labels": [
      "Simulator"
    ],
    "createdAt": "2024-10-10T20:39:13Z"
  },
  {
    "issue_number": 7801,
    "title": "[ImportVerilog] How to implement SVA in Moore?",
    "body": "Hello fabian and hailong:\r\n@fabianschuiki @hailongSun2000 \r\nI'm trying to implement SVA for moore, and the main problem is how to implement property and sequence for moore, I find that   dialect LTL is a good choice to model SVA.\r\n\r\n>The main goal of the ltl dialect is to capture the core formalism underpinning SystemVerilog Assertions (SVAs), the de facto standard for describing temporal logic sequences and properties in hardware verification. (See IEEE 1800-2017 section 16 \u201cAssertions\u201d.) We expressly try not to model this dialect like an AST for SVAs, but instead try to strip away all the syntactic sugar and Verilog quirks, and distill out the core foundation as an IR. Within the CIRCT project, this dialect intends to enable emission of rich temporal assertions as part of the Verilog output, but also provide a foundation for formal tools built ontop of CIRCT.\r\n\r\nI think it's a good choice to directly convert SVA to LTL and bypass Moore, we can saving out time and avoid to model sva property again.",
    "labels": [
      "ImportVerilog"
    ],
    "createdAt": "2024-11-12T17:40:46Z"
  },
  {
    "issue_number": 8012,
    "title": "[Moore][Arc][LLHD] Moore to LLVM lowering issues",
    "body": "Hi all!\n\nI am trying to simulate a SystemVerilog code (listed below) using `arcilator`:\n\n```verilog\nmodule dff(D, clk, Q);\n    input D; // Data input \n    input clk; // clock input \n    output reg Q; // output Q\n\n    // Simple DFF\n    always @(negedge clk) \n    begin\n        Q <= D; \n    end \nendmodule\n```\n\n with such pipeline:\n\n```bash\ncirct-verilog dff.sv | arcilator\n```\n\n`arcilator` fails with  **error: 'llhd.process' op has regions; not supported by ConvertToArcs**\n\nThen I try to use a different pipeline with `circt-opt` :\n\n```bash\ncirct-verilog dff.sv | circt-opt --llhd-early-code-motion --llhd-temporal-code-motion --llhd-desequentialize --llhd-sig2reg -canonicalize | arcilator\n```\n\n`acilator` fails with another **error: failed to legalize operation 'seq.clock_inv'**\n\nWhat is necessary to be able to run `arcilator` on such simple `DFF` example? \n",
    "labels": [],
    "createdAt": "2024-12-20T16:49:46Z"
  },
  {
    "issue_number": 8176,
    "title": "[MooreToCore] Crash when getting values to observe",
    "body": "The following crashes due to an unattached region when calling `getValuesToObserve`.\n\n```mlir\nmoore.module @crash(in %in0: !moore.i32, in %in1: !moore.i32) {\n  %var = moore.variable : <!moore.i32>\n  moore.procedure always_comb {\n    %0 = moore.pows %in0, %in1 : !moore.i32\n    moore.blocking_assign %var, %0 : !moore.i32\n    moore.return\n  }\n}\n```",
    "labels": [
      "Moore"
    ],
    "createdAt": "2025-02-03T10:27:41Z"
  },
  {
    "issue_number": 8211,
    "title": "[MooreToCore]Unexpected observed values in llhd.wait.",
    "body": "Please check this PR(https://github.com/llvm/circt/pull/8210/files) to view the details.\n\nOr for example:\n```\nmoore.module @crash(in %in0: !moore.i32, in %in1: !moore.i32) {\n  %var = moore.variable : <!moore.i32>\n  moore.procedure always_comb {\n    %0 = moore.pows %in0, %in1 : !moore.i32\n    moore.blocking_assign %var, %0 : !moore.i32\n    moore.return\n  }\n}\n```\n\n`%var` will be regarded as one member of the implicit sensitivity list. But this act is illegal\u274c.",
    "labels": [
      "Moore"
    ],
    "createdAt": "2025-02-08T13:58:49Z"
  },
  {
    "issue_number": 8269,
    "title": "[MooreToCore] Support `real` constants",
    "body": "I'm looking into the failing testcase for `real` constants [on sv-tests-results](https://chipsalliance.github.io/sv-tests-results/?v=circt_verilog+5.7.2+real-constants). Just want to put it up here to make sure no one else has already started working on it.",
    "labels": [
      "Moore"
    ],
    "createdAt": "2025-02-23T19:01:31Z"
  },
  {
    "issue_number": 8283,
    "title": "[ImportVerilog] Cannot compile forward decleared string type",
    "body": "I want to support this [sv-tests-results/string_concat_op](https://chipsalliance.github.io/sv-tests-results/?v=circt_verilog+11.4.12.2+string_concat_op) feature, but not sure how to fix it properly.\n\n``` sv\nmodule top();\n\nstring str;\n\ninitial begin\n    str = \"Hello\";\nend\n\nendmodule\n```\n\n`circt-verilog`  has the following complaints when compiling the string.sv file:\n```s.sv:3:8: error: failed to legalize operation 'moore.variable'\nstring str;\n       ^\ns.sv:3:8: note: see current operation: %0 = \"moore.variable\"() <{name = \"str\"}> : () -> !moore.ref<string>\n```\n\nThis error is due to MooreToCore's lack of string-type conversion. It only has `StringConstantOpConv` and `Format*OpConversion`; none of these conversions can handle the `string` type.\n",
    "labels": [],
    "createdAt": "2025-02-28T08:51:12Z"
  },
  {
    "issue_number": 8286,
    "title": "[circt-verilog][llhd][arcilator] Verilog-to-LLVM lowering issues",
    "body": "Hi all!\n\nThere are a few issues related to moore to llvm lowering pipeline.\n\nCurrently there is no possibility to lower combination logic with control flow operators into LLVM. For example:\n\n```verilog\nmodule  top  (\n    input           clk ,\n    input           rstn ,\n    input      in\n    output     out\n    );\n\n    parameter            P1   = 3'd0 ;\n    parameter            P2  = 3'd3 ;\n\n    reg [2:0]            r1 = 3'd1;\n\n    always_comb begin\n        if (in)\n            r1 = P1;\n        else\n            r1 = P2;\n    end\nendmodule\n```\n\nbecause it fails with this : `error: failed to legalize operation 'llhd.constant_time'`\n\nAnd also `arcilator` fails to lower sequential logic which contains both blocking and nonblocking assignments like this example:\n\n```verilog\nmodule  top  (\n    input           clk ,\n    input           rstn ,\n    input      in\n    output     out\n    );\n\n    parameter            P1   = 3'd0 ;\n    parameter            P2  = 3'd3 ;\n\n    reg [2:0]            r1 = 3'd1;\n\n    always @(posedge clk or negedge rstn) begin\n        r1 = P1;\n        r1 <= P2 + r1;\n    end\n\nendmodule\n```\n\nbecause it fails with that:\n\n```\n error: body contains non-pure operation\n    %2 = comb.add %1, %c3_i3 : i3\n```\n\nI'm using to lower a such cmd:\n\n```\ncirct-verilog sample.sv | arcilator \n```\n\nAlso I tried to add into \"populate LLHD\" pipeline a newly added passes  -- \"llhd-hoist-signals\" and \"llhd-mem2reg\". It didn't help.\n\nMaybe I'm doing something wrong or what could be the issue?\n\n1) What are the plans for improving verilog-to-llvm lowering  and do they exist at all?\n2) Will the \"llhd-hoist-signals\" and \"llhd-mem2reg\" passes be added to the `circt-verilog` tool or will they stay standalone?\n\n@fabianschuiki @maerhart ",
    "labels": [],
    "createdAt": "2025-03-03T10:23:03Z"
  },
  {
    "issue_number": 8332,
    "title": "[MooreToCore] Support for StringType from moore to llvm dialect",
    "body": "Hi! Now I try to add types and operators in sim to get the lowered operators in moore, and then lower them to llvm dialect, so that the corresponding dynamic size container can be implemented in arcilator.\n\nFirst, add IntType and RefType in sim, as well as VariableOp, BlockAssignOp, Print, ReadOp, and ConcatOp operators.\nTaking Variable as an example, creating a stringtype VariableOp in Moore will create an int type through string_constant, and then perform conversionOp to convert the int type to Stringtype, and finally create VariableOp. In sim, if VariableOp can directly accept int type, the conversion time can be saved. Therefore, I think it is not necessary to add StringType separately, and only use Int Type and RefType to represent it.\n\nIn sim to llvm dialect, VariableOp will be converted into a series of Ops. First, llvm.alloca will be used to create an i128 memory, which will be divided into i32 size to record the string length, and i96 data to record the string content. Then, llvm.getelementptrOp and llvm.storeOp are used to store the contents in the corresponding locations. This memory will be dynamically doubled according to the length of the string.\n\nCan you give me some advise?",
    "labels": [],
    "createdAt": "2025-03-20T02:36:53Z"
  },
  {
    "issue_number": 8334,
    "title": "[ImportVerilog] Support Delay control",
    "body": "The [chipsalliance tests for delay control](https://chipsalliance.github.io/sv-tests-results/?v=circt_verilog+9.4.1+always) currently fail. For instance:\n```systemverilog\nmodule always_tb ();\n\tlogic a = 0;\n\talways #5 a = ~a;\nendmodule\n```\n\nIt should be possible to support SystemVerilog delay controls by lowering `slang::ast::DelayControl` to `llhd::WaitOp` right?\n\nEdit: Realised that it would have to go through Moore dialect first. Not sure what to use there; is it currently doable in Moore?",
    "labels": [],
    "createdAt": "2025-03-20T16:48:20Z"
  },
  {
    "issue_number": 8406,
    "title": "[hlstool] `noAlwaysComb` lowering option does not seem to work with `hlstool`",
    "body": "While exploring the toolset and fiddling around with Calyx/CF code, I found this:\n\n```test02.mlir\nfunc.func @main(%arg0 : i32, %arg1 : i32) -> i32 {\n  %0 = arith.cmpi slt, %arg0, %arg1 : i32\n  cf.cond_br %0, ^bb1, ^bb2\n^bb1:\n  cf.br ^bb3(%arg0 : i32)\n^bb2:\n  cf.br ^bb3(%arg1 : i32)\n^bb3(%1 : i32):\n  return %1 : i32\n}\n```\n\n```\n$ ./bin/hlstool --calyx-hw --verilog test02.mlir --lowering-options=noAlwaysComb | grep always_comb\n  always_comb begin     // test02.mlir:1:1\n  end // always_comb\n```\n\nThe above was done with a download of `firtool-1.112.0` from the releases page.\n\nThis is problematic because unfortunately [yosys is very anal about this issue](https://github.com/YosysHQ/yosys/blob/33c57937cd6417dd91d34d67d6158ff550544834/passes/proc/proc_dlatch.cc#L436-L441) and absolutely refuses to synthesize if this is the case:\n\n```\n3.4.8. Executing PROC_DLATCH pass (convert process syncs to latches).\nERROR: Latch inferred for signal `\\control_main.\\state_next' from always_comb process `\\control_main.$proc$control_main.sv:0$2'.\n```\n\nThough it's unclear to me if it's actually a yosys bug (other synthesis tools apparently accept it?) I also might be holding `hlstool` wrong too.",
    "labels": [],
    "createdAt": "2025-04-10T00:37:09Z"
  },
  {
    "issue_number": 8476,
    "title": "[MooreToCore] Lower exponentiation to `math.ipowi`",
    "body": "@jiahanxie353 has added the Math dialect to circt-opt in #8475. This is a great precedent to start using that dialect in the MooreToCore conversion. For example, the `moore.pow` operation could be lowered to `math.ipowi` and `math.powf` depending on its type.",
    "labels": [
      "good first issue",
      "Moore"
    ],
    "createdAt": "2025-05-12T16:08:01Z"
  },
  {
    "issue_number": 8844,
    "title": "[circt-verilog]  'moore.case_eq' operand must be simple bit vector type, but got array",
    "body": "I ran `circt-verilog` on this file from OpenTitan:\nhttps://github.com/lowRISC/opentitan/blob/d8b5efd1427152b8387d6e03d9db413167e58475/hw/ip/lc_ctrl/rtl/lc_ctrl_fsm.sv\n\nI got this error:\n\n```bash\nak2518@autobot:/local/scratch/ak2518/opentitan$ /local/scratch/ak2518/circt/build/bin/circt-verilog --debug --parse-only /local/scratch/ak2518/opentitan/hw/ip/lc_ctrl/rtl/lc_ctrl_fsm.sv -yhw/ip/prim_generic/rtl -yhw/ip/prim/rtl -yhw/ip/lc_ctrl/rtl -yhw/ip/rom_ctrl/rtl -Ihw/ip/prim/rtl -yhw/ip/prim_generic/rtl -DYOSYS -DSYNTHESIS  --mlir-print-ir-after-failure --verbose-pass-executions --mlir-pass-statistics\nArgs: /local/scratch/ak2518/circt/build/bin/circt-verilog --debug --parse-only /local/scratch/ak2518/opentitan/hw/ip/lc_ctrl/rtl/lc_ctrl_fsm.sv -yhw/ip/prim_generic/rtl -yhw/ip/prim/rtl -yhw/ip/lc_ctrl/rtl -yhw/ip/rom_ctrl/rtl -Ihw/ip/prim/rtl -yhw/ip/prim_generic/rtl -DYOSYS -DSYNTHESIS --mlir-print-ir-after-failure --verbose-pass-executions --mlir-pass-statistics\nLoad new dialect in Context builtin\nLoad new dialect in Context moore\nLoad new dialect in Context hw\nLoad new dialect in Context cf\nLoad new dialect in Context arith\nLoad new dialect in Context func\nLoad new dialect in Context verif\nLoad new dialect in Context seq\nLoad new dialect in Context ltl\nLoad new dialect in Context comb\nLoad new dialect in Context dbg\n-:148:13: error: 'moore.case_eq' op operand #0 must be simple bit vector type, but got '!moore.array<6 x l5>'\n-:148:13: note: see current operation: %243 = \"moore.case_eq\"(%239, %242) : (!moore.array<6 x l5>, !moore.l30) -> !moore.i1\nak2518@autobot:/local/scratch/ak2518/opentitan$\n```\n\n\nI'm not sure what this error means. I don't know how to debug/inspect the intermediate representation before the error happens. It would be useful if I could see what construct in the original SystemVerilog caused this line in the MLIR.\n\n\nversion:\n\n```bash\nak2518@autobot:/local/scratch/ak2518/opentitan$  /local/scratch/ak2518/circt/build/bin/circt-verilog --version\nLLVM (http://llvm.org/):\n  LLVM version 22.0.0git\n  DEBUG build with assertions.\nCIRCT 55f12edd1\nslang version 9.0.0+54385bb\n```\n\nThrough trial-and-error, I've realised that this is caused by lines 148-203 in `lc_ctrl_state_transition.sv`\nhttps://github.com/lowRISC/opentitan/blob/d8b5efd1427152b8387d6e03d9db413167e58475/hw/ip/lc_ctrl/rtl/lc_ctrl_state_transition.sv#L148-L203",
    "labels": [
      "ImportVerilog"
    ],
    "createdAt": "2025-08-12T11:51:40Z"
  },
  {
    "issue_number": 8863,
    "title": "[Comb] Concat/extract canonicalizer crashes on loop",
    "body": "Consider the following input:\n```mlir\nhw.module @Foo(in %a : i1, in %b : i1, out z : i4) {\n  %0 = comb.extract %1 from 2 : (i4) -> i2\n  %1 = comb.concat %0, %b, %a : i2, i1, i1\n  hw.output %1 : i4\n}\n```\nRunning this through `circt-opt --canonicalize` crashes:\n```\nAssertion `op->use_empty() && \"expected 'op' to have no uses\"' failed.\n[...]\n #8 mlir::RewriterBase::eraseOp(mlir::Operation*)\n #9 mlir::RewriterBase::replaceOp(mlir::Operation*, mlir::ValueRange)\n#10 circt::replaceOpAndCopyNamehint(mlir::PatternRewriter&, mlir::Operation*, mlir::Value) \n#11 extractConcatToConcatExtract(circt::comb::ExtractOp, circt::comb::ConcatOp, mlir::PatternRewriter&)\n    /home/fabian/code/circt/lib/Dialect/Comb/CombFolds.cpp:513:3\n#12 circt::comb::ExtractOp::canonicalize(circt::comb::ExtractOp, mlir::PatternRewriter&)\n    /home/fabian/code/circt/lib/Dialect/Comb/CombFolds.cpp:578:12\n```\nThe input was generate from (loop is useless in practice but intentional):\n```systemverilog\nmodule Foo(input logic a, logic b, output logic [3:0] z);\n  logic [3:0] x;\n  always_comb begin\n    x[0] = a;\n    x[1] = b;\n  end\n  assign z = x;\nendmodule\n```",
    "labels": [
      "Comb"
    ],
    "createdAt": "2025-08-16T20:38:33Z"
  },
  {
    "issue_number": 9013,
    "title": "[circt-opt] Segmentation fault during XOR op building",
    "body": "Hi, all! Let's consider a such `Verilog` example:\n\n```verilog\nmodule top (input clk, input rstn);\n    reg r1;\n    always @(posedge clk or negedge rstn) begin\n        r1 = 0;\n    end\nendmodule\n```\n\nDuring `llhd-desequentialize` pass `circt-opt` tool segfaults using this pipeline:\n\n```\ncirct-verilog test.sv | circt-opt --llhd-desequentialize\n```\n\nWith such stacktrace:\n\n```\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: ./circt-opt --llhd-desequentialize\n #0 0x00005f1950d1c582 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (./circt-opt+0x19b1582)\n #1 0x00005f1950d19312 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #2 0x000073e5fec42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #3 0x00005f19517f1f60 circt::hw::isHWIntegerType(mlir::Type) (./circt-opt+0x2486f60)\n #4 0x00005f1950f4aa48 circt::comb::__mlir_ods_local_type_constraint_Comb1(mlir::Operation*, mlir::Type, llvm::StringRef, unsigned int) CombOps.cpp:0:0\n #5 0x00005f1950f861df circt::comb::XorOp::verifyInvariantsImpl() (./circt-opt+0x1c1b1df)\n #6 0x00005f1950fd06f8 mlir::Op<circt::comb::XorOp, mlir::OpTrait::ZeroRegions, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::hw::TypeVariant<mlir::IntegerType, circt::hw::IntType>>::Impl, mlir::OpTrait::ZeroSuccessors, mlir::OpTrait::VariadicOperands, mlir::OpTrait::OpInvariants, mlir::BytecodeOpInterface::Trait, mlir::OpTrait::IsCommutative, mlir::OpTrait::SameTypeOperands, mlir::OpTrait::SameOperandsAndResultType, mlir::InferIntRangeInterface::Trait, mlir::ConditionallySpeculatable::Trait, mlir::OpTrait::AlwaysSpeculatableImplTrait, mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::Operation*) CombDialect.cpp:0:0\n #7 0x00005f1950fcff9e mlir::RegisteredOperationName::Model<circt::comb::XorOp>::verifyInvariants(mlir::Operation*) CombDialect.cpp:0:0\n #8 0x00005f1952540efa (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) Verifier.cpp:0:0\n #9 0x00005f19525426e8 mlir::verify(mlir::Operation*, bool) (./circt-opt+0x31d76e8)\n#10 0x00005f195318ea65 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (./circt-opt+0x3e23a65)\n#11 0x00005f195318ec29 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (./circt-opt+0x3e23c29)\n#12 0x00005f195318dc1e mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (./circt-opt+0x3e22c1e)\n#13 0x00005f195318e58f mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (./circt-opt+0x3e2358f)\n#14 0x00005f195318ec29 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (./circt-opt+0x3e23c29)\n#15 0x00005f195318fc5b mlir::PassManager::run(mlir::Operation*) (./circt-opt+0x3e24c5b)\n#16 0x00005f19529aa732 performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) MlirOptMain.cpp:0:0\n#17 0x00005f19529ac006 llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::MemoryBufferRef const&, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::MemoryBufferRef, llvm::raw_ostream&)>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::MemoryBufferRef const&, llvm::raw_ostream&) MlirOptMain.cpp:0:0\n#18 0x00005f19529e3476 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::MemoryBufferRef const&, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) (./circt-opt+0x3678476)\n#19 0x00005f19529a963d mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) (.part.0) MlirOptMain.cpp:0:0\n#20 0x00005f19529ac6c8 mlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) (./circt-opt+0x36416c8)\n#21 0x00005f19529ac8c2 mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) (./circt-opt+0x36418c2)\n#22 0x00005f1950c53ff8 main (./circt-opt+0x18e8ff8)\n#23 0x000073e5fec29d90 __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:58:16\n#24 0x000073e5fec29e40 call_init ./csu/../csu/libc-start.c:128:20\n#25 0x000073e5fec29e40 __libc_start_main ./csu/../csu/libc-start.c:379:5\n#26 0x00005f1950c53895 _start (./circt-opt+0x18e8895)\n```\n\nmlir generated by `circt-verilog` presented below:\n\n```mlir\nmodule {\n  hw.module @top(in %clk : i1, in %rstn : i1) {\n    %true = hw.constant true\n    %false = hw.constant false\n    %0:2 = llhd.process -> i1, i1 {\n      cf.br ^bb1(%clk, %rstn, %false, %false : i1, i1, i1, i1)\n    ^bb1(%1: i1, %2: i1, %3: i1, %4: i1):  // 3 preds: ^bb0, ^bb2, ^bb2\n      llhd.wait yield (%3, %4 : i1, i1), (%clk, %rstn : i1, i1), ^bb2(%1, %2 : i1, i1)\n    ^bb2(%5: i1, %6: i1):  // pred: ^bb1\n      %7 = comb.xor bin %5, %true : i1\n      %8 = comb.and bin %7, %clk : i1\n      %9 = comb.xor bin %rstn, %true : i1\n      %10 = comb.and bin %6, %9 : i1\n      %11 = comb.or bin %8, %10 : i1\n      cf.cond_br %11, ^bb1(%clk, %rstn, %false, %true : i1, i1, i1, i1), ^bb1(%clk, %rstn, %false, %false : i1, i1, i1, i1)\n    }\n    hw.output\n  }\n}\n```",
    "labels": [
      "LLHD"
    ],
    "createdAt": "2025-09-24T16:10:55Z"
  },
  {
    "issue_number": 9124,
    "title": "How to obtain Core-only (hw/comb/seq) MLIR from verilog?",
    "body": "circt-bmc does not accept LLHD;\n\nVerilog -> Moore -> Core still emits llhd.*, how to obtain Core-only (hw/comb/seq) MLIR for BMC?\n\nThank you!",
    "labels": [],
    "createdAt": "2025-10-21T12:45:18Z"
  },
  {
    "issue_number": 9191,
    "title": "MLIR pattern checks failing",
    "body": "@fabianschuiki, @maerhart and I noticed while debugging some conversion that adding the flag `-DMLIR_ENABLE_EXPENSIVE_PATTERN_API_CHECKS=ON` to a CIRCT LLVM build exposes several places where our passes are using the MLIR rewriter/pattern API invalidly.\n\nRunning `ninja check-circt` produces failures on the following tests:\n\n```\nCIRCT :: Conversion/ArcToLLVM/lower-arc-to-llvm.mlir\nCIRCT :: Conversion/CombToArith/comb-to-arith.mlir\nCIRCT :: Conversion/ConvertToArcs/convert-to-arcs.mlir\nCIRCT :: Conversion/HWToLLVM/convert_aggregates.mlir\nCIRCT :: Conversion/LoopScheduleToCalyx/convert_pipeline.mlir\nCIRCT :: Conversion/LoopScheduleToCalyx/pipeline_register_pass.mlir\nCIRCT :: Conversion/SCFToCalyx/cider_source_location.mlir\nCIRCT :: Conversion/SCFToCalyx/convert_controlflow.mlir\nCIRCT :: Conversion/SCFToCalyx/convert_func.mlir\nCIRCT :: Conversion/SCFToCalyx/convert_memory.mlir\nCIRCT :: Conversion/SCFToCalyx/convert_simple.mlir\nCIRCT :: Conversion/SCFToCalyx/errors.mlir\nCIRCT :: Conversion/SCFToCalyx/float_compare.mlir\nCIRCT :: Conversion/SCFToCalyx/write_memory.mlir\nCIRCT :: Dialect/Arc/arc-canonicalizer.mlir\nCIRCT :: Dialect/Arc/canonicalizers.mlir\nCIRCT :: Dialect/Arc/lower-sim.mlir\nCIRCT :: Dialect/Calyx/affine-ploop-unparallelize.mlir\nCIRCT :: Dialect/Calyx/canonicalization.mlir\nCIRCT :: Dialect/FIRRTL/canonicalization.mlir\nCIRCT :: Dialect/LLHD/Canonicalization/processes.mlir\nCIRCT :: Transforms/memory_banking.mlir\nCIRCT :: Transforms/memory_banking_attrs.mlir\nCIRCT :: Transforms/memory_banking_multi_config.mlir\nCIRCT :: Transforms/memory_banking_multi_dim.mlir\nCIRCT :: arcilator/arcilator.mlir\nCIRCT :: arcilator/compreg.mlir\nCIRCT :: arcilator/emit-values.mlir\n\n```",
    "labels": [],
    "createdAt": "2025-11-05T16:47:22Z"
  },
  {
    "issue_number": 9234,
    "title": "[ImportVerilog] Functionality for real number format specifiers not defined",
    "body": "I initially added added some basic support for real number format specifiers in PR #8848 some months ago. Due to school I have been busy and unable to follow up. I believe the functionality still needs to be implemented. I apologize for forgetting about this until now. More info at **_IEEE 1800-2017 \u00a7 21.2.1.2 \"Format specifications\"_**.",
    "labels": [
      "ImportVerilog"
    ],
    "createdAt": "2025-11-17T01:43:55Z"
  },
  {
    "issue_number": 9238,
    "title": "Why does Moore lower to LLHD instead of directly lowering to core/seq?",
    "body": "Hi, I have a question. Why does Moore lower to LLHD instead of directly lowering to core/seq? Would it be more convenient to lower to core/seq directly? Thanks!",
    "labels": [],
    "createdAt": "2025-11-18T14:58:07Z"
  },
  {
    "issue_number": 9467,
    "title": "[circt-verilog][arcilator] `arcilator` fails to lower `llhd.constant_time` generated from simple SV delay (`#1`)",
    "body": "## Title\n[circt-verilog][arcilator] `arcilator` fails to lower `llhd.constant_time` generated from simple SV delay (`#1`)\n\n## Summary\nI ran into a failure in the arcilator flow with a minimal SystemVerilog module using a single `#1` delay. The same design runs under Verilator, but arcilator reports `llhd.constant_time` as illegal during conversion to `arcs` and stops. I did a preliminary source-level analysis (below) and would like to discuss with maintainers whether this behavior is expected or should be treated as a bug.\n\n## Details\n\nThe SV design is intentionally minimal and only uses an `initial` block with a\nsingle `#1` delay. There are no clocks, resets, or inputs. The only signals are\ntwo outputs (`q` and `ok`) to indicate observable state and a success message.\n\nBehavior:\n- At time 0, both `q` and `ok` are set to `0`.\n- After `#1`, `q` is set to `1`, `ok` is set to `1`, and a `$display` message is\n  printed.\n\nObserved issue:\n- `circt-verilog --ir-hw` converts the `#1` delay into `llhd.constant_time`.\n- The arcilator pipeline then fails when lowering to `arcs`, reporting that\n  `llhd.constant_time` is illegal and the conversion fails.\n- The same SV code runs successfully under Verilator, so the issue appears\n  specific to the arcilator lowering path.\n\n\n## Reproduction\n### arcilator\nCreate `top.sv`:\n```systemverilog\nmodule top(output logic q, output logic ok);\n  initial begin\n    q = 1'b0;\n    ok = 1'b0;\n    #1 q = 1'b1;\n    ok = 1'b1;\n    $display(\"OK: arcilator run completed\");\n  end\nendmodule\n```\n\nRun:\n```bash\ncirct-verilog --ir-hw top.sv -o top.mlir\narcilator top.mlir --state-file=top.json | opt -O3 --strip-debug -S | llc -O3 --filetype=obj -o top.o\ncc top.o -o top\n./top\n```\n\n### verilator\nUse the same `top.sv` content as above.\n\nRun:\n```bash\nverilator -Wall --cc top.sv --exe sim_main.cpp\nmake -C obj_dir -f Vtop.mk Vtop\n./obj_dir/Vtop\n```\n\n## Actual Result (arcilator)\n```\ntop.mlir:4:10: error: failed to legalize operation 'llhd.constant_time' that was explicitly marked illegal\n    %0 = llhd.constant_time <1000000fs, 0d, 0e>\n         ^\ntop.mlir:1:1: error: conversion to arcs failed\nmodule {\n^\n```\n\n## Expected Result\nThe minimal delay should either:\n- be supported by arcilator, or\n- be lowered to something legal for `arcs` without failing.\n\n### Question:\nHow to solve this problem and simulate this sv problem?\n\n## Analysis of Failure Cause\nBased on the current sources, my preliminary analysis is that the failure stems from a missing legalization pattern in the `ConvertToArcs` pass:\n- `llhd.constant_time` is a valid LLHD op produced by `circt-verilog --ir-hw` for `#1` delays.\n- The arcilator pipeline runs `ConvertToArcs`, which marks the entire LLHD dialect illegal and only provides conversions for `llhd.combinational` and `llhd.yield`.\n\nhttps://github.com/llvm/circt/blob/3c58046f1d8fc6f5355a7f2c2b73b43ffb37ba4d/lib/Conversion/ConvertToArcs/ConvertToArcs.cpp#L567-L585\n\n- As a result, `llhd.constant_time` remains illegal with no rewrite available, and the dialect conversion reports a legalization failure.\n\n\n## Environment\n- OS: Linux 5.15.0-164-generic\n- CIRCT: firtool-1.139.0\n- LLVM: 22.0.0git\n- Verilator: 5.022 2024-02-24 (rev v5.020-157-g2b4852048)\n- Git commit: 2e2f4775452d1e0bb2c8075d845808f781268049\n\n## Notes\nThe failure appears at the `llhd.constant_time` op introduced during `circt-verilog --ir-hw`, before `arcilator` lowers to `arcs`.\n\n## Relevant Source References\n- `llhd.constant_time` is a core LLHD op that materializes a time constant. It is defined as `llhd.constant_time` in the LLHD value ops definition file. See `include/circt/Dialect/LLHD/IR/LLHDValueOps.td`.\n- The `ConvertToArcs` pass marks the entire LLHD dialect as illegal and only provides conversion patterns for `llhd.combinational` and `llhd.yield`. This means any other LLHD ops (including `llhd.constant_time`) remain illegal and will trigger a legalization failure. See `lib/Conversion/ConvertToArcs/ConvertToArcs.cpp`.\n- The arcilator pipeline explicitly runs `ConvertToArcs` as part of its arc conversion pipeline. See `lib/Tools/arcilator/pipelines.cpp`.\n",
    "labels": [
      "LLHD",
      "Arc"
    ],
    "createdAt": "2026-01-17T18:13:38Z"
  },
  {
    "issue_number": 9570,
    "title": "[Moore] Assertion in MooreToCore when module uses packed union type as port",
    "body": "## Description\n\nCIRCT crashes with assertion `detail::isPresent(Val) && \"dyn_cast on a non-existent value\"` when compiling SystemVerilog modules that use packed union types as module ports.\n\n**Likely cause**: MooreToCore conversion pass lacks a type conversion rule for packed union types (`UnionType`). When processing module ports, the type converter fails to convert `UnionType`, resulting in an invalid/null type that causes assertion failures in downstream port processing code (`getModulePortInfo` at line 259).\n\n> **Validation**: Test case accepted by: verilator, iverilog, slang\n> **IEEE 1800-2005**: Packed unions are valid (Section 7.3)\n\n## Steps to Reproduce\n\n1. Save following code as `bug.sv`\n2. Run: `circt-verilog --ir-hw bug.sv`\n\n## Test Case\n\n```systemverilog\ntypedef union packed {\n  logic [31:0] a;\n  logic [31:0] b;\n} my_union;\n\nmodule Sub(input my_union in_val, output my_union out_val);\n  assign out_val = in_val;\nendmodule\n\nmodule Top;\n  my_union data_in, data_out;\n  \n  Sub s(.in_val(data_in), .out_val(data_out));\nendmodule\n```\n\n## Error Output\n\n```\n #4 0x00007f8176f898ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007f8176f89b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007f8176f89530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n```\n\n<details>\n<summary>Full Stack Trace</summary>\n\n```\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\nStack dump:\n0.      Program arguments: /opt/firtool/bin/circt-verilog --ir-hw bug.sv\n #0 0x00007f8172d678a8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x2008a8)\n #1 0x00007f8172d652f5 llvm::sys::RunSignalHandlers() (/opt/firtool-1.139.0/bin/../lib/libLLVMSupport.so+0x1fe2f5)\n #2 0x00007f8172d68631 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x00007f8172875330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #4 0x00007f8176f898ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0\n #5 0x00007f8176f89b93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)\n #6 0x00007f8176f89530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)\n #7 0x00007f817529b438 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2a438)\n #8 0x00007f81752658ed void llvm::function_ref<void ()>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_0>(long) PatternApplicator.cpp:0:0\n #9 0x00007f8175262774 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/opt/firtool-1.139.0/bin/../lib/libMLIRRewrite.so+0x7774)\n#10 0x00007f817529cc6f (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*) DialectConversion.cpp:0:0\n#11 0x00007f817529c470 mlir::OperationConverter::convert(mlir::Operation*, bool) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2b470)\n#12 0x00007f817529cdae mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2bdae)\n#13 0x00007f81752aa8e4 void llvm::function_ref<void ()>::callback_fn<applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode)::$_0>(long) DialectConversion.cpp:0:0\n#14 0x00007f81752a1f7d applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode) DialectConversion.cpp:0:0\n#15 0x00007f81752a20fe mlir::applyFullConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x310fe)\n#16 0x00007f8176f5b231 (anonymous namespace)::MooreToCorePass::runOnOperation() MooreToCore.cpp:0:0\n#17 0x00007f81750572a5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x172a5)\n#18 0x00007f817505a7a9 mlir::PassManager::run(mlir::Operation*) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x1a7a9)\n#19 0x0000563df3daf5d0 executeWithSources(mlir::MLIRContext*, llvm::SourceMgr&) circt-verilog.cpp:0:0\n#20 0x0000563df3daadd5 execute(mlir::MLIRContext*) circt-verilog.cpp:0:0\n#21 0x0000563df3daa4b8 main (/opt/firtool/bin/circt-verilog+0x84b8)\n#22 0x00007f817285a1ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#23 0x00007f817285a28b call_init ./csu/../csu/libc-start.c:128:20\n#24 0x00007f817285a28b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#25 0x0000563df3da9b05 _start (/opt/firtool/bin/circt-verilog+0x7b05)\n[1]    1143009 segmentation fault (core dumped)  /opt/firtool/bin/circt-verilog --ir-hw bug.sv\n\n```\n\n</details>\n\n## Root Cause Analysis\n\n- **Dialect**: Moore\n- **Failing Pass**: MooreToCore\n\n### Hypotheses\n\n1. **Missing UnionType type conversion rule** (confidence: high)\n   - Evidence: [\"Test case uses 'typedef union packed' as module port type\", 'Stack trace shows crash in getModulePortInfo during port processing at line 259', \"Assertion message indicates 'dyn_cast<InOutType>' failed on non-existent value\", 'No conversion rule for UnionType exists in populateTypeConversion function (lines 2268-2409)', 'Similar types like StructType have conversion rules, but UnionType does not', 'Both UnionType and StructType implement DestructurableTypeInterface, suggesting they should be handled similarly']\n   - Mechanism: The typeConverter fails to convert UnionType when processing module ports, resulting in an invalid type that causes assertion failures\n\n2. **Type converter returns invalid non-null type** (confidence: medium)\n   - Evidence: [\"Line 245-248 checks 'if (!portTy)' and emits error\", 'However, crash still occurs, suggesting either the check is not being reached or the type is non-null but invalid', 'The assertion occurs in a different code path that may not be covered by the initial null check']\n   - Mechanism: The typeConverter may return a non-null type with incorrect MLIR type ID or metadata\n\n## Environment\n\n- **CIRCT Version**: LLVM (http://llvm.org/):\n  LLVM version 22.0.0git\n  Optimized build.\nCIRCT firtool-1.139.0\nslang version 9.1.0+0\n\n---\n**Labels**: bug, Moore",
    "labels": [],
    "createdAt": "2026-02-01T02:15:22Z"
  }
]