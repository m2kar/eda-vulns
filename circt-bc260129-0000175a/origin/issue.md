<!-- 
  CIRCT Bug Report
  Generated by circt-bug-reporter skill
-->

<!-- Title: [Moore] Mem2Reg crash with SystemVerilog class handles in always_ff blocks -->

## Description

CIRCT crashes when processing SystemVerilog `always_ff` blocks that use class object handles. The crash occurs in the LLHD Mem2Reg (Memory to Register Promotion) pass when attempting to handle signals containing `ClassHandleType`.

The root cause is that `hw::getBitWidth()` returns -1 for `ClassHandleType` (an unsupported type). When this -1 is implicitly converted to an unsigned value and passed to `IntegerType::get()`, it becomes a very large positive integer (e.g., 0x3FFFFFFF), which exceeds MLIR's maximum bitwidth limit of 16,777,215 bits.

**Crash Type**: assertion (original) / internal error (current version)
**Dialect**: Moore (SystemVerilog frontend)
**Failing Pass**: LLHD Mem2Reg
**Affected Component**: `hw::getBitWidth()` handling of ClassHandleType

## Steps to Reproduce

1. Save the test case below as `test.sv`
2. Run:
   ```bash
   circt-verilog --ir-hw test.sv
   ```

## Test Case

```systemverilog
module top(input logic clk);
  class C; endclass
  C obj;
  always_ff @(posedge clk) obj = new();
endmodule
```

## Error Output

```
test.sv:2:9: remark: Class builtin functions (needed for randomization, constraints, and covergroups) are not yet supported and will be dropped during lowering.
  class C; endclass
        ^
test.sv:3:5: error: 'hw.bitcast' op result #0 must be Type wherein the bitwidth in hardware is known, but got '!llvm.ptr'
  C obj;
    ^
test.sv:3:5: note: see current operation: %10 = "hw.bitcast"(%9) : (i1073741823) -> !llvm.ptr
```

**Note**: The original error (from older CIRCT version) was:
```
error: integer bitwidth is limited to 16777215 bits
Assertion failure in mlir::IntegerType::get() at Mem2Reg.cpp:1742
```

Both errors stem from the same root cause: `getBitWidth()` returning -1 for `ClassHandleType`.

## Root Cause Analysis

### Direct Cause

In `Mem2Reg.cpp` at the failing pass:

```cpp
auto flatType = builder.getIntegerType(hw::getBitWidth(type));
```

When `type` is a `ClassHandleType`:
1. `hw::getBitWidth(type)` returns -1 (indicating unsupported type)
2. This -1 is implicitly converted to `unsigned int`, becoming a large positive value
3. `IntegerType::get()` validates the bitwidth and fails when it exceeds 16,777,215

### Why This Happens

`ClassHandleType` represents a reference to a heap-allocated class object in SystemVerilog. Its "bitwidth" semantic is different from standard hardware types. The `getBitWidth()` function was not designed to handle class handles and returns -1 for unsupported types.

### Source Code Evidence

**hw::getBitWidth()** (HWTypes.cpp:110):
```cpp
int64_t circt::hw::getBitWidth(mlir::Type type) {
  return llvm::TypeSwitch<::mlir::Type, int64_t>(type)
      .Case<IntegerType>([](IntegerType t) { return t.getIntOrFloatBitWidth(); })
      .Default([](Type type) -> int64_t {
        if (auto iface = dyn_cast<BitWidthTypeInterface>(type)) {
          std::optional<int64_t> width = iface.getBitWidth();
          return width.has_value() ? *width : -1;
        }
        return -1;  // ClassHandleType falls here
      });
}
```

**Mem2Reg.cpp** (line ~1753):
```cpp
auto type = getStoredType(slot);
auto flatType = builder.getIntegerType(hw::getBitWidth(type));
//                                     ^^^^^^^^^^^^^^^^^^^^^^^^^
//                        Returns -1 for ClassHandleType
//                        Which becomes a huge unsigned value
```

## Environment

- **CIRCT Version**: firtool-1.139.0
- **LLVM Version**: 22.0.0git
- **OS**: Linux 5.15.0-164-generic
- **Architecture**: x86_64

## Suggested Fix

### Short-term Fix

Add validation in `Mem2Reg.cpp` before creating `IntegerType`:

```cpp
auto type = getStoredType(slot);
int64_t bitWidth = hw::getBitWidth(type);
if (bitWidth < 0) {
  // Handle unsupported types gracefully
  return emitError(...) << "unsupported type for mem2reg promotion: " << type;
}
auto flatType = builder.getIntegerType(static_cast<unsigned>(bitWidth));
```

### Long-term Fix

1. Convert `hw::getBitWidth()` to return `std::optional<uint64_t>` instead of -1
2. Filter out slots containing `ClassHandleType` in Mem2Reg's `findPromotableSlots()` phase
3. Define clear memory representation for class types (e.g., pointer size)
4. Add compiler diagnostics when class types are used in unsupported hardware contexts

## Related Issues

- **#9287** - `[HW] Make hw::getBitWidth use std::optional vs -1`
  - This issue directly addresses the root cause by changing the API design
  - Our test case provides a concrete example of the crash caused by getBitWidth() returning -1
  - Status: OPEN

- **#8245** - `[LLHD] Mem2Reg crash on reasonable input`
  - Similar Mem2Reg crash at the same location (Mem2Reg.cpp:1742)
  - Different root cause but same error location
  - Status: CLOSED

- **#7483** - `[Moore] Mem2Reg Error`
  - Mem2Reg error with Moore types
  - Demonstrates Mem2Reg's incomplete support for Moore dialect
  - Status: CLOSED

---
*This issue was generated with assistance from an automated bug reporter.*
