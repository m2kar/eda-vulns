<!--
  CIRCT Bug Report
  Testcase ID: 260128-00000ee6
  Generated by automated bug reporter
-->

<!-- Title: $ISSUE_TITLE -->

## Description

$ROOT_CAUSE_SUMMARY

**Crash Type**: assertion
**Dialect**: Comb (comb::ExtractOp, comb::ConcatOp)
**Failing Pass**: Canonicalizer

The \`extractConcatToConcatExtract\` pattern in \`CombFolds.cpp\` attempts to optimize \`ExtractOp\` operations that extract from \`ConcatOp\`. When \`reverseConcatArgs.size() == 1\`, the pattern calls \`replaceOpAndCopyNamehint()\` to replace the \`ExtractOp\` with a single value from the concat's inputs. However, the pattern does not verify that the underlying \`ConcatOp\` or \`ExtractOp\` being replaced has no remaining uses before attempting the erase operation, causing an assertion failure.

The crash occurs when a SystemVerilog \`always_comb\` block has multiple assignments from the same wire, creating multiple \`ExtractOp\` instances that all depend on the same \`ConcatOp\`. When the canonicalization pattern attempts to replace one of these \`ExtractOp\` instances, the \`ConcatOp\` still has other uses (from the other assignments), triggering the assertion in \`mlir::RewriterBase::eraseOp()\` that checks \`op->use_empty()\`.

## Steps to Reproduce

1. Save the following test case as \`test.sv\`:
\`\`\`systemverilog
module m(
  output logic [3:0] a
);

  logic w = 1'b0;

  always_comb begin
    a[0] = w;
    a[1] = w;
  end

endmodule
\`\`\`

2. Run:
   \`\`\`bash
   export PATH=/opt/llvm-22/bin:\$PATH
   circt-verilog --ir-hw test.sv
   \`\`\`

## Test Case

\`\`\`systemverilog
module m(
  output logic [3:0] a
);

  logic w = 1'b0;

  always_comb begin
    a[0] = w;
    a[1] = w;
  end

endmodule
\`\`\`

**Lines**: 11 (reduced from 16, 59% reduction)
**Key constructs**: 
- \`always_comb\` procedural block
- Array assignment \`a[0] = w;\`
- Multiple assignments from same wire

## Error Output

\`\`\`
circt-verilog: /root/circt/llvm/mlir/lib/IR/PatternMatch.cpp:156: virtual void mlir::RewriterBase::eraseOp(Operation *): Assertion \`op->use_empty() && "expected 'op' to have no uses"'\` failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: /home/zhiqing/edazz/circt/build/bin/circt-verilog --ir-hw bug.sv
 #0 0x0000555995c3a88 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /root/circt/llvm/llvm/lib/Support/Unix/Signals.inc:842:13
 #1 0x0000555995c9673 llvm::sys::RunSignalHandlers() /root/circt/llvm/llvm/lib/Support/Signals.cpp:109:18
 #2 0x0000555995c97c1 SignalHandler(int, siginfo_t*, void*) /root/circt/llvm/llvm/lib/Support/Unix/Signals.inc:429:38
 #3 0x00007f8e1dc8330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)
 #4 0x00007f8e1d94cb2c __pthread_kill_implementation ./nptl/pthread_kill.c:44:76
 #5 0x00007f8e1d94cb2c __pthread_kill_internal ./nptl/pthread_kill.c:78:10
 #6 0x00007f8e1d94cb2c pthread_kill ./nptl/pthread_kill.c:89:10
 #7 0x00007f8e1dcb427e raise ./signal/../sysdeps/posix/raise.c:27:6
 #8 0x00007f8e1cb658ff abort ./stdlib/abort.c:81:7
 #9 0x00007f8e1cb6581b _nl_load_domain ./intl/loadmsgcat.c:1177:9
#10 0x00007f8e1dcb0517 (/lib/x86_64-linux-gnu/libc.so.6+0x3b517)
#11 0x0000555978cdf0 mlir::IRObjectWithUseList<mlir::BlockOperand>::use_empty() const /root/circt/llvm/mlir/lib/IR/PatternMatch.cpp:232:0
#12 0x0000555978cdf0 mlir::RewriterBase::eraseBlock(mlir::Block*) /root/circt/llvm/mlir/lib/IR/PatternMatch.cpp:233:17
#13 0x000055597878cb64 mlir::RewriterBase::replaceOp(mlir::Operation*, mlir::ValueRange) /root/circt/llvm/mlir/lib/IR/PatternMatch.cpp:136:1
#14 0x000055595c0d22 circt::replaceOpAndCopyNamehint(mlir::PatternRewriter&, mlir::Operation*, mlir::Value) /root/circt/lib/Support/Naming.cpp:82:1
#15 0x0000555941b4f73 extractConcatToConcatExtract(circt::comb::ExtractOp, circt::comb::ConcatOp, mlir::PatternRewriter&) /root/circt/lib/Dialect/Comb/CombFolds.cpp:548:3
\`\`\`

## Root Cause Analysis

### Hypothesis 1 (High Confidence)
**Cause**: The \`extractConcatToConcatExtract\` pattern doesn't check for remaining uses before replacement.

**Evidence**:
- Assertion occurs when \`replaceOpAndCopyNamehint()\` tries to erase an operation with active uses
- Pattern at CombFolds.cpp:548 calls \`replaceOpAndCopyNamehint()\` without checking \`op->use_empty()\` or \`innerCat->use_empty()\`
- Testcase has multiple assignments from same wire, suggesting multiple IR operations depend on same ConcatOp
- Stack trace shows crash in \`eraseOp()\` called from \`replaceOpAndCopyNamehint()\`

**Mechanism**: Multiple \`ExtractOp\` instances from \`always_comb\` block depend on same \`ConcatOp\`. Pattern tries to replace one \`ExtractOp\`, but \`ConcatOp\` still has other uses (from other assignments), causing assertion failure when \`eraseOp()\` is called.

**Fix Suggestions**:
1. Add use checks before replacement (check \`op->use_empty()\` or \`innerCat->use_empty()\`)
2. Use \`replaceAllOpUsesWith\` instead of \`replaceOp()\` to avoid erasing operations with active uses
3. Validate dependencies before applying optimization using \`isOpTriviallyDead()\`
4. Add defensive programming with explicit use list checking

## Environment

- **CIRCT Version**: LLVM 22.0.0git
- **OS**: Linux 5.15.0
- **Architecture**: x86_64
- **Command**: \`circt-verilog --ir-hw bug.sv\`

## Stack Trace

<details>
<summary>Click to expand stack trace</summary>

\`\`\`
#0  llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /root/circt/llvm/llvm/lib/Support/Unix/Signals.inc:842:13
#1  llvm::sys::RunSignalHandlers() /root/circt/llvm/llvm/lib/Support/Signals.cpp:109:18
#2  SignalHandler(int, siginfo_t*, void*) /root/circt/llvm/mlir/lib/IR/Unix/Signals.inc:429:38
#3  (libc)
#4  __pthread_kill_implementation ./nptl/pthread_kill.c:44:76
#5  __pthread_kill_internal ./nptl/pthread_kill.c:78:10
#6  pthread_kill ./nptl/pthread_kill.c:89:10
#7  raise ./signal/../sysdeps/posix/raise.c:27:6
#8  abort ./stdlib/abort.c:81:7
#9  _nl_load_domain ./intl/loadmsgcat.c:1177:9
#10  (libc)
#11 mlir::IRObjectWithUseList<mlir::BlockOperand>::use_empty() const /root/circt/llvm/mlir/lib/IR/PatternMatch.cpp:232:0
#12 mlir::RewriterBase::eraseBlock(mlir::Block*) /root/circt/llvm/mlir/lib/IR/PatternMatch.cpp:233:17
#13 mlir::RewriterBase::replaceOp(mlir::Operation*, mlir::ValueRange) /root/circt/llvm/mlir/lib/IR/PatternMatch.cpp:136:1
#14 circt::replaceOpAndCopyNamehint(mlir::PatternRewriter&, mlir::Operation*, mlir::Value) /root/circt/lib/Support/Naming.cpp:82:1
#15 extractConcatToConcatExtract(circt::comb::ExtractOp, circt::comb::ConcatOp, mlir::PatternRewriter&) /root/circt/lib/Dialect/Comb/CombFolds.cpp:548:3
\`\`\`

</details>

## Related Issues

No duplicates were found. Due to network/API limitations, a comprehensive duplicate search could not be performed.

**Keywords for manual search**:
- \`extractConcatToConcatExtract\`
- \`ReplaceOp\`
- \`use_empty\`
- \`canonicalization\`
- \`ExtractOp\`
- \`ConcatOp\`
- \`always_comb\`
- \`multiple assignments\`
- \`CombFolds\`
- \`assertion failure\`

Please search GitHub Issues manually for these keywords before submitting.

## Additional Information

- **Testcase Reduction**: 31% fewer lines, 59% fewer characters than original
- **Validation**: Syntax valid (slang), no unsupported features, cross-tools (Verilator, Icarus) accept testcase
- **Original testcase**: 16 lines, SystemVerilog with module input, internal wire, array output, and multiple assignments
- **Minimized testcase**: 11 lines, constant wire, only essential elements preserved

---

*This issue was generated with assistance from an automated bug reporter.*
