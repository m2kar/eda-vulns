<!--
  CIRCT Bug Report
  Generated by circt-bug-reporter skill
-->

<!-- Title: [Moore] Assertion failure in getModulePortInfo when module has string-typed ports -->

## Description

CIRCT's Moore dialect crashes when processing a SystemVerilog module with `string` type ports. The type converter successfully converts Moore's `StringType` to `sim::DynamicStringType`, but HW dialect's module port infrastructure does not support this type. When `getModulePortInfo()` constructs `hw::PortInfo` with the converted type, a subsequent `dyn_cast<InOutType>` operation fails because `DynamicStringType` is not a valid HW port type, causing an assertion failure.

**Crash Type**: assertion
**Dialect**: Moore
**Failing Pass**: MooreToCorePass

While `string` type is not synthesizable to hardware, CIRCT should reject it with a clear error message rather than crashing with an assertion failure.

## Steps to Reproduce

1. Save test case below as `test.sv`
2. Run:
   ```bash
   circt-verilog --ir-hw test.sv
   ```

## Test Case

```systemverilog
module test(input string s);
endmodule
```

## Error Output

```
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: circt-verilog --ir-hw test.sv
 #4 0x00007fc6ba06f8ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0
...
Exit code: 139
```

## Root Cause Analysis

### Hypothesis 1 (High Confidence) ⭐
**Cause**: HW dialect does not support `sim::DynamicStringType` as a valid module port type

**Evidence**:
- Type conversion exists: `StringType` → `sim::DynamicStringType`
- `DynamicStringType` is in `sim` dialect, not `hw` dialect
- HW module ports expect hardware-synthesizable types (integers, arrays, structs)
- No validation exists to reject unsupported port types before construction

**Mechanism**:
The type converter happily converts `StringType` to `DynamicStringType`, but this type cannot be used in HW module ports. When `hw::ModulePortInfo` is constructed and subsequently processed, internal operations expecting hardware types (like `dyn_cast<InOutType>`) fail because `DynamicStringType` is not a hardware type.

### Processing Path

1. Parse SystemVerilog `string` type port declarations
2. Create Moore dialect representation with `StringType`
3. MooreToCorePass attempts conversion
4. `getModulePortInfo()` calls `typeConverter.convertType(port.type)`
5. `StringType` → `sim::DynamicStringType` conversion succeeds
6. `hw::PortInfo` is created with `DynamicStringType`
7. **[FAILS]** Later code attempts `dyn_cast<InOutType>` on a type that is not supported

## Environment

- **CIRCT Version**: firtool-1.139.0
- **OS**: Linux
- **Architecture**: x86_64

## Stack Trace

<details>
<summary>Click to expand stack trace</summary>

```
 #4 0x00007fc6ba06f8ae (anonymous namespace)::SVModuleOpConversion::matchAndRewrite(circt::moore::SVModuleOp, circt::moore::SVModuleOpAdaptor, mlir::ConversionPatternRewriter&) const MooreToCore.cpp:0:0
 #5 0x00007fc6ba06fb93 llvm::LogicalResult mlir::ConversionPattern::dispatchTo1To1<mlir::OpConversionPattern<circt::moore::SVModuleOp>, circt::moore::SVModuleOp>(mlir::OpConversionPattern<circt::moore::SVModuleOp> const&, circt::moore::SVModuleOp, circt::moore::SVModuleOp::GenericAdaptor<llvm::ArrayRef<mlir::ValueRange>>, mlir::ConversionPatternRewriter&) (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50b93)
 #6 0x00007fc6ba06f530 mlir::OpConversionPattern<circt::moore::SVModuleOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::ValueRange>, mlir::ConversionPatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libCIRCTMooreToCore.so+0x50530)
 #7 0x00007fc6b8381438 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2a438)
 #8 0x00007fc6b834b8ed void llvm::function_ref<void ()>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_0>(long) PatternApplicator.cpp:0:0
 #9 0x00007fc6b8348774 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/opt/firtool-1.139.0/bin/../lib/libMLIRRewrite.so+0x7774)
#10 0x00007fc6b8382c6f (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*) DialectConversion.cpp:0:0
#11 0x00007fc6b8382470 mlir::OperationConverter::convert(mlir::Operation*, bool) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2b470)
#12 0x00007fc6b8382dae mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x2bdae)
#13 0x00007fc6b83908e4 void llvm::function_ref<void ()>::callback_fn<applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode)::$_0>(long) DialectConversion.cpp:0:0
#14 0x00007fc6b8387f7d applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode) DialectConversion.cpp:0:0
#15 0x00007fc6b83880fe mlir::applyFullConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/opt/firtool-1.139.0/bin/../lib/libMLIRTransformUtils.so+0x310fe)
#16 0x00007fc6ba041231 (anonymous namespace)::MooreToCorePass::runOnOperation() MooreToCore.cpp:0:0
#17 0x00007fc6b813d2a5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x172a5)
#18 0x00007fc6b81407a9 mlir::PassManager::run(mlir::Operation*) (/opt/firtool-1.139.0/bin/../lib/libMLIRPass.so+0x1a7a9)
#19 0x000055bb8f0e75d0 executeWithSources(mlir::MLIRContext*, llvm::SourceMgr&) circt-verilog.cpp:0:0
#20 0x000055bb8f0e2dd5 execute(mlir::MLIRContext*) circt-verilog.cpp:0:0
```

</details>

## Related Issues

- #8283 - [ImportVerilog] Cannot compile forward declared string type (Related: string type support in MooreToCore, but different crash location - variables vs ports)
- #8332 - [MooreToCore] Support for StringType from moore to llvm dialect (Related: StringType lowering discussion, but feature request not bug report)
- #7628 - [MooreToCore] Support string constants (Closed: Different feature - constants vs port types)

## Suggested Fix

Add validation in `getModulePortInfo()` (MooreToCore.cpp:~243) to check if converted port types are HW-compatible before constructing hw::PortInfo:

```cpp
Type portTy = typeConverter.convertType(port.type);
if (!portTy || !isHWCompatibleType(portTy)) {
  return op.emitError("unsupported port type: ") << port.type;
}
```

This would emit a friendly error message instead of crashing with an assertion failure.

---
*This issue was generated with assistance from an automated bug reporter.*